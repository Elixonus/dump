commit 5d57c56d19c67cb5d414c588b20fc9c470aa2b1d
Author: Elias Dobrin <elias@dobrin.net>
Date:   Fri Jul 1 13:08:28 2022 -0700

    Update softbodies.py

diff --git a/softbodies.py b/softbodies.py
index f4a5bb6..51e63ce 100644
--- a/softbodies.py
+++ b/softbodies.py
@@ -53,14 +53,14 @@ class Link:
         """Get the momentary length of the link."""
         return Vector.dist(self.nodes[0].position, self.nodes[1].position)
 
-    def get_velocity(self) -> float:
-        """Get the speed of the expansion/contraction of the link (positive/negative)."""
-        return Vector.dot(self.nodes[0].position - self.nodes[1].position, self.nodes[0].velocity - self.nodes[1].velocity) / self.get_length()
-
     def get_displacement(self) -> float:
         """Get the expansion/contraction of the link from its resting configuration (positive/negative)."""
         return self.get_length() - self.length
 
+    def get_velocity(self) -> float:
+        """Get the speed of the expansion/contraction of the link (positive/negative)."""
+        return Vector.dot(self.nodes[0].position - self.nodes[1].position, self.nodes[0].velocity - self.nodes[1].velocity) / self.get_length()
+
     def get_stiffness_force(self) -> float:
         """Get the spring stiffness force expansion/contraction (positive/negative)."""
         return -self.stiffness * self.get_displacement()

commit e2f02a7b0e028f65eb3a62281fd986abf703b9ba
Author: Elias Dobrin <elias@dobrin.net>
Date:   Mon Jun 20 10:20:30 2022 -0700

    typo in vectors

diff --git a/vectors.py b/vectors.py
index 88a1b37..7ae6336 100644
--- a/vectors.py
+++ b/vectors.py
@@ -68,11 +68,11 @@ class Vector:
         return self.copy().mul(-1)
 
     def __matmul__(self, vector: Vector, /) -> float:
-        """(@) Find the dot product of two vectors as vectors."""
+        """(@) Find the dot product of two vectors."""
         return self.dot(vector)
 
     def __mod__(self, vector: Vector, /) -> float:
-        """(%) Find the cross product of two vectors as vectors."""
+        """(%) Find the cross product of two vectors."""
         return self.cross(vector)
 
     def set(self, vector: Vector, /) -> Vector:

commit 601089ab497ac81ef28db7c04c3071b4b825e2a3
Author: Elias Dobrin <elias@dobrin.net>
Date:   Fri Jun 17 10:01:22 2022 -0700

    Delete softbots.py

diff --git a/softbots.py b/softbots.py
deleted file mode 100644
index 295d165..0000000
--- a/softbots.py
+++ /dev/null
@@ -1,24 +0,0 @@
-from __future__ import annotations
-from softbodies import Node, Link
-
-
-class Softbot:
-    nodes: list[Node]
-    links: list[Link]
-    muscles: list[Muscle]
-
-    def __init__(self, nodes: list[Node], links: list[Link], muscles: list[Muscle]) -> None:
-        self.nodes = nodes
-        self.links = links
-        self.muscles = muscles
-
-
-class Muscle(Link):
-    length_original: float
-
-    def __init__(self, nodes: tuple[Node, Node], stiffness: float, dampening: float, length: float = None) -> None:
-        super().__init__(nodes, stiffness, dampening, length)
-        self.length_original = length
-
-    def set_length(self, activation) -> None:
-        self.length = self.length_original * min(max((1 - 0.5 * activation), 0), 1)

commit 61ba9383f8419a5f2b7049b67b05a47887aa68f4
Author: Elias Dobrin <elias@dobrin.net>
Date:   Fri Jun 17 09:59:05 2022 -0700

    softbots class added

diff --git a/softbots.py b/softbots.py
new file mode 100644
index 0000000..295d165
--- /dev/null
+++ b/softbots.py
@@ -0,0 +1,24 @@
+from __future__ import annotations
+from softbodies import Node, Link
+
+
+class Softbot:
+    nodes: list[Node]
+    links: list[Link]
+    muscles: list[Muscle]
+
+    def __init__(self, nodes: list[Node], links: list[Link], muscles: list[Muscle]) -> None:
+        self.nodes = nodes
+        self.links = links
+        self.muscles = muscles
+
+
+class Muscle(Link):
+    length_original: float
+
+    def __init__(self, nodes: tuple[Node, Node], stiffness: float, dampening: float, length: float = None) -> None:
+        super().__init__(nodes, stiffness, dampening, length)
+        self.length_original = length
+
+    def set_length(self, activation) -> None:
+        self.length = self.length_original * min(max((1 - 0.5 * activation), 0), 1)

commit 0747495f4d61ff7ef64662982d4d6b113e001502
Author: Elias Dobrin <elias@dobrin.net>
Date:   Wed Jun 15 10:34:07 2022 -0700

    added friction file and hanging 2 file

diff --git a/sb_dropping.py b/sb_dropping.py
index e4977b2..cc67286 100644
--- a/sb_dropping.py
+++ b/sb_dropping.py
@@ -80,9 +80,9 @@ for i in range(iterations):
         node.velocity.add(node.acceleration * (time / iterations))
         node.position.add(node.velocity * (time / iterations))
     if i % round(iterations / time / 60) == 0:
-        surface = cairo.ImageSurface(cairo.FORMAT_RGB24, 500, 500)
+        surface = cairo.ImageSurface(cairo.FORMAT_RGB24, 1000, 1000)
         context = cairo.Context(surface)
-        context.scale(500, 500)
+        context.scale(1000, 1000)
         context.rectangle(0, 0, 1, 1)
         context.set_source_rgb(0.29, 0.17, 0)
         context.fill_preserve()
diff --git a/sb_friction.py b/sb_friction.py
new file mode 100644
index 0000000..a22f1ef
--- /dev/null
+++ b/sb_friction.py
@@ -0,0 +1,122 @@
+import os
+from math import pi, tau, sqrt
+import cairo
+import ffmpeg
+from structures import Tower
+from vectors import Vector
+
+input_f = 0.5
+
+while True:
+    try:
+        data = input("ENTER FRICTION COEFFICIENT (0-1): ")
+        input_f = float(data)
+        if 0 <= input_f <= 1:
+            break
+        else:
+            print("VALUE NOT BETWEEN THE SPECIFIED RANGE.")
+        continue
+    except ValueError:
+        print("VALUE IS INVALID.")
+        continue
+
+os.makedirs("output", exist_ok=True)
+for png in os.scandir("output"):
+    os.remove(png)
+
+time = 5
+iterations = 10000
+f = 0
+camera_position = Vector(0.5, 0.5)
+camera_zoom = 0.9
+softbody = Tower(width=0.3, height=0.3, grid=(3, 3), mass=1, stiffness=150, dampening=0.5)
+softbody.rotate(pi / 12)
+softbody.translate(Vector(0.15, 0.2))
+nodes = softbody.nodes
+links = softbody.links
+for node in nodes:
+    node.velocity.add(Vector(1, 0))
+
+print()
+for i in range(iterations):
+    print(f"SOLVING DIFFERENTIAL EQUATIONS: {round(100 * (i + 1) / iterations)}%", end="\r")
+    for node in nodes:
+        node.force.set(Vector(0, 0))
+    for node in nodes:
+        node.force.add(Vector(0, -2.8 * node.mass))
+    for link in links:
+        node_1 = link.nodes[0]
+        node_2 = link.nodes[1]
+        node_1_force = link.get_force() * (
+                node_1.position - node_2.position
+        ) / Vector.dist(node_1.position, node_2.position)
+        node_1.force.add(node_1_force)
+        node_2.force.sub(node_1_force)
+    for node in nodes:
+        if node.position.x < 0:
+            node_force_normal = Vector(-500 * node.position.x, 0)
+            node.force.add(node_force_normal)
+        if node.position.y < 0:
+            node_force_normal = Vector(0, -500 * node.position.y)
+            if node.velocity.x < 0:
+                node_force_friction = Vector(0.3 * input_f * node_force_normal.y, 0)
+            else:
+                node_force_friction = Vector(-0.3 * input_f * node_force_normal.y, 0)
+            node.force.add(node_force_normal + node_force_friction)
+        if node.position.x > 1:
+            node_force_normal = Vector(500 * (1 - node.position.x), 0)
+            node.force.add(node_force_normal)
+        if node.position.y > 1:
+            node_force_normal = Vector(0, 500 * (1 - node.position.y))
+            node.force.add(node_force_normal)
+    for node in nodes:
+        node.acceleration = node.force / node.mass
+        node.velocity.add(node.acceleration * (time / iterations))
+        node.position.add(node.velocity * (time / iterations))
+    if i % round(iterations / time / 60) == 0:
+        surface = cairo.ImageSurface(cairo.FORMAT_RGB24, 1000, 1000)
+        context = cairo.Context(surface)
+        context.scale(1000, 1000)
+        context.rectangle(0, 0, 1, 1)
+        context.set_source_rgb(0.29, 0.17, 0)
+        context.fill_preserve()
+        gradient = cairo.RadialGradient(0.5, 0.5, 0, 0.5, 0.5, sqrt(2) / 2)
+        gradient.add_color_stop_rgba(0, 0, 0, 0, 0)
+        gradient.add_color_stop_rgba(1, 0, 0, 0, 0.2)
+        context.set_source(gradient)
+        context.fill()
+        context.translate(0.5, 0.5)
+        context.scale(1, -1)
+        context.scale(camera_zoom, camera_zoom)
+        context.translate(-camera_position.x, -camera_position.y)
+
+        context.rectangle(0, 0, 1, 1)
+        context.set_source_rgb(0.5, 0.94, 1)
+        context.fill_preserve()
+        context.set_source_rgb(0, 0, 0)
+        context.set_line_width(0.01)
+        context.stroke()
+
+        for link in links:
+            context.move_to(link.nodes[0].position.x, link.nodes[0].position.y)
+            context.line_to(link.nodes[1].position.x, link.nodes[1].position.y)
+            context.set_source_rgb(0, 0, 0)
+            context.set_line_width(0.01 * (link.length / link.get_length()))
+            context.stroke()
+
+        for node in nodes:
+            context.arc(node.position.x, node.position.y, 0.01, 0, tau)
+            context.set_source_rgb(1, 1, 1)
+            context.fill_preserve()
+            context.set_source_rgb(0, 0, 0)
+            context.set_line_width(0.005)
+            context.stroke()
+
+        surface.write_to_png(f"output/{f:06d}.png")
+        f += 1
+
+ffmpeg.input("output/%06d.png", pattern_type="sequence", framerate=60).output("output.mp4").run(overwrite_output=True)
+for png in os.scandir("output"):
+    os.remove(png)
+os.rmdir("output")
+os.startfile("output.mp4")
\ No newline at end of file
diff --git a/sb_hanging_1.py b/sb_hanging_1.py
index 34520cd..e681c1f 100644
--- a/sb_hanging_1.py
+++ b/sb_hanging_1.py
@@ -81,9 +81,9 @@ for i in range(iterations):
         node.velocity.add(node.acceleration * (time / iterations))
         node.position.add(node.velocity * (time / iterations))
     if i % round(iterations / time / 60) == 0:
-        surface = cairo.ImageSurface(cairo.FORMAT_RGB24, 500, 500)
+        surface = cairo.ImageSurface(cairo.FORMAT_RGB24, 1000, 1000)
         context = cairo.Context(surface)
-        context.scale(500, 500)
+        context.scale(1000, 1000)
         context.rectangle(0, 0, 1, 1)
         context.set_source_rgb(0.29, 0.17, 0)
         context.fill_preserve()
diff --git a/sb_hanging_2.py b/sb_hanging_2.py
new file mode 100644
index 0000000..63c6ccf
--- /dev/null
+++ b/sb_hanging_2.py
@@ -0,0 +1,133 @@
+import os
+from math import tau, sqrt
+import cairo
+import ffmpeg
+from structures import Tower
+from vectors import Vector
+
+input_s = 0.5
+
+while True:
+    try:
+        data = input("ENTER LINK STIFFNESS (0-1): ")
+        input_s = float(data)
+        if 0 <= input_s <= 1:
+            break
+        else:
+            print("VALUE NOT BETWEEN THE SPECIFIED RANGE.")
+        continue
+    except ValueError:
+        print("VALUE IS INVALID.")
+        continue
+
+input_d = 0.5
+
+while True:
+    try:
+        data = input("ENTER LINK DAMPENING (0-1): ")
+        input_d = float(data)
+        if 0 <= input_d <= 1:
+            break
+        else:
+            print("VALUE NOT BETWEEN THE SPECIFIED RANGE.")
+        continue
+    except ValueError:
+        print("VALUE IS INVALID.")
+        continue
+
+os.makedirs("output", exist_ok=True)
+for png in os.scandir("output"):
+    os.remove(png)
+
+time = 5
+iterations = 10000
+f = 0
+camera_position = Vector(0.5, 0.5)
+camera_zoom = 0.9
+softbody = Tower(width=0.5, height=0.5, grid=(5, 5), mass=1, stiffness=200 * input_s ** 2, dampening=2 * input_d ** 2)
+softbody.translate(Vector(0.5, 0.5))
+nodes = softbody.nodes
+links = softbody.links
+
+print()
+for i in range(iterations):
+    print(f"SOLVING DIFFERENTIAL EQUATIONS: {round(100 * (i + 1) / iterations)}%", end="\r")
+    for node in nodes:
+        node.force.set(Vector(0, 0))
+    for node in nodes:
+        node.force.add(Vector(0, -9.8 * node.mass))
+    for link in links:
+        node_1 = link.nodes[0]
+        node_2 = link.nodes[1]
+        node_1_force = link.get_force() * (
+                node_1.position - node_2.position
+        ) / Vector.dist(node_1.position, node_2.position)
+        node_1.force.add(node_1_force)
+        node_2.force.sub(node_1_force)
+    for node in nodes:
+        node_force_normal = Vector(0, 0)
+        if node.position.x < 0:
+            node_force_normal.add(Vector(-500 * node.position.x, 0))
+        if node.position.y < 0:
+            node_force_normal.add(Vector(0, -500 * node.position.y))
+        if node.position.x > 1:
+            node_force_normal.add(Vector(500 * (1 - node.position.x), 0))
+        if node.position.y > 1:
+            node_force_normal.add(Vector(0, 500 * (1 - node.position.y)))
+        node.force.add(node_force_normal)
+    softbody.nodes_tower[0][-1].force.set(Vector(0, 0))
+    softbody.nodes_tower[-1][-1].force.set(Vector(0, 0))
+    for node in nodes:
+        node.acceleration = node.force / node.mass
+        node.velocity.add(node.acceleration * (time / iterations))
+        node.position.add(node.velocity * (time / iterations))
+    if i % round(iterations / time / 60) == 0:
+        surface = cairo.ImageSurface(cairo.FORMAT_RGB24, 1000, 1000)
+        context = cairo.Context(surface)
+        context.scale(1000, 1000)
+        context.rectangle(0, 0, 1, 1)
+        context.set_source_rgb(0.29, 0.17, 0)
+        context.fill_preserve()
+        gradient = cairo.RadialGradient(0.5, 0.5, 0, 0.5, 0.5, sqrt(2) / 2)
+        gradient.add_color_stop_rgba(0, 0, 0, 0, 0)
+        gradient.add_color_stop_rgba(1, 0, 0, 0, 0.2)
+        context.set_source(gradient)
+        context.fill()
+        context.translate(0.5, 0.5)
+        context.scale(1, -1)
+        context.scale(camera_zoom, camera_zoom)
+        context.translate(-camera_position.x, -camera_position.y)
+
+        context.rectangle(0, 0, 1, 1)
+        context.set_source_rgb(0.5, 0.94, 1)
+        context.fill_preserve()
+        context.set_source_rgb(0, 0, 0)
+        context.set_line_width(0.01)
+        context.stroke()
+
+        for link in links:
+            context.move_to(link.nodes[0].position.x, link.nodes[0].position.y)
+            context.line_to(link.nodes[1].position.x, link.nodes[1].position.y)
+            context.set_source_rgb(0.5 * abs(link.get_force()), 0, 0)
+            context.set_line_width(0.01 * (link.length / link.get_length()))
+            context.stroke()
+
+        for node in nodes:
+            context.arc(node.position.x, node.position.y, 0.01, 0, tau)
+            context.set_source_rgb(1, 1, 1)
+            context.fill_preserve()
+            if node is softbody.nodes_tower[0][-1] or node is softbody.nodes_tower[-1][-1]:
+                context.set_source_rgb(1, 0, 0)
+            else:
+                context.set_source_rgb(0, 0, 0)
+            context.set_line_width(0.005)
+            context.stroke()
+
+        surface.write_to_png(f"output/{f:06d}.png")
+        f += 1
+
+ffmpeg.input("output/%06d.png", pattern_type="sequence", framerate=60).output("output.mp4").run(overwrite_output=True)
+for png in os.scandir("output"):
+    os.remove(png)
+os.rmdir("output")
+os.startfile("output.mp4")
\ No newline at end of file

commit 087559ba8293822b74141d2d35653df670ad8a74
Author: Elias Dobrin <elias@dobrin.net>
Date:   Tue Jun 14 21:57:09 2022 -0700

    added second demo hanging object script

diff --git a/sb_dropping.py b/sb_dropping.py
index c9ad9ed..e4977b2 100644
--- a/sb_dropping.py
+++ b/sb_dropping.py
@@ -97,7 +97,7 @@ for i in range(iterations):
         context.translate(-camera_position.x, -camera_position.y)
 
         context.rectangle(0, 0, 1, 1)
-        context.set_source_rgb(0.71, 0.94, 1)
+        context.set_source_rgb(0.5, 0.94, 1)
         context.fill_preserve()
         context.set_source_rgb(0, 0, 0)
         context.set_line_width(0.01)
diff --git a/sb_hanging_1.py b/sb_hanging_1.py
new file mode 100644
index 0000000..34520cd
--- /dev/null
+++ b/sb_hanging_1.py
@@ -0,0 +1,132 @@
+import os
+from math import tau, sqrt
+import cairo
+import ffmpeg
+from structures import Tower
+from vectors import Vector
+
+input_s = 0.5
+
+while True:
+    try:
+        data = input("ENTER LINK STIFFNESS (0-1): ")
+        input_s = float(data)
+        if 0 <= input_s <= 1:
+            break
+        else:
+            print("VALUE NOT BETWEEN THE SPECIFIED RANGE.")
+        continue
+    except ValueError:
+        print("VALUE IS INVALID.")
+        continue
+
+input_d = 0.5
+
+while True:
+    try:
+        data = input("ENTER LINK DAMPENING (0-1): ")
+        input_d = float(data)
+        if 0 <= input_d <= 1:
+            break
+        else:
+            print("VALUE NOT BETWEEN THE SPECIFIED RANGE.")
+        continue
+    except ValueError:
+        print("VALUE IS INVALID.")
+        continue
+
+os.makedirs("output", exist_ok=True)
+for png in os.scandir("output"):
+    os.remove(png)
+
+time = 5
+iterations = 10000
+f = 0
+camera_position = Vector(0.5, 0.5)
+camera_zoom = 0.9
+softbody = Tower(width=0.5, height=0.5, grid=(5, 5), mass=1, stiffness=400 * input_s ** 2, dampening=5 * input_d ** 2)
+softbody.translate(Vector(0.5, 0.5))
+nodes = softbody.nodes
+links = softbody.links
+
+print()
+for i in range(iterations):
+    print(f"SOLVING DIFFERENTIAL EQUATIONS: {round(100 * (i + 1) / iterations)}%", end="\r")
+    for node in nodes:
+        node.force.set(Vector(0, 0))
+    for node in nodes:
+        node.force.add(Vector(0, -9.8 * node.mass))
+    for link in links:
+        node_1 = link.nodes[0]
+        node_2 = link.nodes[1]
+        node_1_force = link.get_force() * (
+                node_1.position - node_2.position
+        ) / Vector.dist(node_1.position, node_2.position)
+        node_1.force.add(node_1_force)
+        node_2.force.sub(node_1_force)
+    for node in nodes:
+        node_force_normal = Vector(0, 0)
+        if node.position.x < 0:
+            node_force_normal.add(Vector(-500 * node.position.x, 0))
+        if node.position.y < 0:
+            node_force_normal.add(Vector(0, -500 * node.position.y))
+        if node.position.x > 1:
+            node_force_normal.add(Vector(500 * (1 - node.position.x), 0))
+        if node.position.y > 1:
+            node_force_normal.add(Vector(0, 500 * (1 - node.position.y)))
+        node.force.add(node_force_normal)
+    softbody.nodes_tower[0][-1].force.set(Vector(0, 0))
+    for node in nodes:
+        node.acceleration = node.force / node.mass
+        node.velocity.add(node.acceleration * (time / iterations))
+        node.position.add(node.velocity * (time / iterations))
+    if i % round(iterations / time / 60) == 0:
+        surface = cairo.ImageSurface(cairo.FORMAT_RGB24, 500, 500)
+        context = cairo.Context(surface)
+        context.scale(500, 500)
+        context.rectangle(0, 0, 1, 1)
+        context.set_source_rgb(0.29, 0.17, 0)
+        context.fill_preserve()
+        gradient = cairo.RadialGradient(0.5, 0.5, 0, 0.5, 0.5, sqrt(2) / 2)
+        gradient.add_color_stop_rgba(0, 0, 0, 0, 0)
+        gradient.add_color_stop_rgba(1, 0, 0, 0, 0.2)
+        context.set_source(gradient)
+        context.fill()
+        context.translate(0.5, 0.5)
+        context.scale(1, -1)
+        context.scale(camera_zoom, camera_zoom)
+        context.translate(-camera_position.x, -camera_position.y)
+
+        context.rectangle(0, 0, 1, 1)
+        context.set_source_rgb(0.5, 0.94, 1)
+        context.fill_preserve()
+        context.set_source_rgb(0, 0, 0)
+        context.set_line_width(0.01)
+        context.stroke()
+
+        for link in links:
+            context.move_to(link.nodes[0].position.x, link.nodes[0].position.y)
+            context.line_to(link.nodes[1].position.x, link.nodes[1].position.y)
+            context.set_source_rgb(0.5 * abs(link.get_force()), 0, 0)
+            context.set_line_width(0.01 * (link.length / link.get_length()))
+            context.stroke()
+
+        for node in nodes:
+            context.arc(node.position.x, node.position.y, 0.01, 0, tau)
+            context.set_source_rgb(1, 1, 1)
+            context.fill_preserve()
+            if node is softbody.nodes_tower[0][-1]:
+                context.set_source_rgb(1, 0, 0)
+            else:
+                context.set_source_rgb(0, 0, 0)
+            context.set_line_width(0.005)
+            context.stroke()
+
+        surface.write_to_png(f"output/{f:06d}.png")
+        f += 1
+
+ffmpeg.input("output/%06d.png", pattern_type="sequence", framerate=60).output("output.mp4").run(overwrite_output=True)
+for png in os.scandir("output"):
+    os.remove(png)
+os.rmdir("output")
+os.startfile("output.mp4")
\ No newline at end of file

commit b38729475a7141588bf5f09ebc8cadb99dc1412c
Author: Elias Dobrin <elias@dobrin.net>
Date:   Tue Jun 14 21:41:45 2022 -0700

    changed background rendering

diff --git a/sb_dropping.py b/sb_dropping.py
index cbb6a2e..c9ad9ed 100644
--- a/sb_dropping.py
+++ b/sb_dropping.py
@@ -9,28 +9,30 @@ input_s = 0.5
 
 while True:
     try:
-        data = input("STIFFNESS (0-1) [0.5]: ")
-        if data == "":
-            break
-        input_s = float(data) ** 2
+        data = input("ENTER LINK STIFFNESS (0-1): ")
+        input_s = float(data)
         if 0 <= input_s <= 1:
             break
+        else:
+            print("VALUE NOT BETWEEN THE SPECIFIED RANGE.")
         continue
     except ValueError:
+        print("VALUE IS INVALID.")
         continue
 
 input_d = 0.5
 
 while True:
     try:
-        data = input("DAMPENING (0-1) [0.5]: ")
-        if data == "":
-            break
-        input_d = float(data) ** 2
+        data = input("ENTER LINK DAMPENING (0-1): ")
+        input_d = float(data)
         if 0 <= input_d <= 1:
             break
+        else:
+            print("VALUE NOT BETWEEN THE SPECIFIED RANGE.")
         continue
     except ValueError:
+        print("VALUE IS INVALID.")
         continue
 
 os.makedirs("output", exist_ok=True)
@@ -38,16 +40,18 @@ for png in os.scandir("output"):
     os.remove(png)
 
 time = 5
-iterations = 5000
+iterations = 10000
 f = 0
 camera_position = Vector(0.5, 0.5)
 camera_zoom = 0.9
-softbody = Tower(width=0.5, height=0.5, grid=(7, 7), mass=1, stiffness=200 * input_s, dampening=2 * input_d)
+softbody = Tower(width=0.5, height=0.5, grid=(5, 5), mass=1, stiffness=400 * input_s ** 2, dampening=5 * input_d ** 2)
 softbody.translate(Vector(0.5, 0.5))
 nodes = softbody.nodes
 links = softbody.links
 
+print()
 for i in range(iterations):
+    print(f"SOLVING DIFFERENTIAL EQUATIONS: {round(100 * (i + 1) / iterations)}%", end="\r")
     for node in nodes:
         node.force.set(Vector(0, 0))
     for node in nodes:
@@ -62,32 +66,15 @@ for i in range(iterations):
         node_2.force.sub(node_1_force)
     for node in nodes:
         node_force_normal = Vector(0, 0)
-        node_force_friction = Vector(0, 0)
         if node.position.x < 0:
             node_force_normal.add(Vector(-500 * node.position.x, 0))
-            try:
-                node_force_friction.add(Vector(0, -node.velocity.y / abs(node.velocity.y)))
-            except ZeroDivisionError:
-                node_force_friction.add(Vector(0, 0))
         if node.position.y < 0:
             node_force_normal.add(Vector(0, -500 * node.position.y))
-            try:
-                node_force_friction.add(Vector(0, -node.velocity.x / abs(node.velocity.x)))
-            except ZeroDivisionError:
-                node_force_friction.add(Vector(0, 0))
         if node.position.x > 1:
             node_force_normal.add(Vector(500 * (1 - node.position.x), 0))
-            try:
-                node_force_friction.add(Vector(0, -node.velocity.y / abs(node.velocity.y)))
-            except ZeroDivisionError:
-                node_force_friction.add(Vector(0, 0))
         if node.position.y > 1:
             node_force_normal.add(Vector(0, 500 * (1 - node.position.y)))
-            try:
-                node_force_friction.add(Vector(0, -node.velocity.x / abs(node.velocity.x)))
-            except ZeroDivisionError:
-                node_force_friction.add(Vector(0, 0))
-        node.force += node_force_normal + 0 * node_force_normal.len() * node_force_friction
+        node.force.add(node_force_normal)
     for node in nodes:
         node.acceleration = node.force / node.mass
         node.velocity.add(node.acceleration * (time / iterations))
@@ -97,9 +84,11 @@ for i in range(iterations):
         context = cairo.Context(surface)
         context.scale(500, 500)
         context.rectangle(0, 0, 1, 1)
+        context.set_source_rgb(0.29, 0.17, 0)
+        context.fill_preserve()
         gradient = cairo.RadialGradient(0.5, 0.5, 0, 0.5, 0.5, sqrt(2) / 2)
-        gradient.add_color_stop_rgb(0, 1, 1, 1)
-        gradient.add_color_stop_rgb(1, 0.8, 0.8, 0.8)
+        gradient.add_color_stop_rgba(0, 0, 0, 0, 0)
+        gradient.add_color_stop_rgba(1, 0, 0, 0, 0.2)
         context.set_source(gradient)
         context.fill()
         context.translate(0.5, 0.5)
@@ -108,6 +97,8 @@ for i in range(iterations):
         context.translate(-camera_position.x, -camera_position.y)
 
         context.rectangle(0, 0, 1, 1)
+        context.set_source_rgb(0.71, 0.94, 1)
+        context.fill_preserve()
         context.set_source_rgb(0, 0, 0)
         context.set_line_width(0.01)
         context.stroke()

commit 4cd6879b24ed163b069e4abbc5e20ae118337cff
Author: Elias Dobrin <elias@dobrin.net>
Date:   Tue Jun 14 15:03:18 2022 -0700

    no idea

diff --git a/.gitignore b/.gitignore
index 75969d4..723ad78 100644
--- a/.gitignore
+++ b/.gitignore
@@ -130,3 +130,6 @@ dmypy.json
 
 # Pyre type checker
 .pyre/
+
+# JetBrains
+.idea
diff --git a/.idea/.gitignore b/.idea/.gitignore
deleted file mode 100644
index 13566b8..0000000
--- a/.idea/.gitignore
+++ /dev/null
@@ -1,8 +0,0 @@
-# Default ignored files
-/shelf/
-/workspace.xml
-# Editor-based HTTP Client requests
-/httpRequests/
-# Datasource local storage ignored files
-/dataSources/
-/dataSources.local.xml
diff --git a/.idea/inspectionProfiles/Project_Default.xml b/.idea/inspectionProfiles/Project_Default.xml
deleted file mode 100644
index 5101a59..0000000
--- a/.idea/inspectionProfiles/Project_Default.xml
+++ /dev/null
@@ -1,31 +0,0 @@
-<component name="InspectionProjectProfileManager">
-  <profile version="1.0">
-    <option name="myName" value="Project Default" />
-    <inspection_tool class="HtmlUnknownTag" enabled="true" level="WARNING" enabled_by_default="true">
-      <option name="myValues">
-        <value>
-          <list size="7">
-            <item index="0" class="java.lang.String" itemvalue="nobr" />
-            <item index="1" class="java.lang.String" itemvalue="noembed" />
-            <item index="2" class="java.lang.String" itemvalue="comment" />
-            <item index="3" class="java.lang.String" itemvalue="noscript" />
-            <item index="4" class="java.lang.String" itemvalue="embed" />
-            <item index="5" class="java.lang.String" itemvalue="script" />
-            <item index="6" class="java.lang.String" itemvalue="style" />
-          </list>
-        </value>
-      </option>
-      <option name="myCustomValuesEnabled" value="true" />
-    </inspection_tool>
-    <inspection_tool class="PyPackageRequirementsInspection" enabled="true" level="WARNING" enabled_by_default="true">
-      <option name="ignoredPackages">
-        <value>
-          <list size="2">
-            <item index="0" class="java.lang.String" itemvalue="mazelib" />
-            <item index="1" class="java.lang.String" itemvalue="euclid" />
-          </list>
-        </value>
-      </option>
-    </inspection_tool>
-  </profile>
-</component>
\ No newline at end of file
diff --git a/.idea/inspectionProfiles/profiles_settings.xml b/.idea/inspectionProfiles/profiles_settings.xml
deleted file mode 100644
index 105ce2d..0000000
--- a/.idea/inspectionProfiles/profiles_settings.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<component name="InspectionProjectProfileManager">
-  <settings>
-    <option name="USE_PROJECT_PROFILE" value="false" />
-    <version value="1.0" />
-  </settings>
-</component>
\ No newline at end of file
diff --git a/.idea/misc.xml b/.idea/misc.xml
deleted file mode 100644
index dc9ea49..0000000
--- a/.idea/misc.xml
+++ /dev/null
@@ -1,4 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.10" project-jdk-type="Python SDK" />
-</project>
\ No newline at end of file
diff --git a/.idea/modules.xml b/.idea/modules.xml
deleted file mode 100644
index e88184b..0000000
--- a/.idea/modules.xml
+++ /dev/null
@@ -1,8 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="ProjectModuleManager">
-    <modules>
-      <module fileurl="file://$PROJECT_DIR$/.idea/softbodies.iml" filepath="$PROJECT_DIR$/.idea/softbodies.iml" />
-    </modules>
-  </component>
-</project>
\ No newline at end of file
diff --git a/.idea/softbodies.iml b/.idea/softbodies.iml
deleted file mode 100644
index 8b8c395..0000000
--- a/.idea/softbodies.iml
+++ /dev/null
@@ -1,12 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<module type="PYTHON_MODULE" version="4">
-  <component name="NewModuleRootManager">
-    <content url="file://$MODULE_DIR$" />
-    <orderEntry type="inheritedJdk" />
-    <orderEntry type="sourceFolder" forTests="false" />
-  </component>
-  <component name="PyDocumentationSettings">
-    <option name="format" value="PLAIN" />
-    <option name="myDocStringFormat" value="Plain" />
-  </component>
-</module>
\ No newline at end of file
diff --git a/.idea/vcs.xml b/.idea/vcs.xml
deleted file mode 100644
index 94a25f7..0000000
--- a/.idea/vcs.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="VcsDirectoryMappings">
-    <mapping directory="$PROJECT_DIR$" vcs="Git" />
-  </component>
-</project>
\ No newline at end of file

commit 5537b9f87f0b94cd06d8356856cb056d438f895e
Author: Elias Dobrin <elias@dobrin.net>
Date:   Tue Jun 14 15:02:32 2022 -0700

    update gitignore

diff --git a/.gitignore b/.gitignore
index 09a21f2..75969d4 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,4 +1,5 @@
 output.mp4
+output/*
 
 # Byte-compiled / optimized / DLL files
 __pycache__/
diff --git a/sb_dropping.py b/sb_dropping.py
index 87b62e3..cbb6a2e 100644
--- a/sb_dropping.py
+++ b/sb_dropping.py
@@ -43,7 +43,6 @@ f = 0
 camera_position = Vector(0.5, 0.5)
 camera_zoom = 0.9
 softbody = Tower(width=0.5, height=0.5, grid=(7, 7), mass=1, stiffness=200 * input_s, dampening=2 * input_d)
-softbody.rotate(3.1415 / 6)
 softbody.translate(Vector(0.5, 0.5))
 nodes = softbody.nodes
 links = softbody.links

commit fd1a32b50ef58dd09a1562e068e36acf4d043b79
Author: Elias Dobrin <elias@dobrin.net>
Date:   Tue Jun 14 15:00:22 2022 -0700

    added cool gradient and fixed bugs

diff --git a/.idea/.gitignore b/.idea/.gitignore
new file mode 100644
index 0000000..13566b8
--- /dev/null
+++ b/.idea/.gitignore
@@ -0,0 +1,8 @@
+# Default ignored files
+/shelf/
+/workspace.xml
+# Editor-based HTTP Client requests
+/httpRequests/
+# Datasource local storage ignored files
+/dataSources/
+/dataSources.local.xml
diff --git a/.idea/inspectionProfiles/Project_Default.xml b/.idea/inspectionProfiles/Project_Default.xml
new file mode 100644
index 0000000..5101a59
--- /dev/null
+++ b/.idea/inspectionProfiles/Project_Default.xml
@@ -0,0 +1,31 @@
+<component name="InspectionProjectProfileManager">
+  <profile version="1.0">
+    <option name="myName" value="Project Default" />
+    <inspection_tool class="HtmlUnknownTag" enabled="true" level="WARNING" enabled_by_default="true">
+      <option name="myValues">
+        <value>
+          <list size="7">
+            <item index="0" class="java.lang.String" itemvalue="nobr" />
+            <item index="1" class="java.lang.String" itemvalue="noembed" />
+            <item index="2" class="java.lang.String" itemvalue="comment" />
+            <item index="3" class="java.lang.String" itemvalue="noscript" />
+            <item index="4" class="java.lang.String" itemvalue="embed" />
+            <item index="5" class="java.lang.String" itemvalue="script" />
+            <item index="6" class="java.lang.String" itemvalue="style" />
+          </list>
+        </value>
+      </option>
+      <option name="myCustomValuesEnabled" value="true" />
+    </inspection_tool>
+    <inspection_tool class="PyPackageRequirementsInspection" enabled="true" level="WARNING" enabled_by_default="true">
+      <option name="ignoredPackages">
+        <value>
+          <list size="2">
+            <item index="0" class="java.lang.String" itemvalue="mazelib" />
+            <item index="1" class="java.lang.String" itemvalue="euclid" />
+          </list>
+        </value>
+      </option>
+    </inspection_tool>
+  </profile>
+</component>
\ No newline at end of file
diff --git a/.idea/inspectionProfiles/profiles_settings.xml b/.idea/inspectionProfiles/profiles_settings.xml
new file mode 100644
index 0000000..105ce2d
--- /dev/null
+++ b/.idea/inspectionProfiles/profiles_settings.xml
@@ -0,0 +1,6 @@
+<component name="InspectionProjectProfileManager">
+  <settings>
+    <option name="USE_PROJECT_PROFILE" value="false" />
+    <version value="1.0" />
+  </settings>
+</component>
\ No newline at end of file
diff --git a/.idea/misc.xml b/.idea/misc.xml
new file mode 100644
index 0000000..dc9ea49
--- /dev/null
+++ b/.idea/misc.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.10" project-jdk-type="Python SDK" />
+</project>
\ No newline at end of file
diff --git a/.idea/modules.xml b/.idea/modules.xml
new file mode 100644
index 0000000..e88184b
--- /dev/null
+++ b/.idea/modules.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectModuleManager">
+    <modules>
+      <module fileurl="file://$PROJECT_DIR$/.idea/softbodies.iml" filepath="$PROJECT_DIR$/.idea/softbodies.iml" />
+    </modules>
+  </component>
+</project>
\ No newline at end of file
diff --git a/.idea/softbodies.iml b/.idea/softbodies.iml
new file mode 100644
index 0000000..8b8c395
--- /dev/null
+++ b/.idea/softbodies.iml
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="PYTHON_MODULE" version="4">
+  <component name="NewModuleRootManager">
+    <content url="file://$MODULE_DIR$" />
+    <orderEntry type="inheritedJdk" />
+    <orderEntry type="sourceFolder" forTests="false" />
+  </component>
+  <component name="PyDocumentationSettings">
+    <option name="format" value="PLAIN" />
+    <option name="myDocStringFormat" value="Plain" />
+  </component>
+</module>
\ No newline at end of file
diff --git a/.idea/vcs.xml b/.idea/vcs.xml
new file mode 100644
index 0000000..94a25f7
--- /dev/null
+++ b/.idea/vcs.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="VcsDirectoryMappings">
+    <mapping directory="$PROJECT_DIR$" vcs="Git" />
+  </component>
+</project>
\ No newline at end of file
diff --git a/sb_dropping.py b/sb_dropping.py
index c0b3436..87b62e3 100644
--- a/sb_dropping.py
+++ b/sb_dropping.py
@@ -1,5 +1,5 @@
 import os
-from math import tau
+from math import tau, sqrt
 import cairo
 import ffmpeg
 from structures import Tower
@@ -43,7 +43,8 @@ f = 0
 camera_position = Vector(0.5, 0.5)
 camera_zoom = 0.9
 softbody = Tower(width=0.5, height=0.5, grid=(7, 7), mass=1, stiffness=200 * input_s, dampening=2 * input_d)
-softbody.translate(Vector(0.8, 0.5))
+softbody.rotate(3.1415 / 6)
+softbody.translate(Vector(0.5, 0.5))
 nodes = softbody.nodes
 links = softbody.links
 
@@ -97,7 +98,10 @@ for i in range(iterations):
         context = cairo.Context(surface)
         context.scale(500, 500)
         context.rectangle(0, 0, 1, 1)
-        context.set_source_rgb(1, 1, 1)
+        gradient = cairo.RadialGradient(0.5, 0.5, 0, 0.5, 0.5, sqrt(2) / 2)
+        gradient.add_color_stop_rgb(0, 1, 1, 1)
+        gradient.add_color_stop_rgb(1, 0.8, 0.8, 0.8)
+        context.set_source(gradient)
         context.fill()
         context.translate(0.5, 0.5)
         context.scale(1, -1)
@@ -124,13 +128,6 @@ for i in range(iterations):
             context.set_line_width(0.005)
             context.stroke()
 
-            context.move_to(node.position.x, node.position.y)
-            vector = 0.1 * node.velocity
-            context.line_to(node.position.x + vector.x, node.position.y + vector.y)
-            context.set_source_rgb(1, 0, 0)
-            context.set_line_width(0.0025)
-            context.stroke()
-
         surface.write_to_png(f"output/{f:06d}.png")
         f += 1
 

commit aa4296bc3af3128eb9a2c3493f0bf45ec16417fa
Author: Elias Dobrin <elias@dobrin.net>
Date:   Tue Jun 14 14:35:18 2022 -0700

    made velocity meter and fixed stuff

diff --git a/sb_dropping.py b/sb_dropping.py
index b7ad318..c0b3436 100644
--- a/sb_dropping.py
+++ b/sb_dropping.py
@@ -2,21 +2,48 @@ import os
 from math import tau
 import cairo
 import ffmpeg
-from softbodies import Softbody, Node, Link
 from structures import Tower
 from vectors import Vector
 
+input_s = 0.5
+
+while True:
+    try:
+        data = input("STIFFNESS (0-1) [0.5]: ")
+        if data == "":
+            break
+        input_s = float(data) ** 2
+        if 0 <= input_s <= 1:
+            break
+        continue
+    except ValueError:
+        continue
+
+input_d = 0.5
+
+while True:
+    try:
+        data = input("DAMPENING (0-1) [0.5]: ")
+        if data == "":
+            break
+        input_d = float(data) ** 2
+        if 0 <= input_d <= 1:
+            break
+        continue
+    except ValueError:
+        continue
+
 os.makedirs("output", exist_ok=True)
 for png in os.scandir("output"):
     os.remove(png)
 
 time = 5
-iterations = 3000
+iterations = 5000
 f = 0
 camera_position = Vector(0.5, 0.5)
 camera_zoom = 0.9
-softbody = Tower(width=0.5, height=0.5, grid=(7, 7), mass=1, stiffness=100, dampening=1)
-softbody.translate(Vector(0.5, 0.5))
+softbody = Tower(width=0.5, height=0.5, grid=(7, 7), mass=1, stiffness=200 * input_s, dampening=2 * input_d)
+softbody.translate(Vector(0.8, 0.5))
 nodes = softbody.nodes
 links = softbody.links
 
@@ -97,6 +124,13 @@ for i in range(iterations):
             context.set_line_width(0.005)
             context.stroke()
 
+            context.move_to(node.position.x, node.position.y)
+            vector = 0.1 * node.velocity
+            context.line_to(node.position.x + vector.x, node.position.y + vector.y)
+            context.set_source_rgb(1, 0, 0)
+            context.set_line_width(0.0025)
+            context.stroke()
+
         surface.write_to_png(f"output/{f:06d}.png")
         f += 1
 

commit 2805d54ed6f68f460c931265319b9f30a4c24492
Author: Elias Dobrin <elias@dobrin.net>
Date:   Tue Jun 14 11:43:31 2022 -0700

    Update README.md

diff --git a/README.md b/README.md
index 7781515..cd19984 100644
--- a/README.md
+++ b/README.md
@@ -1,2 +1,11 @@
 # softbodies
 Python package for simulating physics of softbodies following Hooke's principles.
+
+## Contributing
+Please use vscode or pycharm to not mess up indentations
+
+```pip install -r requirements.txt```
+
+Installs pycairo and ffmpeg
+
+Still need to put ffmpeg to path

commit 6d25cfabbf21c88fd7eafb6f6f0ca11f17b34d03
Author: Elias Dobrin <elias@dobrin.net>
Date:   Tue Jun 14 11:39:48 2022 -0700

    Create .gitignore
    
    Update .gitignore

diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..09a21f2
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,131 @@
+output.mp4
+
+# Byte-compiled / optimized / DLL files
+__pycache__/
+*.py[cod]
+*$py.class
+
+# C extensions
+*.so
+
+# Distribution / packaging
+.Python
+build/
+develop-eggs/
+dist/
+downloads/
+eggs/
+.eggs/
+lib/
+lib64/
+parts/
+sdist/
+var/
+wheels/
+pip-wheel-metadata/
+share/python-wheels/
+*.egg-info/
+.installed.cfg
+*.egg
+MANIFEST
+
+# PyInstaller
+#  Usually these files are written by a python script from a template
+#  before PyInstaller builds the exe, so as to inject date/other infos into it.
+*.manifest
+*.spec
+
+# Installer logs
+pip-log.txt
+pip-delete-this-directory.txt
+
+# Unit test / coverage reports
+htmlcov/
+.tox/
+.nox/
+.coverage
+.coverage.*
+.cache
+nosetests.xml
+coverage.xml
+*.cover
+*.py,cover
+.hypothesis/
+.pytest_cache/
+
+# Translations
+*.mo
+*.pot
+
+# Django stuff:
+*.log
+local_settings.py
+db.sqlite3
+db.sqlite3-journal
+
+# Flask stuff:
+instance/
+.webassets-cache
+
+# Scrapy stuff:
+.scrapy
+
+# Sphinx documentation
+docs/_build/
+
+# PyBuilder
+target/
+
+# Jupyter Notebook
+.ipynb_checkpoints
+
+# IPython
+profile_default/
+ipython_config.py
+
+# pyenv
+.python-version
+
+# pipenv
+#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
+#   However, in case of collaboration, if having platform-specific dependencies or dependencies
+#   having no cross-platform support, pipenv may install dependencies that don't work, or not
+#   install all needed dependencies.
+#Pipfile.lock
+
+# PEP 582; used by e.g. github.com/David-OConnor/pyflow
+__pypackages__/
+
+# Celery stuff
+celerybeat-schedule
+celerybeat.pid
+
+# SageMath parsed files
+*.sage.py
+
+# Environments
+.env
+.venv
+env/
+venv/
+ENV/
+env.bak/
+venv.bak/
+
+# Spyder project settings
+.spyderproject
+.spyproject
+
+# Rope project settings
+.ropeproject
+
+# mkdocs documentation
+/site
+
+# mypy
+.mypy_cache/
+.dmypy.json
+dmypy.json
+
+# Pyre type checker
+.pyre/

commit a748ab043576637e576fdc80bd66d4b7a994ece4
Author: Elias Dobrin <elias@dobrin.net>
Date:   Tue Jun 14 11:38:19 2022 -0700

    cleanup

diff --git a/__pycache__/softbodies.cpython-310.pyc b/__pycache__/softbodies.cpython-310.pyc
deleted file mode 100644
index d1e9211..0000000
Binary files a/__pycache__/softbodies.cpython-310.pyc and /dev/null differ
diff --git a/__pycache__/structures.cpython-310.pyc b/__pycache__/structures.cpython-310.pyc
deleted file mode 100644
index 9bc4fd9..0000000
Binary files a/__pycache__/structures.cpython-310.pyc and /dev/null differ
diff --git a/__pycache__/vectors.cpython-310.pyc b/__pycache__/vectors.cpython-310.pyc
deleted file mode 100644
index 8157755..0000000
Binary files a/__pycache__/vectors.cpython-310.pyc and /dev/null differ
diff --git a/output.mp4 b/output.mp4
deleted file mode 100644
index f8381fb..0000000
Binary files a/output.mp4 and /dev/null differ

commit 857c7c25352abccb98b53911b0970c27b23e810d
Author: Elias Dobrin <elias@dobrin.net>
Date:   Tue Jun 14 11:38:00 2022 -0700

    drop script working

diff --git a/__pycache__/softbodies.cpython-310.pyc b/__pycache__/softbodies.cpython-310.pyc
new file mode 100644
index 0000000..d1e9211
Binary files /dev/null and b/__pycache__/softbodies.cpython-310.pyc differ
diff --git a/__pycache__/structures.cpython-310.pyc b/__pycache__/structures.cpython-310.pyc
new file mode 100644
index 0000000..9bc4fd9
Binary files /dev/null and b/__pycache__/structures.cpython-310.pyc differ
diff --git a/__pycache__/vectors.cpython-310.pyc b/__pycache__/vectors.cpython-310.pyc
new file mode 100644
index 0000000..8157755
Binary files /dev/null and b/__pycache__/vectors.cpython-310.pyc differ
diff --git a/sb_dropping.py b/sb_dropping.py
index 1ed1f06..b7ad318 100644
--- a/sb_dropping.py
+++ b/sb_dropping.py
@@ -14,8 +14,8 @@ time = 5
 iterations = 3000
 f = 0
 camera_position = Vector(0.5, 0.5)
-camera_zoom = 0.2
-softbody = Tower(width=0.5, height=0.5, grid=(2, 2), mass=1, stiffness=10, dampening=0)
+camera_zoom = 0.9
+softbody = Tower(width=0.5, height=0.5, grid=(7, 7), mass=1, stiffness=100, dampening=1)
 softbody.translate(Vector(0.5, 0.5))
 nodes = softbody.nodes
 links = softbody.links
@@ -37,30 +37,30 @@ for i in range(iterations):
         node_force_normal = Vector(0, 0)
         node_force_friction = Vector(0, 0)
         if node.position.x < 0:
-            node_force_normal.add(Vector(-node.position.x, 0))
+            node_force_normal.add(Vector(-500 * node.position.x, 0))
             try:
                 node_force_friction.add(Vector(0, -node.velocity.y / abs(node.velocity.y)))
             except ZeroDivisionError:
                 node_force_friction.add(Vector(0, 0))
         if node.position.y < 0:
-            node_force_normal.add(Vector(0, -node.position.y))
+            node_force_normal.add(Vector(0, -500 * node.position.y))
             try:
                 node_force_friction.add(Vector(0, -node.velocity.x / abs(node.velocity.x)))
             except ZeroDivisionError:
                 node_force_friction.add(Vector(0, 0))
         if node.position.x > 1:
-            node_force_normal.add(Vector(1 - node.position.x, 0))
+            node_force_normal.add(Vector(500 * (1 - node.position.x), 0))
             try:
                 node_force_friction.add(Vector(0, -node.velocity.y / abs(node.velocity.y)))
             except ZeroDivisionError:
                 node_force_friction.add(Vector(0, 0))
         if node.position.y > 1:
-            node_force_normal.add(Vector(0, 1 - node.position.y))
+            node_force_normal.add(Vector(0, 500 * (1 - node.position.y)))
             try:
                 node_force_friction.add(Vector(0, -node.velocity.x / abs(node.velocity.x)))
             except ZeroDivisionError:
                 node_force_friction.add(Vector(0, 0))
-        node.force += 10 * node_force_normal
+        node.force += node_force_normal + 0 * node_force_normal.len() * node_force_friction
     for node in nodes:
         node.acceleration = node.force / node.mass
         node.velocity.add(node.acceleration * (time / iterations))
@@ -85,7 +85,7 @@ for i in range(iterations):
         for link in links:
             context.move_to(link.nodes[0].position.x, link.nodes[0].position.y)
             context.line_to(link.nodes[1].position.x, link.nodes[1].position.y)
-            context.set_source_rgb(1, 0.3 - abs(link.get_force() / 3), 0.3 - abs(link.get_force() / 3))
+            context.set_source_rgb(0, 0, 0)
             context.set_line_width(0.01 * (link.length / link.get_length()))
             context.stroke()
 

commit 87620e380238510d93bfc636bd0429dee100d5e4
Author: Elias Dobrin <elias@dobrin.net>
Date:   Tue Jun 14 11:24:04 2022 -0700

    doing the flop

diff --git a/output.mp4 b/output.mp4
new file mode 100644
index 0000000..f8381fb
Binary files /dev/null and b/output.mp4 differ
diff --git a/sb_dropping.py b/sb_dropping.py
index 3acdf82..1ed1f06 100644
--- a/sb_dropping.py
+++ b/sb_dropping.py
@@ -11,15 +11,15 @@ for png in os.scandir("output"):
     os.remove(png)
 
 time = 5
-iterations = 1000
+iterations = 3000
+f = 0
 camera_position = Vector(0.5, 0.5)
-camera_zoom = 0.9
-softbody = Tower(width=0.5, height=0.5, grid=(5, 5), mass=1, stiffness=100, dampening=0)
+camera_zoom = 0.2
+softbody = Tower(width=0.5, height=0.5, grid=(2, 2), mass=1, stiffness=10, dampening=0)
 softbody.translate(Vector(0.5, 0.5))
 nodes = softbody.nodes
 links = softbody.links
 
-
 for i in range(iterations):
     for node in nodes:
         node.force.set(Vector(0, 0))
@@ -43,7 +43,7 @@ for i in range(iterations):
             except ZeroDivisionError:
                 node_force_friction.add(Vector(0, 0))
         if node.position.y < 0:
-            node_force_normal.add(Vector(-node.position.y, 0))
+            node_force_normal.add(Vector(0, -node.position.y))
             try:
                 node_force_friction.add(Vector(0, -node.velocity.x / abs(node.velocity.x)))
             except ZeroDivisionError:
@@ -55,17 +55,17 @@ for i in range(iterations):
             except ZeroDivisionError:
                 node_force_friction.add(Vector(0, 0))
         if node.position.y > 1:
-            node_force_normal.add(Vector(1 - node.position.y, 0))
+            node_force_normal.add(Vector(0, 1 - node.position.y))
             try:
                 node_force_friction.add(Vector(0, -node.velocity.x / abs(node.velocity.x)))
             except ZeroDivisionError:
                 node_force_friction.add(Vector(0, 0))
-        node.force += node_force_normal + node_force_friction
+        node.force += 10 * node_force_normal
     for node in nodes:
         node.acceleration = node.force / node.mass
         node.velocity.add(node.acceleration * (time / iterations))
         node.position.add(node.velocity * (time / iterations))
-    if iterations % (iterations / time / 60) == 0:
+    if i % round(iterations / time / 60) == 0:
         surface = cairo.ImageSurface(cairo.FORMAT_RGB24, 500, 500)
         context = cairo.Context(surface)
         context.scale(500, 500)
@@ -97,7 +97,8 @@ for i in range(iterations):
             context.set_line_width(0.005)
             context.stroke()
 
-        surface.write_to_png(f"output/{i:06d}.png")
+        surface.write_to_png(f"output/{f:06d}.png")
+        f += 1
 
 ffmpeg.input("output/%06d.png", pattern_type="sequence", framerate=60).output("output.mp4").run(overwrite_output=True)
 for png in os.scandir("output"):

commit 70d1a46809cec0ee9b6742515eb1536d3a845f5d
Author: Elias Dobrin <elias@dobrin.net>
Date:   Tue Jun 14 11:08:28 2022 -0700

    rendering pipeline finished but not working

diff --git a/sb_dropping.py b/sb_dropping.py
index 3a7129e..3acdf82 100644
--- a/sb_dropping.py
+++ b/sb_dropping.py
@@ -1,16 +1,25 @@
+import os
+from math import tau
+import cairo
+import ffmpeg
 from softbodies import Softbody, Node, Link
 from structures import Tower
 from vectors import Vector
 
+os.makedirs("output", exist_ok=True)
+for png in os.scandir("output"):
+    os.remove(png)
+
 time = 5
 iterations = 1000
-
+camera_position = Vector(0.5, 0.5)
+camera_zoom = 0.9
 softbody = Tower(width=0.5, height=0.5, grid=(5, 5), mass=1, stiffness=100, dampening=0)
 softbody.translate(Vector(0.5, 0.5))
-
 nodes = softbody.nodes
 links = softbody.links
 
+
 for i in range(iterations):
     for node in nodes:
         node.force.set(Vector(0, 0))
@@ -57,3 +66,41 @@ for i in range(iterations):
         node.velocity.add(node.acceleration * (time / iterations))
         node.position.add(node.velocity * (time / iterations))
     if iterations % (iterations / time / 60) == 0:
+        surface = cairo.ImageSurface(cairo.FORMAT_RGB24, 500, 500)
+        context = cairo.Context(surface)
+        context.scale(500, 500)
+        context.rectangle(0, 0, 1, 1)
+        context.set_source_rgb(1, 1, 1)
+        context.fill()
+        context.translate(0.5, 0.5)
+        context.scale(1, -1)
+        context.scale(camera_zoom, camera_zoom)
+        context.translate(-camera_position.x, -camera_position.y)
+
+        context.rectangle(0, 0, 1, 1)
+        context.set_source_rgb(0, 0, 0)
+        context.set_line_width(0.01)
+        context.stroke()
+
+        for link in links:
+            context.move_to(link.nodes[0].position.x, link.nodes[0].position.y)
+            context.line_to(link.nodes[1].position.x, link.nodes[1].position.y)
+            context.set_source_rgb(1, 0.3 - abs(link.get_force() / 3), 0.3 - abs(link.get_force() / 3))
+            context.set_line_width(0.01 * (link.length / link.get_length()))
+            context.stroke()
+
+        for node in nodes:
+            context.arc(node.position.x, node.position.y, 0.01, 0, tau)
+            context.set_source_rgb(1, 1, 1)
+            context.fill_preserve()
+            context.set_source_rgb(0, 0, 0)
+            context.set_line_width(0.005)
+            context.stroke()
+
+        surface.write_to_png(f"output/{i:06d}.png")
+
+ffmpeg.input("output/%06d.png", pattern_type="sequence", framerate=60).output("output.mp4").run(overwrite_output=True)
+for png in os.scandir("output"):
+    os.remove(png)
+os.rmdir("output")
+os.startfile("output.mp4")
\ No newline at end of file

commit ed79d1b207b3d7c03a46989fe16d304d370ddd58
Author: Elias Dobrin <elias@dobrin.net>
Date:   Tue Jun 14 10:59:42 2022 -0700

    finished physics logic/loop

diff --git a/sb_dropping.py b/sb_dropping.py
index b3038bf..3a7129e 100644
--- a/sb_dropping.py
+++ b/sb_dropping.py
@@ -2,13 +2,16 @@ from softbodies import Softbody, Node, Link
 from structures import Tower
 from vectors import Vector
 
+time = 5
+iterations = 1000
+
 softbody = Tower(width=0.5, height=0.5, grid=(5, 5), mass=1, stiffness=100, dampening=0)
 softbody.translate(Vector(0.5, 0.5))
 
 nodes = softbody.nodes
 links = softbody.links
 
-for i in range(1000):
+for i in range(iterations):
     for node in nodes:
         node.force.set(Vector(0, 0))
     for node in nodes:
@@ -48,3 +51,9 @@ for i in range(1000):
                 node_force_friction.add(Vector(0, -node.velocity.x / abs(node.velocity.x)))
             except ZeroDivisionError:
                 node_force_friction.add(Vector(0, 0))
+        node.force += node_force_normal + node_force_friction
+    for node in nodes:
+        node.acceleration = node.force / node.mass
+        node.velocity.add(node.acceleration * (time / iterations))
+        node.position.add(node.velocity * (time / iterations))
+    if iterations % (iterations / time / 60) == 0:

commit 0a9b3cf0f6cb4b6a0f4ee2d9c1b4635cf44239c9
Author: Elias Dobrin <elias@dobrin.net>
Date:   Tue Jun 14 10:50:28 2022 -0700

    added structures dependency

diff --git a/sb_dropping.py b/sb_dropping.py
index ca97289..b3038bf 100644
--- a/sb_dropping.py
+++ b/sb_dropping.py
@@ -47,4 +47,4 @@ for i in range(1000):
             try:
                 node_force_friction.add(Vector(0, -node.velocity.x / abs(node.velocity.x)))
             except ZeroDivisionError:
-                node_force_friction.add(Vector(0, 0))
\ No newline at end of file
+                node_force_friction.add(Vector(0, 0))
diff --git a/structures.py b/structures.py
new file mode 100644
index 0000000..9b95abf
--- /dev/null
+++ b/structures.py
@@ -0,0 +1,135 @@
+from __future__ import annotations
+from math import sqrt, cos, sin, atan2, tau
+from softbodies import Softbody, Node, Link
+from vectors import Vector
+
+
+class Structure(Softbody):
+    nodes: list[Node]
+    links: list[Link]
+
+    def __init__(self, nodes: list[Node], links: list[Link]) -> None:
+        super().__init__(nodes, links)
+
+    def get_components(self) -> tuple[list[Node], list[Link]]:
+        return self.nodes, self.links
+
+    def get_total_mass(self) -> float:
+        total_mass = sum(node.mass for node in self.nodes)
+        return total_mass
+
+    def get_center_mass(self) -> Vector:
+        center_mass = sum(node.mass * node.position for node in self.nodes)
+        return center_mass
+
+    def translate(self, vector: Vector) -> None:
+        for node in self.nodes:
+            node.position += vector
+
+    def scale(self, factor: float, center: Vector = None) -> None:
+        if center is None:
+            center = Vector(0, 0)
+        self.translate(-center)
+        for node in self.nodes:
+            node.position *= factor
+        for link in self.links:
+            link.length *= factor
+        self.translate(center)
+
+    def rotate(self, radians: float, center: Vector = None) -> None:
+        if center is None:
+            center = Vector(0, 0)
+        self.translate(-center)
+        for node in self.nodes:
+            node_angle = atan2(node.position.y, node.position.x)
+            node_radius = node.position.len()
+            node.position.x = node_radius * cos(node_angle + radians)
+            node.position.y = node_radius * sin(node_angle + radians)
+        self.translate(center)
+
+
+class Tower(Structure):
+    nodes_tower: list[list[Node]]
+
+    def __init__(self, width: float, height: float, grid: tuple[int, int], mass: float, stiffness: float, dampening: float) -> None:
+        nodes_tower = []
+        for x in range(grid[0] + 1):
+            nodes_tower.append([])
+            for y in range(grid[1] + 1):
+                node_mass = mass / ((grid[0] + 1) * (grid[1] + 1))
+                node_position = Vector(width * (x / grid[0] - 0.5),
+                                       height * (y / grid[1] - 0.5))
+                node = Node(node_mass, node_position)
+                nodes_tower[x].append(node)
+        links = []
+        for x in range(grid[0]):
+            for y in range(grid[1] + 1):
+                links.append(Link((nodes_tower[x][y], nodes_tower[x + 1][y]), stiffness, dampening))
+        for x in range(grid[0] + 1):
+            for y in range(grid[1]):
+                links.append(Link((nodes_tower[x][y], nodes_tower[x][y + 1]), stiffness, dampening))
+        for x in range(grid[0]):
+            for y in range(grid[1]):
+                links.append(Link((nodes_tower[x][y], nodes_tower[x + 1][y + 1]), stiffness, dampening))
+                links.append(Link((nodes_tower[x + 1][y], nodes_tower[x][y + 1]), stiffness, dampening))
+        nodes = [node for buffer in nodes_tower for node in buffer]
+        super().__init__(nodes, links)
+        self.nodes_tower = nodes_tower
+
+
+class Pyramid(Structure):
+    nodes_pyramid: list[list[Node]]
+
+    def __init__(self, width: float, grid: int, mass: float, stiffness: float, dampening: float) -> None:
+        height = (sqrt(3) / 2) * width
+        nodes_pyramid = []
+        for y in range(grid + 1):
+            nodes_pyramid.append([])
+            for x in range(grid + 1 - y):
+                node_mass = mass / ((grid + 1) * (grid + 2) / 2)
+                node_position = Vector(width * ((x + 0.5 * y) / grid - 0.5),
+                                       height * (y / grid - 0.5))
+                node = Node(node_mass, node_position)
+                nodes_pyramid[y].append(node)
+        links = []
+        for y in range(grid):
+            for x in range(grid - y):
+                links.append(Link((nodes_pyramid[y][x], nodes_pyramid[y + 1][x]), stiffness, dampening))
+                links.append(Link((nodes_pyramid[y][x], nodes_pyramid[y][x + 1]), stiffness, dampening))
+                links.append(Link((nodes_pyramid[y][-x - 1], nodes_pyramid[y + 1][-x - 1]), stiffness, dampening))
+        nodes = [node for buffer in nodes_pyramid for node in buffer]
+        super().__init__(nodes, links)
+        self.nodes_pyramid = nodes_pyramid
+
+
+class Wheel(Structure):
+    def __init__(self, radius: float, rings: int, slices: int, mass: float, stiffness: float, dampening: float) -> None:
+        node_mass = mass / (rings * slices + 1)
+        nodes_mesh = [[Node(node_mass, Vector(0, 0))]]
+        for r in range(1, rings + 1):
+            nodes_mesh.append([])
+            for s in range(slices):
+                ang = (s / slices) * tau
+                rad = (r / rings) * radius
+                node_position = Vector(rad * cos(ang),
+                                       rad * sin(ang))
+                node = Node(node_mass, node_position)
+                nodes_mesh[r].append(node)
+        links = []
+        for r in range(1, rings + 1):
+            for s in range(slices):
+                links.append(Link((nodes_mesh[r][s], nodes_mesh[r][(s + 1) % slices]), stiffness, dampening))
+        for s in range(slices):
+            links.append(Link((nodes_mesh[0][0], nodes_mesh[1][s]), stiffness, dampening))
+        for r in range(1, rings):
+            for s in range(slices):
+                links.append(Link((nodes_mesh[r][s], nodes_mesh[r + 1][s]), stiffness, dampening))
+
+        nodes = [node for buffer in nodes_mesh for node in buffer]
+        super().__init__(nodes, links)
+
+
+if __name__ == "__main__":
+    from time import sleep
+    print("Do not run me! This is just a dependency program")
+    sleep(5)
\ No newline at end of file

commit cc286e50b37963088f0e92e7b4a914cfae8bb668
Author: Elias Dobrin <elias@dobrin.net>
Date:   Tue Jun 14 10:49:33 2022 -0700

    working on sb_dropping file

diff --git a/sb_dropping.py b/sb_dropping.py
new file mode 100644
index 0000000..ca97289
--- /dev/null
+++ b/sb_dropping.py
@@ -0,0 +1,50 @@
+from softbodies import Softbody, Node, Link
+from structures import Tower
+from vectors import Vector
+
+softbody = Tower(width=0.5, height=0.5, grid=(5, 5), mass=1, stiffness=100, dampening=0)
+softbody.translate(Vector(0.5, 0.5))
+
+nodes = softbody.nodes
+links = softbody.links
+
+for i in range(1000):
+    for node in nodes:
+        node.force.set(Vector(0, 0))
+    for node in nodes:
+        node.force.add(Vector(0, -9.8 * node.mass))
+    for link in links:
+        node_1 = link.nodes[0]
+        node_2 = link.nodes[1]
+        node_1_force = link.get_force() * (
+                node_1.position - node_2.position
+        ) / Vector.dist(node_1.position, node_2.position)
+        node_1.force.add(node_1_force)
+        node_2.force.sub(node_1_force)
+    for node in nodes:
+        node_force_normal = Vector(0, 0)
+        node_force_friction = Vector(0, 0)
+        if node.position.x < 0:
+            node_force_normal.add(Vector(-node.position.x, 0))
+            try:
+                node_force_friction.add(Vector(0, -node.velocity.y / abs(node.velocity.y)))
+            except ZeroDivisionError:
+                node_force_friction.add(Vector(0, 0))
+        if node.position.y < 0:
+            node_force_normal.add(Vector(-node.position.y, 0))
+            try:
+                node_force_friction.add(Vector(0, -node.velocity.x / abs(node.velocity.x)))
+            except ZeroDivisionError:
+                node_force_friction.add(Vector(0, 0))
+        if node.position.x > 1:
+            node_force_normal.add(Vector(1 - node.position.x, 0))
+            try:
+                node_force_friction.add(Vector(0, -node.velocity.y / abs(node.velocity.y)))
+            except ZeroDivisionError:
+                node_force_friction.add(Vector(0, 0))
+        if node.position.y > 1:
+            node_force_normal.add(Vector(1 - node.position.y, 0))
+            try:
+                node_force_friction.add(Vector(0, -node.velocity.x / abs(node.velocity.x)))
+            except ZeroDivisionError:
+                node_force_friction.add(Vector(0, 0))
\ No newline at end of file

commit 82406226d03f93c65f3555940c4a74425240d85f
Author: Elias Dobrin <elias@dobrin.net>
Date:   Mon Jun 13 13:02:43 2022 -0700

    Create LICENSE.txt

diff --git a/LICENSE.txt b/LICENSE.txt
new file mode 100644
index 0000000..9fe37c5
--- /dev/null
+++ b/LICENSE.txt
@@ -0,0 +1,21 @@
+MIT License
+
+Copyright (c) 2022 Elias Dobrin
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.

commit 22498db67603817cccdfcc2e367a298c76c921f2
Author: Elias <elias@dobrin.net>
Date:   Mon Jun 13 13:01:39 2022 -0700

    removed packaging

diff --git a/LICENSE b/LICENSE
deleted file mode 100644
index 9fe37c5..0000000
--- a/LICENSE
+++ /dev/null
@@ -1,21 +0,0 @@
-MIT License
-
-Copyright (c) 2022 Elias Dobrin
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
diff --git a/setup.py b/setup.py
deleted file mode 100644
index 34aab13..0000000
--- a/setup.py
+++ /dev/null
@@ -1,10 +0,0 @@
-from setuptools import setup
-
-setup(
-    name="softbodies",
-    version="1.0.0",
-    description="Module for simulating physics of softbodies following Hooke's principles.",
-    author="Elias Dobrin",
-    url="https://github.com/Elixonus/softbodies",
-    keywords=["softbody", "spring", "springs"]
-)
diff --git a/softbodies/softbodies.py b/softbodies.py
similarity index 100%
rename from softbodies/softbodies.py
rename to softbodies.py
diff --git a/softbodies/__init__.py b/softbodies/__init__.py
deleted file mode 100644
index 9652743..0000000
--- a/softbodies/__init__.py
+++ /dev/null
@@ -1,4 +0,0 @@
-"""Package for simulating physics of softbodies following Hooke's principles."""
-
-from softbodies.softbodies import Softbody, Node, Link
-from softbodies.vectors import Vector
diff --git a/softbodies/vectors.py b/vectors.py
similarity index 100%
rename from softbodies/vectors.py
rename to vectors.py

commit ea384996cab6ca1b5e0b73ac0ec00748edc6a635
Author: Elias Dobrin <elias@dobrin.net>
Date:   Mon Jun 13 11:11:45 2022 -0700

    Delete python-publish.yml

diff --git a/.github/workflows/python-publish.yml b/.github/workflows/python-publish.yml
deleted file mode 100644
index f34f878..0000000
--- a/.github/workflows/python-publish.yml
+++ /dev/null
@@ -1,39 +0,0 @@
-# This workflow will upload a Python Package using Twine when a release is created
-# For more information see: https://help.github.com/en/actions/language-and-framework-guides/using-python-with-github-actions#publishing-to-package-registries
-
-# This workflow uses actions that are not certified by GitHub.
-# They are provided by a third-party and are governed by
-# separate terms of service, privacy policy, and support
-# documentation.
-
-name: Upload Python Package
-
-on:
-  release:
-    types: [published]
-
-permissions:
-  contents: read
-
-jobs:
-  deploy:
-
-    runs-on: ubuntu-latest
-
-    steps:
-    - uses: actions/checkout@v3
-    - name: Set up Python
-      uses: actions/setup-python@v3
-      with:
-        python-version: '3.x'
-    - name: Install dependencies
-      run: |
-        python -m pip install --upgrade pip
-        pip install build
-    - name: Build package
-      run: python -m build
-    - name: Publish package
-      uses: pypa/gh-action-pypi-publish@27b31702a0e7fc50959f5ad993c78deac1bdfc29
-      with:
-        user: Elixonus
-        password: ${{ pypi-AgEIcHlwaS5vcmcCJDE4MmExNTU4LTQ4NmMtNGVkOC1iYjdkLTA0Y2M2Yzg4NTQ3NQACJXsicGVybWlzc2lvbnMiOiAidXNlciIsICJ2ZXJzaW9uIjogMX0AAAYgO-GK8h0uGNVsTxe9jMnPg_KBG5Yo5sepvGwaMkx63V0 }}

commit d2128a7e2ec25bc800ded2c0c3fe0f0051a8ff20
Author: Elias Dobrin <elias@dobrin.net>
Date:   Mon Jun 13 11:09:42 2022 -0700

    Create python-publish.yml

diff --git a/.github/workflows/python-publish.yml b/.github/workflows/python-publish.yml
new file mode 100644
index 0000000..f34f878
--- /dev/null
+++ b/.github/workflows/python-publish.yml
@@ -0,0 +1,39 @@
+# This workflow will upload a Python Package using Twine when a release is created
+# For more information see: https://help.github.com/en/actions/language-and-framework-guides/using-python-with-github-actions#publishing-to-package-registries
+
+# This workflow uses actions that are not certified by GitHub.
+# They are provided by a third-party and are governed by
+# separate terms of service, privacy policy, and support
+# documentation.
+
+name: Upload Python Package
+
+on:
+  release:
+    types: [published]
+
+permissions:
+  contents: read
+
+jobs:
+  deploy:
+
+    runs-on: ubuntu-latest
+
+    steps:
+    - uses: actions/checkout@v3
+    - name: Set up Python
+      uses: actions/setup-python@v3
+      with:
+        python-version: '3.x'
+    - name: Install dependencies
+      run: |
+        python -m pip install --upgrade pip
+        pip install build
+    - name: Build package
+      run: python -m build
+    - name: Publish package
+      uses: pypa/gh-action-pypi-publish@27b31702a0e7fc50959f5ad993c78deac1bdfc29
+      with:
+        user: Elixonus
+        password: ${{ pypi-AgEIcHlwaS5vcmcCJDE4MmExNTU4LTQ4NmMtNGVkOC1iYjdkLTA0Y2M2Yzg4NTQ3NQACJXsicGVybWlzc2lvbnMiOiAidXNlciIsICJ2ZXJzaW9uIjogMX0AAAYgO-GK8h0uGNVsTxe9jMnPg_KBG5Yo5sepvGwaMkx63V0 }}

commit 5e3c23d1f761081a6b4970bc23244bdacbb5a26a
Author: Elias Dobrin <elias@dobrin.net>
Date:   Mon Jun 13 11:01:41 2022 -0700

    Revert "Revert "Merge branch 'main' of https://github.com/Elixonus/softbodies""
    
    This reverts commit ee06a84405adbbcc8d87771638c4a8303ce06c2c.

diff --git a/.idea/workspace.xml b/.idea/workspace.xml
deleted file mode 100644
index d53a10e..0000000
--- a/.idea/workspace.xml
+++ /dev/null
@@ -1,127 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="AutoImportSettings">
-    <option name="autoReloadType" value="SELECTIVE" />
-  </component>
-  <component name="ChangeListManager">
-    <list default="true" id="44865169-17f5-40d2-b94e-08a42550aacd" name="Changes" comment="nothing">
-      <change beforePath="$PROJECT_DIR$/setup.py" beforeDir="false" afterPath="$PROJECT_DIR$/setup.py" afterDir="false" />
-    </list>
-    <option name="SHOW_DIALOG" value="false" />
-    <option name="HIGHLIGHT_CONFLICTS" value="true" />
-    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
-    <option name="LAST_RESOLUTION" value="IGNORE" />
-  </component>
-  <component name="FileTemplateManagerImpl">
-    <option name="RECENT_TEMPLATES">
-      <list>
-        <option value="Python Script" />
-      </list>
-    </option>
-  </component>
-  <component name="Git.Settings">
-    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
-  </component>
-  <component name="MarkdownSettingsMigration">
-    <option name="stateVersion" value="1" />
-  </component>
-  <component name="ProjectId" id="2AVa4AiD0XYoyfo6WTleRN4qDsP" />
-  <component name="ProjectLevelVcsManager" settingsEditedManually="true">
-    <ConfirmationsSetting value="2" id="Add" />
-  </component>
-  <component name="ProjectViewState">
-    <option name="hideEmptyMiddlePackages" value="true" />
-    <option name="showLibraryContents" value="true" />
-  </component>
-  <component name="PropertiesComponent"><![CDATA[{
-  "keyToString": {
-    "RunOnceActivity.OpenProjectViewOnStart": "true",
-    "RunOnceActivity.ShowReadmeOnStart": "true",
-    "WebServerToolWindowFactoryState": "false",
-    "last_opened_file_path": "C:/Users/Elias Dobrin/Documents/GitHub/softbodies",
-    "node.js.detected.package.eslint": "true",
-    "node.js.detected.package.tslint": "true",
-    "node.js.selected.package.eslint": "(autodetect)",
-    "node.js.selected.package.tslint": "(autodetect)"
-  }
-}]]></component>
-  <component name="SpellCheckerSettings" RuntimeDictionaries="0" Folders="0" CustomDictionaries="0" DefaultDictionary="application-level" UseSingleDictionary="true" transferred="true" />
-  <component name="TaskManager">
-    <task active="true" id="Default" summary="Default task">
-      <changelist id="44865169-17f5-40d2-b94e-08a42550aacd" name="Changes" comment="" />
-      <created>1655097020164</created>
-      <option name="number" value="Default" />
-      <option name="presentableId" value="Default" />
-      <updated>1655097020164</updated>
-      <workItem from="1655097025187" duration="252000" />
-      <workItem from="1655097348642" duration="4958000" />
-    </task>
-    <task id="LOCAL-00001" summary="packaged project">
-      <created>1655098217141</created>
-      <option name="number" value="00001" />
-      <option name="presentableId" value="LOCAL-00001" />
-      <option name="project" value="LOCAL" />
-      <updated>1655098217141</updated>
-    </task>
-    <task id="LOCAL-00002" summary="added setup.py">
-      <created>1655141613732</created>
-      <option name="number" value="00002" />
-      <option name="presentableId" value="LOCAL-00002" />
-      <option name="project" value="LOCAL" />
-      <updated>1655141613732</updated>
-    </task>
-    <task id="LOCAL-00003" summary="removed error dialog">
-      <created>1655141658924</created>
-      <option name="number" value="00003" />
-      <option name="presentableId" value="LOCAL-00003" />
-      <option name="project" value="LOCAL" />
-      <updated>1655141658924</updated>
-    </task>
-    <task id="LOCAL-00004" summary="fixed import bug">
-      <created>1655142210755</created>
-      <option name="number" value="00004" />
-      <option name="presentableId" value="LOCAL-00004" />
-      <option name="project" value="LOCAL" />
-      <updated>1655142210755</updated>
-    </task>
-    <task id="LOCAL-00005" summary="__init__ docstring">
-      <created>1655142323488</created>
-      <option name="number" value="00005" />
-      <option name="presentableId" value="LOCAL-00005" />
-      <option name="project" value="LOCAL" />
-      <updated>1655142323492</updated>
-    </task>
-    <task id="LOCAL-00006" summary="nothing">
-      <created>1655142372902</created>
-      <option name="number" value="00006" />
-      <option name="presentableId" value="LOCAL-00006" />
-      <option name="project" value="LOCAL" />
-      <updated>1655142372902</updated>
-    </task>
-    <option name="localTasksCounter" value="7" />
-    <servers />
-  </component>
-  <component name="TypeScriptGeneratedFilesManager">
-    <option name="version" value="3" />
-  </component>
-  <component name="Vcs.Log.Tabs.Properties">
-    <option name="TAB_STATES">
-      <map>
-        <entry key="MAIN">
-          <value>
-            <State />
-          </value>
-        </entry>
-      </map>
-    </option>
-  </component>
-  <component name="VcsManagerConfiguration">
-    <MESSAGE value="packaged project" />
-    <MESSAGE value="added setup.py" />
-    <MESSAGE value="removed error dialog" />
-    <MESSAGE value="fixed import bug" />
-    <MESSAGE value="__init__ docstring" />
-    <MESSAGE value="nothing" />
-    <option name="LAST_COMMIT_MESSAGE" value="nothing" />
-  </component>
-</project>
\ No newline at end of file
diff --git a/README.md b/README.md
new file mode 100644
index 0000000..7781515
--- /dev/null
+++ b/README.md
@@ -0,0 +1,2 @@
+# softbodies
+Python package for simulating physics of softbodies following Hooke's principles.

commit ee06a84405adbbcc8d87771638c4a8303ce06c2c
Author: Elias Dobrin <elias@dobrin.net>
Date:   Mon Jun 13 11:00:50 2022 -0700

    Revert "Merge branch 'main' of https://github.com/Elixonus/softbodies"
    
    This reverts commit 2e6cab08881fb9eadd0cfc88c57180f224bb1533, reversing
    changes made to 03466f0f19d6e78f79e72df2d071bec474995308.

diff --git a/.idea/workspace.xml b/.idea/workspace.xml
new file mode 100644
index 0000000..d53a10e
--- /dev/null
+++ b/.idea/workspace.xml
@@ -0,0 +1,127 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="AutoImportSettings">
+    <option name="autoReloadType" value="SELECTIVE" />
+  </component>
+  <component name="ChangeListManager">
+    <list default="true" id="44865169-17f5-40d2-b94e-08a42550aacd" name="Changes" comment="nothing">
+      <change beforePath="$PROJECT_DIR$/setup.py" beforeDir="false" afterPath="$PROJECT_DIR$/setup.py" afterDir="false" />
+    </list>
+    <option name="SHOW_DIALOG" value="false" />
+    <option name="HIGHLIGHT_CONFLICTS" value="true" />
+    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
+    <option name="LAST_RESOLUTION" value="IGNORE" />
+  </component>
+  <component name="FileTemplateManagerImpl">
+    <option name="RECENT_TEMPLATES">
+      <list>
+        <option value="Python Script" />
+      </list>
+    </option>
+  </component>
+  <component name="Git.Settings">
+    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
+  </component>
+  <component name="MarkdownSettingsMigration">
+    <option name="stateVersion" value="1" />
+  </component>
+  <component name="ProjectId" id="2AVa4AiD0XYoyfo6WTleRN4qDsP" />
+  <component name="ProjectLevelVcsManager" settingsEditedManually="true">
+    <ConfirmationsSetting value="2" id="Add" />
+  </component>
+  <component name="ProjectViewState">
+    <option name="hideEmptyMiddlePackages" value="true" />
+    <option name="showLibraryContents" value="true" />
+  </component>
+  <component name="PropertiesComponent"><![CDATA[{
+  "keyToString": {
+    "RunOnceActivity.OpenProjectViewOnStart": "true",
+    "RunOnceActivity.ShowReadmeOnStart": "true",
+    "WebServerToolWindowFactoryState": "false",
+    "last_opened_file_path": "C:/Users/Elias Dobrin/Documents/GitHub/softbodies",
+    "node.js.detected.package.eslint": "true",
+    "node.js.detected.package.tslint": "true",
+    "node.js.selected.package.eslint": "(autodetect)",
+    "node.js.selected.package.tslint": "(autodetect)"
+  }
+}]]></component>
+  <component name="SpellCheckerSettings" RuntimeDictionaries="0" Folders="0" CustomDictionaries="0" DefaultDictionary="application-level" UseSingleDictionary="true" transferred="true" />
+  <component name="TaskManager">
+    <task active="true" id="Default" summary="Default task">
+      <changelist id="44865169-17f5-40d2-b94e-08a42550aacd" name="Changes" comment="" />
+      <created>1655097020164</created>
+      <option name="number" value="Default" />
+      <option name="presentableId" value="Default" />
+      <updated>1655097020164</updated>
+      <workItem from="1655097025187" duration="252000" />
+      <workItem from="1655097348642" duration="4958000" />
+    </task>
+    <task id="LOCAL-00001" summary="packaged project">
+      <created>1655098217141</created>
+      <option name="number" value="00001" />
+      <option name="presentableId" value="LOCAL-00001" />
+      <option name="project" value="LOCAL" />
+      <updated>1655098217141</updated>
+    </task>
+    <task id="LOCAL-00002" summary="added setup.py">
+      <created>1655141613732</created>
+      <option name="number" value="00002" />
+      <option name="presentableId" value="LOCAL-00002" />
+      <option name="project" value="LOCAL" />
+      <updated>1655141613732</updated>
+    </task>
+    <task id="LOCAL-00003" summary="removed error dialog">
+      <created>1655141658924</created>
+      <option name="number" value="00003" />
+      <option name="presentableId" value="LOCAL-00003" />
+      <option name="project" value="LOCAL" />
+      <updated>1655141658924</updated>
+    </task>
+    <task id="LOCAL-00004" summary="fixed import bug">
+      <created>1655142210755</created>
+      <option name="number" value="00004" />
+      <option name="presentableId" value="LOCAL-00004" />
+      <option name="project" value="LOCAL" />
+      <updated>1655142210755</updated>
+    </task>
+    <task id="LOCAL-00005" summary="__init__ docstring">
+      <created>1655142323488</created>
+      <option name="number" value="00005" />
+      <option name="presentableId" value="LOCAL-00005" />
+      <option name="project" value="LOCAL" />
+      <updated>1655142323492</updated>
+    </task>
+    <task id="LOCAL-00006" summary="nothing">
+      <created>1655142372902</created>
+      <option name="number" value="00006" />
+      <option name="presentableId" value="LOCAL-00006" />
+      <option name="project" value="LOCAL" />
+      <updated>1655142372902</updated>
+    </task>
+    <option name="localTasksCounter" value="7" />
+    <servers />
+  </component>
+  <component name="TypeScriptGeneratedFilesManager">
+    <option name="version" value="3" />
+  </component>
+  <component name="Vcs.Log.Tabs.Properties">
+    <option name="TAB_STATES">
+      <map>
+        <entry key="MAIN">
+          <value>
+            <State />
+          </value>
+        </entry>
+      </map>
+    </option>
+  </component>
+  <component name="VcsManagerConfiguration">
+    <MESSAGE value="packaged project" />
+    <MESSAGE value="added setup.py" />
+    <MESSAGE value="removed error dialog" />
+    <MESSAGE value="fixed import bug" />
+    <MESSAGE value="__init__ docstring" />
+    <MESSAGE value="nothing" />
+    <option name="LAST_COMMIT_MESSAGE" value="nothing" />
+  </component>
+</project>
\ No newline at end of file
diff --git a/README.md b/README.md
deleted file mode 100644
index 7781515..0000000
--- a/README.md
+++ /dev/null
@@ -1,2 +0,0 @@
-# softbodies
-Python package for simulating physics of softbodies following Hooke's principles.

commit 2e6cab08881fb9eadd0cfc88c57180f224bb1533
Merge: 03466f0 75668bd
Author: Elias Dobrin <elias@dobrin.net>
Date:   Mon Jun 13 11:00:06 2022 -0700

    Merge branch 'main' of https://github.com/Elixonus/softbodies

commit 03466f0f19d6e78f79e72df2d071bec474995308
Author: Elias Dobrin <elias@dobrin.net>
Date:   Mon Jun 13 10:59:48 2022 -0700

    nothing

diff --git a/setup.py b/setup.py
index 711dd86..34aab13 100644
--- a/setup.py
+++ b/setup.py
@@ -6,6 +6,5 @@ setup(
     description="Module for simulating physics of softbodies following Hooke's principles.",
     author="Elias Dobrin",
     url="https://github.com/Elixonus/softbodies",
-    license="MIT",
     keywords=["softbody", "spring", "springs"]
 )

commit 75668bdb1de87d26fb517d3ec608a19bba4cb9f2
Author: Elias Dobrin <elias@dobrin.net>
Date:   Mon Jun 13 10:48:00 2022 -0700

    Create README.md

diff --git a/README.md b/README.md
new file mode 100644
index 0000000..7781515
--- /dev/null
+++ b/README.md
@@ -0,0 +1,2 @@
+# softbodies
+Python package for simulating physics of softbodies following Hooke's principles.

commit 7e5dbbb2afad9e91aa0ce1812a2d72335e767367
Author: Elias Dobrin <elias@dobrin.net>
Date:   Mon Jun 13 10:45:23 2022 -0700

    __init__ docstring

diff --git a/softbodies/__init__.py b/softbodies/__init__.py
index 614d4b9..9652743 100644
--- a/softbodies/__init__.py
+++ b/softbodies/__init__.py
@@ -1,2 +1,4 @@
+"""Package for simulating physics of softbodies following Hooke's principles."""
+
 from softbodies.softbodies import Softbody, Node, Link
 from softbodies.vectors import Vector

commit b7684ce57cc3fad22d71e29c538388c4f4c2ea75
Author: Elias Dobrin <elias@dobrin.net>
Date:   Mon Jun 13 10:43:30 2022 -0700

    fixed import bug

diff --git a/setup.py b/setup.py
index 7c2798c..711dd86 100644
--- a/setup.py
+++ b/setup.py
@@ -8,4 +8,4 @@ setup(
     url="https://github.com/Elixonus/softbodies",
     license="MIT",
     keywords=["softbody", "spring", "springs"]
-)
\ No newline at end of file
+)
diff --git a/softbodies/__init__.py b/softbodies/__init__.py
index bfb8955..614d4b9 100644
--- a/softbodies/__init__.py
+++ b/softbodies/__init__.py
@@ -1,2 +1,2 @@
-from softbodies import Softbody, Node, Link
-from vectors import Vector
+from softbodies.softbodies import Softbody, Node, Link
+from softbodies.vectors import Vector
diff --git a/softbodies/softbodies.py b/softbodies/softbodies.py
index 6e7cd0f..f4a5bb6 100644
--- a/softbodies/softbodies.py
+++ b/softbodies/softbodies.py
@@ -1,4 +1,4 @@
-"""Python module for simulating physics of softbodies following Hooke's principles."""
+"""Module for simulating physics of softbodies following Hooke's principles."""
 
 from __future__ import annotations
 from vectors import Vector
diff --git a/softbodies/vectors.py b/softbodies/vectors.py
index 6ab21b5..88a1b37 100644
--- a/softbodies/vectors.py
+++ b/softbodies/vectors.py
@@ -1,4 +1,4 @@
-"""Python module for dealing with two-dimensional vectors."""
+"""Module for dealing with two-dimensional vectors."""
 
 from __future__ import annotations
 from math import hypot

commit 588d9c6f3c9050173b3f4cf5d5a94bfed91652d5
Author: Elias Dobrin <elias@dobrin.net>
Date:   Mon Jun 13 10:34:18 2022 -0700

    removed error dialog

diff --git a/softbodies/vectors.py b/softbodies/vectors.py
index ff5b6bf..6ab21b5 100644
--- a/softbodies/vectors.py
+++ b/softbodies/vectors.py
@@ -124,9 +124,3 @@ class Vector:
     def copy(self) -> Vector:
         """Copy the vector instance."""
         return Vector(self.x, self.y)
-
-
-if __name__ == "__main__":
-    from time import sleep
-    print("Do not run me! This is just a dependency program")
-    sleep(5)
\ No newline at end of file

commit f4c4e6cce8949954f536b50f6f1a2823aafb2adb
Author: Elias Dobrin <elias@dobrin.net>
Date:   Mon Jun 13 10:33:33 2022 -0700

    added setup.py

diff --git a/setup.py b/setup.py
new file mode 100644
index 0000000..7c2798c
--- /dev/null
+++ b/setup.py
@@ -0,0 +1,11 @@
+from setuptools import setup
+
+setup(
+    name="softbodies",
+    version="1.0.0",
+    description="Module for simulating physics of softbodies following Hooke's principles.",
+    author="Elias Dobrin",
+    url="https://github.com/Elixonus/softbodies",
+    license="MIT",
+    keywords=["softbody", "spring", "springs"]
+)
\ No newline at end of file

commit aa6761418553b8b5a1c2957cfc3560a7fcffc795
Merge: 76364d6 ba69e2d
Author: Elias Dobrin <elias@dobrin.net>
Date:   Sun Jun 12 22:30:37 2022 -0700

    Merge remote-tracking branch 'origin/main'

commit 76364d61eb95181fc422eb22042647b6c4ff2306
Author: Elias Dobrin <elias@dobrin.net>
Date:   Sun Jun 12 22:30:16 2022 -0700

    packaged project

diff --git a/softbodies/__init__.py b/softbodies/__init__.py
new file mode 100644
index 0000000..bfb8955
--- /dev/null
+++ b/softbodies/__init__.py
@@ -0,0 +1,2 @@
+from softbodies import Softbody, Node, Link
+from vectors import Vector
diff --git a/softbodies.py b/softbodies/softbodies.py
similarity index 100%
rename from softbodies.py
rename to softbodies/softbodies.py
diff --git a/vectors.py b/softbodies/vectors.py
similarity index 100%
rename from vectors.py
rename to softbodies/vectors.py

commit ba69e2da217c8fb4d6728c4ed2472b0a8dd3ea9c
Author: Elias Dobrin <elias@dobrin.net>
Date:   Sun Jun 12 22:24:52 2022 -0700

    Create LICENSE

diff --git a/LICENSE b/LICENSE
new file mode 100644
index 0000000..9fe37c5
--- /dev/null
+++ b/LICENSE
@@ -0,0 +1,21 @@
+MIT License
+
+Copyright (c) 2022 Elias Dobrin
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.

commit 575d2ffbd7bd249e896526d3105851d0eb571ea1
Author: Elias Dobrin <elias@dobrin.net>
Date:   Sun Jun 12 17:33:06 2022 -0700

    annotated

diff --git a/.gitattributes b/.gitattributes
deleted file mode 100644
index dfe0770..0000000
--- a/.gitattributes
+++ /dev/null
@@ -1,2 +0,0 @@
-# Auto detect text files and perform LF normalization
-* text=auto
diff --git a/softbodies.py b/softbodies.py
index dc07db2..6e7cd0f 100644
--- a/softbodies.py
+++ b/softbodies.py
@@ -1,12 +1,16 @@
+"""Python module for simulating physics of softbodies following Hooke's principles."""
+
 from __future__ import annotations
 from vectors import Vector
 
 
 class Softbody:
+    """An object which encapsulates a set of nodes and links."""
     nodes: list[Node]
     links: list[Link]
 
     def __init__(self, nodes: list[Node], links: list[Link]) -> None:
+        """Create a softbody from a list of nodes and list of links."""
         self.nodes = nodes
         self.links = links
 
@@ -20,6 +24,7 @@ class Node:
     force: Vector
 
     def __init__(self, mass: float, position: Vector) -> None:
+        """Create a node from mass and position that is static."""
         self.mass = mass
         self.position = position
         self.velocity = Vector(0, 0)
@@ -35,6 +40,7 @@ class Link:
     dampening: float
 
     def __init__(self, nodes: tuple[Node, Node], stiffness: float, dampening: float, length: float = None) -> None:
+        """Create a link from a pair of nodes, stiffness coefficient, dampening coefficient and length."""
         self.nodes = nodes
         if length is None:
             self.length = Vector.dist(nodes[0].position, nodes[1].position)
diff --git a/vectors.py b/vectors.py
index edfdee0..ff5b6bf 100644
--- a/vectors.py
+++ b/vectors.py
@@ -1,4 +1,4 @@
-"""Python module for dealing with two-dimensional cartesian coordinates and vector operations."""
+"""Python module for dealing with two-dimensional vectors."""
 
 from __future__ import annotations
 from math import hypot

commit 5c8ce417c4deac3d839ee574cc5bbfaa8e4a168b
Author: Elias Dobrin <elias@dobrin.net>
Date:   Sun Jun 12 17:22:06 2022 -0700

    cleanup files

diff --git a/.gitignore b/.gitignore
deleted file mode 100644
index 570b976..0000000
--- a/.gitignore
+++ /dev/null
@@ -1,3 +0,0 @@
-output.mp4
-venv
-.idea
\ No newline at end of file
diff --git a/output.mp4 b/output.mp4
deleted file mode 100644
index 17911ea..0000000
Binary files a/output.mp4 and /dev/null differ
diff --git a/sb_square_friction.py b/sb_square_friction.py
deleted file mode 100644
index da8fe3c..0000000
--- a/sb_square_friction.py
+++ /dev/null
@@ -1,108 +0,0 @@
-import os
-from math import tau, pi
-from time import sleep
-import cairo
-import ffmpeg
-from structures import Tower
-from vectors import Vector
-
-print("This program will simulate the physics of a softbody square mesh thrown across the ground.")
-sleep(1)
-print("Enter the friction coefficient.")
-
-friction_coefficient = 0
-while True:
-    try:
-        friction_coefficient = float(input("Cf [0.0-1]: "))
-        assert 0 <= friction_coefficient <= 1
-        break
-    except:
-        continue
-
-print("Solving differential equations...")
-
-structure = Tower(width=0.2, height=0.2, grid=(2, 2), mass=0.1, stiffness=50, dampening=1)
-structure.rotate(pi / 6, center=Vector(0, 0))
-structure.translate(Vector(0.2, 0.2))
-nodes, links = structure.get_components()
-
-for node in nodes:
-    node.velocity.x += 3.5
-
-camera_position = Vector(0.5, 0.5)
-camera_zoom = 0.9
-
-
-os.makedirs("output", exist_ok=True)
-for png in os.scandir("output"):
-    os.remove(png)
-
-for i in range(250):
-    for s in range(10):
-        for node in nodes:
-            node.force.set(Vector(0, -9.8 * node.mass))
-        for link in links:
-            link.nodes[0].force.add(link.get_force() * (link.nodes[0].position - link.nodes[1].position) / Vector.dist(
-                link.nodes[0].position, link.nodes[1].position))
-            link.nodes[1].force.add(link.get_force() * (link.nodes[1].position - link.nodes[0].position) / Vector.dist(
-                link.nodes[0].position, link.nodes[1].position))
-
-        for node in nodes:
-            force_normal = Vector(0, 0)
-            if node.position.x < 0:
-                force_normal.x += 100 * abs(node.position.x)
-            elif node.position.x > 1:
-                force_normal.x -= 100 * abs(1 - node.position.x)
-            if node.position.y < 0:
-                force_normal.y += 100 * abs(node.position.y)
-            elif node.position.y > 1:
-                force_normal.y -= 100 * abs(1 - node.position.y)
-            try:
-                force_friction = friction_coefficient * force_normal.len() * Vector(-node.velocity.x, 0)
-            except ZeroDivisionError:
-                force_friction = Vector(0, 0)
-            node.force += force_normal + force_friction
-
-        for node in nodes:
-            node.acceleration = node.force / node.mass
-            node.velocity += node.acceleration * 0.0005
-            node.position += node.velocity * 0.0005
-
-    surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 500, 500)
-    context = cairo.Context(surface)
-    context.scale(500, 500)
-    context.rectangle(0, 0, 1, 1)
-    context.set_source_rgb(1, 1, 1)
-    context.fill()
-    context.translate(0.5, 0.5)
-    context.scale(1, -1)
-    context.scale(camera_zoom, camera_zoom)
-    context.translate(-camera_position.x, -camera_position.y)
-
-    context.rectangle(0, 0, 1, 1)
-    context.set_source_rgb(0, 0, 0)
-    context.set_line_width(0.01)
-    context.stroke()
-
-    for link in links:
-        context.move_to(link.nodes[0].position.x, link.nodes[0].position.y)
-        context.line_to(link.nodes[1].position.x, link.nodes[1].position.y)
-        context.set_source_rgb(1, 0.3 - abs(link.get_force() / 3), 0.3 - abs(link.get_force() / 3))
-        context.set_line_width(0.01 * (link.length / link.get_length()))
-        context.stroke()
-
-    for node in nodes:
-        context.arc(node.position.x, node.position.y, 0.01, 0, tau)
-        context.set_source_rgb(1, 1, 1)
-        context.fill_preserve()
-        context.set_source_rgb(0, 0, 0)
-        context.set_line_width(0.005)
-        context.stroke()
-
-    surface.write_to_png(f"output/{i:06d}.png")
-
-ffmpeg.input("output/%06d.png", pattern_type="sequence", framerate=60).output("output.mp4").run(overwrite_output=True)
-for png in os.scandir("output"):
-    os.remove(png)
-os.rmdir("output")
-os.startfile("output.mp4")
\ No newline at end of file
diff --git a/sb_square_launch.py b/sb_square_launch.py
deleted file mode 100644
index a787e37..0000000
--- a/sb_square_launch.py
+++ /dev/null
@@ -1,121 +0,0 @@
-import os
-from math import pi, tau
-from time import sleep
-import cairo
-import ffmpeg
-from structures import Tower
-from vectors import Vector
-
-print("This program will simulate the physics of a softbody square mesh.")
-sleep(1)
-print("The object is dropped from a height of 0.5 meters and is then launched diagonally.\n")
-sleep(1)
-
-print("Enter the number of lateral grid elements in the mesh.")
-grid_x = 1
-while True:
-    try:
-        grid_x = int(input("[1-7]: "))
-        assert 1 <= grid_x <= 7
-        break
-    except:
-        continue
-
-print("Enter the number of medial grid elements in the mesh.")
-grid_y = 1
-while True:
-    try:
-        grid_y = int(input("[1-7]: "))
-        assert 1 <= grid_y <= 7
-        break
-    except:
-        continue
-
-print("Solving differential equations...")
-
-structure = Tower(width=0.1 * grid_x, height=0.1 * grid_y, grid=(grid_x, grid_y), mass=0.1, stiffness=50, dampening=1)
-structure.translate(Vector(0.5, 0.5))
-structure.rotate(pi / 12, center=Vector(0.5, 0.5))
-nodes, links = structure.get_components()
-
-camera_position = Vector(0.5, 0.5)
-camera_zoom = 0.9
-
-
-os.makedirs("output", exist_ok=True)
-for png in os.scandir("output"):
-    os.remove(png)
-
-for i in range(250):
-    if i == 100:
-        for node in nodes:
-            node.velocity.x += 3
-            node.velocity.y += 5
-
-    for s in range(10):
-        for node in nodes:
-            node.force.set(Vector(0, -9.8 * node.mass))
-        for link in links:
-            link.nodes[0].force.add(link.get_force() * (link.nodes[0].position - link.nodes[1].position) / Vector.dist(
-                link.nodes[0].position, link.nodes[1].position))
-            link.nodes[1].force.add(link.get_force() * (link.nodes[1].position - link.nodes[0].position) / Vector.dist(
-                link.nodes[0].position, link.nodes[1].position))
-
-        for node in nodes:
-            force_normal = Vector(0, 0)
-            if node.position.x < 0:
-                force_normal.x += 100 * abs(node.position.x)
-            elif node.position.x > 1:
-                force_normal.x -= 100 * abs(1 - node.position.x)
-            if node.position.y < 0:
-                force_normal.y += 100 * abs(node.position.y)
-            elif node.position.y > 1:
-                force_normal.y -= 100 * abs(1 - node.position.y)
-            try:
-                force_friction = -0.25 * force_normal.len() * (node.velocity / node.velocity.len())
-            except ZeroDivisionError:
-                force_friction = Vector(0, 0)
-            node.force += force_normal + force_friction
-
-        for node in nodes:
-            node.integrate(time=0.0005)
-
-    surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 500, 500)
-    context = cairo.Context(surface)
-    context.scale(500, 500)
-    context.rectangle(0, 0, 1, 1)
-    context.set_source_rgb(1, 1, 1)
-    context.fill()
-    context.translate(0.5, 0.5)
-    context.scale(1, -1)
-    context.scale(camera_zoom, camera_zoom)
-    context.translate(-camera_position.x, -camera_position.y)
-
-    context.rectangle(0, 0, 1, 1)
-    context.set_source_rgb(0, 0, 0)
-    context.set_line_width(0.01)
-    context.stroke()
-
-    for link in links:
-        context.move_to(link.nodes[0].position.x, link.nodes[0].position.y)
-        context.line_to(link.nodes[1].position.x, link.nodes[1].position.y)
-        context.set_source_rgb(0, 0, 0)
-        context.set_line_width(0.01 * (link.length / link.get_length()))
-        context.stroke()
-
-    for node in nodes:
-        amt = node.velocity.len()
-        context.arc(node.position.x, node.position.y, 0.01, 0, tau)
-        context.set_source_rgb(1, 1 - amt / 5, 1 - amt / 5)
-        context.fill_preserve()
-        context.set_source_rgb(0, 0, 0)
-        context.set_line_width(0.005)
-        context.stroke()
-
-    surface.write_to_png(f"output/{i:06d}.png")
-
-ffmpeg.input("output/%06d.png", pattern_type="sequence", framerate=60).output("output.mp4").run(overwrite_output=True)
-for png in os.scandir("output"):
-    os.remove(png)
-os.rmdir("output")
-os.startfile("output.mp4")
\ No newline at end of file
diff --git a/sb_square_pinned.py b/sb_square_pinned.py
deleted file mode 100644
index 5c480be..0000000
--- a/sb_square_pinned.py
+++ /dev/null
@@ -1,116 +0,0 @@
-import os
-from math import tau
-from time import sleep
-import cairo
-import ffmpeg
-from structures import Tower
-from vectors import Vector
-
-print("This program will simulate the physics of a softbody square mesh with two fixated nodes.")
-sleep(1)
-
-print("Enter the number of lateral grid elements in the mesh.")
-grid_x = 1
-while True:
-    try:
-        grid_x = int(input("[1-7]: "))
-        assert 1 <= grid_x <= 7
-        break
-    except:
-        continue
-
-print("Enter the number of medial grid elements in the mesh.")
-grid_y = 1
-while True:
-    try:
-        grid_y = int(input("[1-7]: "))
-        assert 1 <= grid_y <= 7
-        break
-    except:
-        continue
-
-print("Solving differential equations...")
-
-structure = Tower(width=0.1 * grid_x, height=0.1 * grid_y, grid=(grid_x, grid_y), mass=0.1, stiffness=10, dampening=0.1)
-structure.translate(Vector(0.5, 0.5))
-nodes, links = structure.get_components()
-
-camera_position = Vector(0.5, 0.5)
-camera_zoom = 0.9
-
-
-os.makedirs("output", exist_ok=True)
-for png in os.scandir("output"):
-    os.remove(png)
-
-for i in range(250):
-    for s in range(10):
-        for node in nodes:
-            node.force.set(Vector(0, -9.8 * node.mass))
-        for link in links:
-            link.nodes[0].force.add(link.get_force() * (link.nodes[0].position - link.nodes[1].position) / Vector.dist(
-                link.nodes[0].position, link.nodes[1].position))
-            link.nodes[1].force.add(link.get_force() * (link.nodes[1].position - link.nodes[0].position) / Vector.dist(
-                link.nodes[0].position, link.nodes[1].position))
-
-        for node in nodes:
-            force_normal = Vector(0, 0)
-            if node.position.x < 0:
-                force_normal.x += 100 * abs(node.position.x)
-            elif node.position.x > 1:
-                force_normal.x -= 100 * abs(1 - node.position.x)
-            if node.position.y < 0:
-                force_normal.y += 100 * abs(node.position.y)
-            elif node.position.y > 1:
-                force_normal.y -= 100 * abs(1 - node.position.y)
-            try:
-                force_friction = -0.25 * force_normal.len() * (node.velocity / node.velocity.len())
-            except ZeroDivisionError:
-                force_friction = Vector(0, 0)
-            node.force += force_normal + force_friction
-
-        for node in nodes:
-            structure.nodes_tower[0][-1].force.set(Vector(0, 0))
-            structure.nodes_tower[-1][-1].force.set(Vector(0, 0))
-        for node in nodes:
-            node.integrate(time=0.0005)
-
-    surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 500, 500)
-    context = cairo.Context(surface)
-    context.scale(500, 500)
-    context.rectangle(0, 0, 1, 1)
-    context.set_source_rgb(1, 1, 1)
-    context.fill()
-    context.translate(0.5, 0.5)
-    context.scale(1, -1)
-    context.scale(camera_zoom, camera_zoom)
-    context.translate(-camera_position.x, -camera_position.y)
-
-    context.rectangle(0, 0, 1, 1)
-    context.set_source_rgb(0, 0, 0)
-    context.set_line_width(0.01)
-    context.stroke()
-
-    for link in links:
-        context.move_to(link.nodes[0].position.x, link.nodes[0].position.y)
-        context.line_to(link.nodes[1].position.x, link.nodes[1].position.y)
-        context.set_source_rgb(0, 0, 0)
-        context.set_line_width(0.01 * (link.length / link.get_length()))
-        context.stroke()
-
-    for node in nodes:
-        amt = node.velocity.len()
-        context.arc(node.position.x, node.position.y, 0.01, 0, tau)
-        context.set_source_rgb(1, 1 - amt / 5, 1 - amt / 5)
-        context.fill_preserve()
-        context.set_source_rgb(0, 0, 0)
-        context.set_line_width(0.005)
-        context.stroke()
-
-    surface.write_to_png(f"output/{i:06d}.png")
-
-ffmpeg.input("output/%06d.png", pattern_type="sequence", framerate=60).output("output.mp4").run(overwrite_output=True)
-for png in os.scandir("output"):
-    os.remove(png)
-os.rmdir("output")
-os.startfile("output.mp4")
\ No newline at end of file
diff --git a/sb_square_pivot.py b/sb_square_pivot.py
deleted file mode 100644
index da9d520..0000000
--- a/sb_square_pivot.py
+++ /dev/null
@@ -1,116 +0,0 @@
-import os
-from math import tau, pi
-from time import sleep
-import cairo
-import ffmpeg
-from structures import Tower
-from vectors import Vector
-
-print("This program will simulate the physics of a softbody square mesh with one fixated node.")
-sleep(1)
-
-print("Enter the number of lateral grid elements in the mesh.")
-grid_x = 1
-while True:
-    try:
-        grid_x = int(input("[1-5]: "))
-        assert 1 <= grid_x <= 5
-        break
-    except:
-        continue
-
-print("Enter the number of medial grid elements in the mesh.")
-grid_y = 1
-while True:
-    try:
-        grid_y = int(input("[1-5]: "))
-        assert 1 <= grid_y <= 5
-        break
-    except:
-        continue
-
-print("Solving differential equations...")
-
-structure = Tower(width=0.1 * grid_x, height=0.1 * grid_y, grid=(grid_x, grid_y), mass=0.1, stiffness=10, dampening=0.1)
-structure.rotate(pi / 6, center=Vector(0, 0))
-structure.translate(Vector(0.5, 0.5))
-nodes, links = structure.get_components()
-
-camera_position = Vector(0.5, 0.5)
-camera_zoom = 0.9
-
-
-os.makedirs("output", exist_ok=True)
-for png in os.scandir("output"):
-    os.remove(png)
-
-for i in range(250):
-    for s in range(10):
-        for node in nodes:
-            node.force.set(Vector(0, -9.8 * node.mass))
-        for link in links:
-            link.nodes[0].force.add(link.get_force() * (link.nodes[0].position - link.nodes[1].position) / Vector.dist(
-                link.nodes[0].position, link.nodes[1].position))
-            link.nodes[1].force.add(link.get_force() * (link.nodes[1].position - link.nodes[0].position) / Vector.dist(
-                link.nodes[0].position, link.nodes[1].position))
-
-        for node in nodes:
-            force_normal = Vector(0, 0)
-            if node.position.x < 0:
-                force_normal.x += 100 * abs(node.position.x)
-            elif node.position.x > 1:
-                force_normal.x -= 100 * abs(1 - node.position.x)
-            if node.position.y < 0:
-                force_normal.y += 100 * abs(node.position.y)
-            elif node.position.y > 1:
-                force_normal.y -= 100 * abs(1 - node.position.y)
-            try:
-                force_friction = -0.25 * force_normal.len() * (node.velocity / node.velocity.len())
-            except ZeroDivisionError:
-                force_friction = Vector(0, 0)
-            node.force += force_normal + force_friction
-
-        for node in nodes:
-            structure.nodes_tower[0][-1].force.set(Vector(0, 0))
-        for node in nodes:
-            node.integrate(time=0.0005)
-
-    surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 500, 500)
-    context = cairo.Context(surface)
-    context.scale(500, 500)
-    context.rectangle(0, 0, 1, 1)
-    context.set_source_rgb(1, 1, 1)
-    context.fill()
-    context.translate(0.5, 0.5)
-    context.scale(1, -1)
-    context.scale(camera_zoom, camera_zoom)
-    context.translate(-camera_position.x, -camera_position.y)
-
-    context.rectangle(0, 0, 1, 1)
-    context.set_source_rgb(0, 0, 0)
-    context.set_line_width(0.01)
-    context.stroke()
-
-    for link in links:
-        context.move_to(link.nodes[0].position.x, link.nodes[0].position.y)
-        context.line_to(link.nodes[1].position.x, link.nodes[1].position.y)
-        context.set_source_rgb(0, 0, 0)
-        context.set_line_width(0.01 * (link.length / link.get_length()))
-        context.stroke()
-
-    for node in nodes:
-        amt = node.velocity.len()
-        context.arc(node.position.x, node.position.y, 0.01, 0, tau)
-        context.set_source_rgb(1, 1 - amt / 5, 1 - amt / 5)
-        context.fill_preserve()
-        context.set_source_rgb(0, 0, 0)
-        context.set_line_width(0.005)
-        context.stroke()
-
-    surface.write_to_png(f"output/{i:06d}.png")
-
-ffmpeg.input("output/%06d.png", pattern_type="sequence", framerate=60).output("output.mp4").run(overwrite_output=True)
-for png in os.scandir("output"):
-    os.remove(png)
-os.rmdir("output")
-os.startfile("output.mp4")
\ No newline at end of file
diff --git a/sb_triangle_launch.py b/sb_triangle_launch.py
deleted file mode 100644
index 0eb8ff9..0000000
--- a/sb_triangle_launch.py
+++ /dev/null
@@ -1,111 +0,0 @@
-import os
-from math import pi, tau
-from time import sleep
-import cairo
-import ffmpeg
-from structures import Pyramid
-from vectors import Vector
-
-print("This program will simulate the physics of a softbody triangle mesh.")
-sleep(1)
-print("The object is dropped from a height of 0.5 meters and is then launched diagonally.\n")
-sleep(1)
-
-print("Enter the number of edge grid elements in the mesh.")
-grid = 1
-while True:
-    try:
-        grid = int(input("[1-7]: "))
-        assert 1 <= grid <= 7
-        break
-    except:
-        continue
-
-print("Solving differential equations...")
-
-structure = Pyramid(width=0.1 * grid, grid=grid, mass=0.1, stiffness=100, dampening=1)
-structure.translate(Vector(0.5, 0.5))
-structure.rotate(pi / 12, center=Vector(0.5, 0.5))
-nodes, links = structure.get_components()
-
-camera_position = Vector(0.5, 0.5)
-camera_zoom = 0.9
-
-
-os.makedirs("output", exist_ok=True)
-for png in os.scandir("output"):
-    os.remove(png)
-
-for i in range(250):
-    if i == 100:
-        for node in nodes:
-            node.velocity.x += 3
-            node.velocity.y += 5
-
-    for s in range(10):
-        for node in nodes:
-            node.force.set(Vector(0, -9.8 * node.mass))
-        for link in links:
-            link.nodes[0].force.add(link.get_force() * (link.nodes[0].position - link.nodes[1].position) / Vector.dist(
-                link.nodes[0].position, link.nodes[1].position))
-            link.nodes[1].force.add(link.get_force() * (link.nodes[1].position - link.nodes[0].position) / Vector.dist(
-                link.nodes[0].position, link.nodes[1].position))
-
-        for node in nodes:
-            force_normal = Vector(0, 0)
-            if node.position.x < 0:
-                force_normal.x += 100 * abs(node.position.x)
-            elif node.position.x > 1:
-                force_normal.x -= 100 * abs(1 - node.position.x)
-            if node.position.y < 0:
-                force_normal.y += 100 * abs(node.position.y)
-            elif node.position.y > 1:
-                force_normal.y -= 100 * abs(1 - node.position.y)
-            try:
-                force_friction = -0.25 * force_normal.len() * (node.velocity / node.velocity.len())
-            except ZeroDivisionError:
-                force_friction = Vector(0, 0)
-            node.force += force_normal + force_friction
-
-        for node in nodes:
-            node.integrate(time=0.0005)
-
-    surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 500, 500)
-    context = cairo.Context(surface)
-    context.scale(500, 500)
-    context.rectangle(0, 0, 1, 1)
-    context.set_source_rgb(1, 1, 1)
-    context.fill()
-    context.translate(0.5, 0.5)
-    context.scale(1, -1)
-    context.scale(camera_zoom, camera_zoom)
-    context.translate(-camera_position.x, -camera_position.y)
-
-    context.rectangle(0, 0, 1, 1)
-    context.set_source_rgb(0, 0, 0)
-    context.set_line_width(0.01)
-    context.stroke()
-
-    for link in links:
-        context.move_to(link.nodes[0].position.x, link.nodes[0].position.y)
-        context.line_to(link.nodes[1].position.x, link.nodes[1].position.y)
-        context.set_source_rgb(0, 0, 0)
-        context.set_line_width(0.01 * (link.length / link.get_length()))
-        context.stroke()
-
-    for node in nodes:
-        amt = node.velocity.len()
-        context.arc(node.position.x, node.position.y, 0.01, 0, tau)
-        context.set_source_rgb(1, 1 - amt / 5, 1 - amt / 5)
-        context.fill_preserve()
-        context.set_source_rgb(0, 0, 0)
-        context.set_line_width(0.005)
-        context.stroke()
-
-    surface.write_to_png(f"output/{i:06d}.png")
-
-ffmpeg.input("output/%06d.png", pattern_type="sequence", framerate=60).output("output.mp4").run(overwrite_output=True)
-for png in os.scandir("output"):
-    os.remove(png)
-os.rmdir("output")
-os.startfile("output.mp4")
\ No newline at end of file
diff --git a/structures.py b/structures.py
deleted file mode 100644
index 9b95abf..0000000
--- a/structures.py
+++ /dev/null
@@ -1,135 +0,0 @@
-from __future__ import annotations
-from math import sqrt, cos, sin, atan2, tau
-from softbodies import Softbody, Node, Link
-from vectors import Vector
-
-
-class Structure(Softbody):
-    nodes: list[Node]
-    links: list[Link]
-
-    def __init__(self, nodes: list[Node], links: list[Link]) -> None:
-        super().__init__(nodes, links)
-
-    def get_components(self) -> tuple[list[Node], list[Link]]:
-        return self.nodes, self.links
-
-    def get_total_mass(self) -> float:
-        total_mass = sum(node.mass for node in self.nodes)
-        return total_mass
-
-    def get_center_mass(self) -> Vector:
-        center_mass = sum(node.mass * node.position for node in self.nodes)
-        return center_mass
-
-    def translate(self, vector: Vector) -> None:
-        for node in self.nodes:
-            node.position += vector
-
-    def scale(self, factor: float, center: Vector = None) -> None:
-        if center is None:
-            center = Vector(0, 0)
-        self.translate(-center)
-        for node in self.nodes:
-            node.position *= factor
-        for link in self.links:
-            link.length *= factor
-        self.translate(center)
-
-    def rotate(self, radians: float, center: Vector = None) -> None:
-        if center is None:
-            center = Vector(0, 0)
-        self.translate(-center)
-        for node in self.nodes:
-            node_angle = atan2(node.position.y, node.position.x)
-            node_radius = node.position.len()
-            node.position.x = node_radius * cos(node_angle + radians)
-            node.position.y = node_radius * sin(node_angle + radians)
-        self.translate(center)
-
-
-class Tower(Structure):
-    nodes_tower: list[list[Node]]
-
-    def __init__(self, width: float, height: float, grid: tuple[int, int], mass: float, stiffness: float, dampening: float) -> None:
-        nodes_tower = []
-        for x in range(grid[0] + 1):
-            nodes_tower.append([])
-            for y in range(grid[1] + 1):
-                node_mass = mass / ((grid[0] + 1) * (grid[1] + 1))
-                node_position = Vector(width * (x / grid[0] - 0.5),
-                                       height * (y / grid[1] - 0.5))
-                node = Node(node_mass, node_position)
-                nodes_tower[x].append(node)
-        links = []
-        for x in range(grid[0]):
-            for y in range(grid[1] + 1):
-                links.append(Link((nodes_tower[x][y], nodes_tower[x + 1][y]), stiffness, dampening))
-        for x in range(grid[0] + 1):
-            for y in range(grid[1]):
-                links.append(Link((nodes_tower[x][y], nodes_tower[x][y + 1]), stiffness, dampening))
-        for x in range(grid[0]):
-            for y in range(grid[1]):
-                links.append(Link((nodes_tower[x][y], nodes_tower[x + 1][y + 1]), stiffness, dampening))
-                links.append(Link((nodes_tower[x + 1][y], nodes_tower[x][y + 1]), stiffness, dampening))
-        nodes = [node for buffer in nodes_tower for node in buffer]
-        super().__init__(nodes, links)
-        self.nodes_tower = nodes_tower
-
-
-class Pyramid(Structure):
-    nodes_pyramid: list[list[Node]]
-
-    def __init__(self, width: float, grid: int, mass: float, stiffness: float, dampening: float) -> None:
-        height = (sqrt(3) / 2) * width
-        nodes_pyramid = []
-        for y in range(grid + 1):
-            nodes_pyramid.append([])
-            for x in range(grid + 1 - y):
-                node_mass = mass / ((grid + 1) * (grid + 2) / 2)
-                node_position = Vector(width * ((x + 0.5 * y) / grid - 0.5),
-                                       height * (y / grid - 0.5))
-                node = Node(node_mass, node_position)
-                nodes_pyramid[y].append(node)
-        links = []
-        for y in range(grid):
-            for x in range(grid - y):
-                links.append(Link((nodes_pyramid[y][x], nodes_pyramid[y + 1][x]), stiffness, dampening))
-                links.append(Link((nodes_pyramid[y][x], nodes_pyramid[y][x + 1]), stiffness, dampening))
-                links.append(Link((nodes_pyramid[y][-x - 1], nodes_pyramid[y + 1][-x - 1]), stiffness, dampening))
-        nodes = [node for buffer in nodes_pyramid for node in buffer]
-        super().__init__(nodes, links)
-        self.nodes_pyramid = nodes_pyramid
-
-
-class Wheel(Structure):
-    def __init__(self, radius: float, rings: int, slices: int, mass: float, stiffness: float, dampening: float) -> None:
-        node_mass = mass / (rings * slices + 1)
-        nodes_mesh = [[Node(node_mass, Vector(0, 0))]]
-        for r in range(1, rings + 1):
-            nodes_mesh.append([])
-            for s in range(slices):
-                ang = (s / slices) * tau
-                rad = (r / rings) * radius
-                node_position = Vector(rad * cos(ang),
-                                       rad * sin(ang))
-                node = Node(node_mass, node_position)
-                nodes_mesh[r].append(node)
-        links = []
-        for r in range(1, rings + 1):
-            for s in range(slices):
-                links.append(Link((nodes_mesh[r][s], nodes_mesh[r][(s + 1) % slices]), stiffness, dampening))
-        for s in range(slices):
-            links.append(Link((nodes_mesh[0][0], nodes_mesh[1][s]), stiffness, dampening))
-        for r in range(1, rings):
-            for s in range(slices):
-                links.append(Link((nodes_mesh[r][s], nodes_mesh[r + 1][s]), stiffness, dampening))
-
-        nodes = [node for buffer in nodes_mesh for node in buffer]
-        super().__init__(nodes, links)
-
-
-if __name__ == "__main__":
-    from time import sleep
-    print("Do not run me! This is just a dependency program")
-    sleep(5)
\ No newline at end of file

commit 33bb02a941f50b8a86755d8802c6e596c052c670
Author: Daxonus <elias@dobrin.net>
Date:   Mon Jun 6 09:48:06 2022 -0700

    fixed softbodies library

diff --git a/output.mp4 b/output.mp4
index 8b94ef5..17911ea 100644
Binary files a/output.mp4 and b/output.mp4 differ
diff --git a/sb_square_friction.py b/sb_square_friction.py
index 761d9b6..da8fe3c 100644
--- a/sb_square_friction.py
+++ b/sb_square_friction.py
@@ -58,13 +58,15 @@ for i in range(250):
             elif node.position.y > 1:
                 force_normal.y -= 100 * abs(1 - node.position.y)
             try:
-                force_friction = -1 * friction_coefficient * force_normal.len() * (node.velocity / node.velocity.len())
+                force_friction = friction_coefficient * force_normal.len() * Vector(-node.velocity.x, 0)
             except ZeroDivisionError:
                 force_friction = Vector(0, 0)
             node.force += force_normal + force_friction
 
         for node in nodes:
-            node.integrate(time=0.0005)
+            node.acceleration = node.force / node.mass
+            node.velocity += node.acceleration * 0.0005
+            node.position += node.velocity * 0.0005
 
     surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 500, 500)
     context = cairo.Context(surface)
@@ -85,14 +87,13 @@ for i in range(250):
     for link in links:
         context.move_to(link.nodes[0].position.x, link.nodes[0].position.y)
         context.line_to(link.nodes[1].position.x, link.nodes[1].position.y)
-        context.set_source_rgb(0, 0, 0)
+        context.set_source_rgb(1, 0.3 - abs(link.get_force() / 3), 0.3 - abs(link.get_force() / 3))
         context.set_line_width(0.01 * (link.length / link.get_length()))
         context.stroke()
 
     for node in nodes:
-        amt = node.velocity.len()
         context.arc(node.position.x, node.position.y, 0.01, 0, tau)
-        context.set_source_rgb(1, 1 - amt / 5, 1 - amt / 5)
+        context.set_source_rgb(1, 1, 1)
         context.fill_preserve()
         context.set_source_rgb(0, 0, 0)
         context.set_line_width(0.005)
diff --git a/softbodies.py b/softbodies.py
index ce74f33..dc07db2 100644
--- a/softbodies.py
+++ b/softbodies.py
@@ -10,30 +10,22 @@ class Softbody:
         self.nodes = nodes
         self.links = links
 
-    def integrate(self, time: float) -> None:
-        for node in self.nodes:
-            node.integrate(time)
-
 
 class Node:
     """A point mass particle that implements Euler integration."""
     mass: float
     position: Vector
     velocity: Vector
+    acceleration: Vector
     force: Vector
 
     def __init__(self, mass: float, position: Vector) -> None:
         self.mass = mass
         self.position = position
         self.velocity = Vector(0, 0)
+        self.acceleration = Vector(0, 0)
         self.force = Vector(0, 0)
 
-    def integrate(self, time: float) -> None:
-        """Integrate the position and velocity with Euler's method."""
-        acceleration = self.force / self.mass
-        self.velocity += acceleration * time
-        self.position += self.velocity * time
-
 
 class Link:
     """A massless Hookean spring that features a pair of spring stiffness and dampening forces."""
@@ -55,7 +47,7 @@ class Link:
         """Get the momentary length of the link."""
         return Vector.dist(self.nodes[0].position, self.nodes[1].position)
 
-    def get_speed(self) -> float:
+    def get_velocity(self) -> float:
         """Get the speed of the expansion/contraction of the link (positive/negative)."""
         return Vector.dot(self.nodes[0].position - self.nodes[1].position, self.nodes[0].velocity - self.nodes[1].velocity) / self.get_length()
 
@@ -69,18 +61,8 @@ class Link:
 
     def get_dampening_force(self) -> float:
         """Get the spring dampening force expansion/contraction (positive/negative)."""
-        return -self.dampening * self.get_speed()
+        return -self.dampening * self.get_velocity()
 
     def get_force(self) -> float:
         """Get the spring force expansion/contraction (positive/negative)."""
         return self.get_stiffness_force() + self.get_dampening_force()
-
-    def integrate(self, time: float) -> None:
-        self.nodes[0].integrate(time)
-        self.nodes[1].integrate(time)
-
-
-if __name__ == "__main__":
-    from time import sleep
-    print("Do not run me! This is just a dependency program")
-    sleep(5)
\ No newline at end of file

commit 037b728643f8bf848876371d067608f5495430c4
Author: Daxonus <elias@dobrin.net>
Date:   Mon May 30 19:15:50 2022 -0700

    added 2 example files

diff --git a/output.mp4 b/output.mp4
index 70a10b2..8b94ef5 100644
Binary files a/output.mp4 and b/output.mp4 differ
diff --git a/sb_square_friction.py b/sb_square_friction.py
new file mode 100644
index 0000000..761d9b6
--- /dev/null
+++ b/sb_square_friction.py
@@ -0,0 +1,107 @@
+import os
+from math import tau, pi
+from time import sleep
+import cairo
+import ffmpeg
+from structures import Tower
+from vectors import Vector
+
+print("This program will simulate the physics of a softbody square mesh thrown across the ground.")
+sleep(1)
+print("Enter the friction coefficient.")
+
+friction_coefficient = 0
+while True:
+    try:
+        friction_coefficient = float(input("Cf [0.0-1]: "))
+        assert 0 <= friction_coefficient <= 1
+        break
+    except:
+        continue
+
+print("Solving differential equations...")
+
+structure = Tower(width=0.2, height=0.2, grid=(2, 2), mass=0.1, stiffness=50, dampening=1)
+structure.rotate(pi / 6, center=Vector(0, 0))
+structure.translate(Vector(0.2, 0.2))
+nodes, links = structure.get_components()
+
+for node in nodes:
+    node.velocity.x += 3.5
+
+camera_position = Vector(0.5, 0.5)
+camera_zoom = 0.9
+
+
+os.makedirs("output", exist_ok=True)
+for png in os.scandir("output"):
+    os.remove(png)
+
+for i in range(250):
+    for s in range(10):
+        for node in nodes:
+            node.force.set(Vector(0, -9.8 * node.mass))
+        for link in links:
+            link.nodes[0].force.add(link.get_force() * (link.nodes[0].position - link.nodes[1].position) / Vector.dist(
+                link.nodes[0].position, link.nodes[1].position))
+            link.nodes[1].force.add(link.get_force() * (link.nodes[1].position - link.nodes[0].position) / Vector.dist(
+                link.nodes[0].position, link.nodes[1].position))
+
+        for node in nodes:
+            force_normal = Vector(0, 0)
+            if node.position.x < 0:
+                force_normal.x += 100 * abs(node.position.x)
+            elif node.position.x > 1:
+                force_normal.x -= 100 * abs(1 - node.position.x)
+            if node.position.y < 0:
+                force_normal.y += 100 * abs(node.position.y)
+            elif node.position.y > 1:
+                force_normal.y -= 100 * abs(1 - node.position.y)
+            try:
+                force_friction = -1 * friction_coefficient * force_normal.len() * (node.velocity / node.velocity.len())
+            except ZeroDivisionError:
+                force_friction = Vector(0, 0)
+            node.force += force_normal + force_friction
+
+        for node in nodes:
+            node.integrate(time=0.0005)
+
+    surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 500, 500)
+    context = cairo.Context(surface)
+    context.scale(500, 500)
+    context.rectangle(0, 0, 1, 1)
+    context.set_source_rgb(1, 1, 1)
+    context.fill()
+    context.translate(0.5, 0.5)
+    context.scale(1, -1)
+    context.scale(camera_zoom, camera_zoom)
+    context.translate(-camera_position.x, -camera_position.y)
+
+    context.rectangle(0, 0, 1, 1)
+    context.set_source_rgb(0, 0, 0)
+    context.set_line_width(0.01)
+    context.stroke()
+
+    for link in links:
+        context.move_to(link.nodes[0].position.x, link.nodes[0].position.y)
+        context.line_to(link.nodes[1].position.x, link.nodes[1].position.y)
+        context.set_source_rgb(0, 0, 0)
+        context.set_line_width(0.01 * (link.length / link.get_length()))
+        context.stroke()
+
+    for node in nodes:
+        amt = node.velocity.len()
+        context.arc(node.position.x, node.position.y, 0.01, 0, tau)
+        context.set_source_rgb(1, 1 - amt / 5, 1 - amt / 5)
+        context.fill_preserve()
+        context.set_source_rgb(0, 0, 0)
+        context.set_line_width(0.005)
+        context.stroke()
+
+    surface.write_to_png(f"output/{i:06d}.png")
+
+ffmpeg.input("output/%06d.png", pattern_type="sequence", framerate=60).output("output.mp4").run(overwrite_output=True)
+for png in os.scandir("output"):
+    os.remove(png)
+os.rmdir("output")
+os.startfile("output.mp4")
\ No newline at end of file
diff --git a/sb_square_pivot.py b/sb_square_pivot.py
new file mode 100644
index 0000000..da9d520
--- /dev/null
+++ b/sb_square_pivot.py
@@ -0,0 +1,116 @@
+import os
+from math import tau, pi
+from time import sleep
+import cairo
+import ffmpeg
+from structures import Tower
+from vectors import Vector
+
+print("This program will simulate the physics of a softbody square mesh with one fixated node.")
+sleep(1)
+
+print("Enter the number of lateral grid elements in the mesh.")
+grid_x = 1
+while True:
+    try:
+        grid_x = int(input("[1-5]: "))
+        assert 1 <= grid_x <= 5
+        break
+    except:
+        continue
+
+print("Enter the number of medial grid elements in the mesh.")
+grid_y = 1
+while True:
+    try:
+        grid_y = int(input("[1-5]: "))
+        assert 1 <= grid_y <= 5
+        break
+    except:
+        continue
+
+print("Solving differential equations...")
+
+structure = Tower(width=0.1 * grid_x, height=0.1 * grid_y, grid=(grid_x, grid_y), mass=0.1, stiffness=10, dampening=0.1)
+structure.rotate(pi / 6, center=Vector(0, 0))
+structure.translate(Vector(0.5, 0.5))
+nodes, links = structure.get_components()
+
+camera_position = Vector(0.5, 0.5)
+camera_zoom = 0.9
+
+
+os.makedirs("output", exist_ok=True)
+for png in os.scandir("output"):
+    os.remove(png)
+
+for i in range(250):
+    for s in range(10):
+        for node in nodes:
+            node.force.set(Vector(0, -9.8 * node.mass))
+        for link in links:
+            link.nodes[0].force.add(link.get_force() * (link.nodes[0].position - link.nodes[1].position) / Vector.dist(
+                link.nodes[0].position, link.nodes[1].position))
+            link.nodes[1].force.add(link.get_force() * (link.nodes[1].position - link.nodes[0].position) / Vector.dist(
+                link.nodes[0].position, link.nodes[1].position))
+
+        for node in nodes:
+            force_normal = Vector(0, 0)
+            if node.position.x < 0:
+                force_normal.x += 100 * abs(node.position.x)
+            elif node.position.x > 1:
+                force_normal.x -= 100 * abs(1 - node.position.x)
+            if node.position.y < 0:
+                force_normal.y += 100 * abs(node.position.y)
+            elif node.position.y > 1:
+                force_normal.y -= 100 * abs(1 - node.position.y)
+            try:
+                force_friction = -0.25 * force_normal.len() * (node.velocity / node.velocity.len())
+            except ZeroDivisionError:
+                force_friction = Vector(0, 0)
+            node.force += force_normal + force_friction
+
+        for node in nodes:
+            structure.nodes_tower[0][-1].force.set(Vector(0, 0))
+        for node in nodes:
+            node.integrate(time=0.0005)
+
+    surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 500, 500)
+    context = cairo.Context(surface)
+    context.scale(500, 500)
+    context.rectangle(0, 0, 1, 1)
+    context.set_source_rgb(1, 1, 1)
+    context.fill()
+    context.translate(0.5, 0.5)
+    context.scale(1, -1)
+    context.scale(camera_zoom, camera_zoom)
+    context.translate(-camera_position.x, -camera_position.y)
+
+    context.rectangle(0, 0, 1, 1)
+    context.set_source_rgb(0, 0, 0)
+    context.set_line_width(0.01)
+    context.stroke()
+
+    for link in links:
+        context.move_to(link.nodes[0].position.x, link.nodes[0].position.y)
+        context.line_to(link.nodes[1].position.x, link.nodes[1].position.y)
+        context.set_source_rgb(0, 0, 0)
+        context.set_line_width(0.01 * (link.length / link.get_length()))
+        context.stroke()
+
+    for node in nodes:
+        amt = node.velocity.len()
+        context.arc(node.position.x, node.position.y, 0.01, 0, tau)
+        context.set_source_rgb(1, 1 - amt / 5, 1 - amt / 5)
+        context.fill_preserve()
+        context.set_source_rgb(0, 0, 0)
+        context.set_line_width(0.005)
+        context.stroke()
+
+    surface.write_to_png(f"output/{i:06d}.png")
+
+ffmpeg.input("output/%06d.png", pattern_type="sequence", framerate=60).output("output.mp4").run(overwrite_output=True)
+for png in os.scandir("output"):
+    os.remove(png)
+os.rmdir("output")
+os.startfile("output.mp4")
\ No newline at end of file

commit 69c6c7a5cb97d141f25e00b0fbdac0685c423004
Author: Daxonus <elias@dobrin.net>
Date:   Mon May 30 18:47:38 2022 -0700

    added square pin example

diff --git a/output.mp4 b/output.mp4
index fce40f4..70a10b2 100644
Binary files a/output.mp4 and b/output.mp4 differ
diff --git a/sb_square_pinned.py b/sb_square_pinned.py
new file mode 100644
index 0000000..5c480be
--- /dev/null
+++ b/sb_square_pinned.py
@@ -0,0 +1,116 @@
+import os
+from math import tau
+from time import sleep
+import cairo
+import ffmpeg
+from structures import Tower
+from vectors import Vector
+
+print("This program will simulate the physics of a softbody square mesh with two fixated nodes.")
+sleep(1)
+
+print("Enter the number of lateral grid elements in the mesh.")
+grid_x = 1
+while True:
+    try:
+        grid_x = int(input("[1-7]: "))
+        assert 1 <= grid_x <= 7
+        break
+    except:
+        continue
+
+print("Enter the number of medial grid elements in the mesh.")
+grid_y = 1
+while True:
+    try:
+        grid_y = int(input("[1-7]: "))
+        assert 1 <= grid_y <= 7
+        break
+    except:
+        continue
+
+print("Solving differential equations...")
+
+structure = Tower(width=0.1 * grid_x, height=0.1 * grid_y, grid=(grid_x, grid_y), mass=0.1, stiffness=10, dampening=0.1)
+structure.translate(Vector(0.5, 0.5))
+nodes, links = structure.get_components()
+
+camera_position = Vector(0.5, 0.5)
+camera_zoom = 0.9
+
+
+os.makedirs("output", exist_ok=True)
+for png in os.scandir("output"):
+    os.remove(png)
+
+for i in range(250):
+    for s in range(10):
+        for node in nodes:
+            node.force.set(Vector(0, -9.8 * node.mass))
+        for link in links:
+            link.nodes[0].force.add(link.get_force() * (link.nodes[0].position - link.nodes[1].position) / Vector.dist(
+                link.nodes[0].position, link.nodes[1].position))
+            link.nodes[1].force.add(link.get_force() * (link.nodes[1].position - link.nodes[0].position) / Vector.dist(
+                link.nodes[0].position, link.nodes[1].position))
+
+        for node in nodes:
+            force_normal = Vector(0, 0)
+            if node.position.x < 0:
+                force_normal.x += 100 * abs(node.position.x)
+            elif node.position.x > 1:
+                force_normal.x -= 100 * abs(1 - node.position.x)
+            if node.position.y < 0:
+                force_normal.y += 100 * abs(node.position.y)
+            elif node.position.y > 1:
+                force_normal.y -= 100 * abs(1 - node.position.y)
+            try:
+                force_friction = -0.25 * force_normal.len() * (node.velocity / node.velocity.len())
+            except ZeroDivisionError:
+                force_friction = Vector(0, 0)
+            node.force += force_normal + force_friction
+
+        for node in nodes:
+            structure.nodes_tower[0][-1].force.set(Vector(0, 0))
+            structure.nodes_tower[-1][-1].force.set(Vector(0, 0))
+        for node in nodes:
+            node.integrate(time=0.0005)
+
+    surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 500, 500)
+    context = cairo.Context(surface)
+    context.scale(500, 500)
+    context.rectangle(0, 0, 1, 1)
+    context.set_source_rgb(1, 1, 1)
+    context.fill()
+    context.translate(0.5, 0.5)
+    context.scale(1, -1)
+    context.scale(camera_zoom, camera_zoom)
+    context.translate(-camera_position.x, -camera_position.y)
+
+    context.rectangle(0, 0, 1, 1)
+    context.set_source_rgb(0, 0, 0)
+    context.set_line_width(0.01)
+    context.stroke()
+
+    for link in links:
+        context.move_to(link.nodes[0].position.x, link.nodes[0].position.y)
+        context.line_to(link.nodes[1].position.x, link.nodes[1].position.y)
+        context.set_source_rgb(0, 0, 0)
+        context.set_line_width(0.01 * (link.length / link.get_length()))
+        context.stroke()
+
+    for node in nodes:
+        amt = node.velocity.len()
+        context.arc(node.position.x, node.position.y, 0.01, 0, tau)
+        context.set_source_rgb(1, 1 - amt / 5, 1 - amt / 5)
+        context.fill_preserve()
+        context.set_source_rgb(0, 0, 0)
+        context.set_line_width(0.005)
+        context.stroke()
+
+    surface.write_to_png(f"output/{i:06d}.png")
+
+ffmpeg.input("output/%06d.png", pattern_type="sequence", framerate=60).output("output.mp4").run(overwrite_output=True)
+for png in os.scandir("output"):
+    os.remove(png)
+os.rmdir("output")
+os.startfile("output.mp4")
\ No newline at end of file

commit 0274e0013b2b31370c48fac7d47dc7953ebc9851
Author: Daxonus <elias@dobrin.net>
Date:   Mon May 30 18:36:04 2022 -0700

    warn messages for dependencies

diff --git a/ideas.txt b/ideas.txt
deleted file mode 100644
index 146cfb7..0000000
--- a/ideas.txt
+++ /dev/null
@@ -1,7 +0,0 @@
-nice rendering of softbody structures
-making lots of variations of spring meshes
-friction
-collisions
-collisions that modify the resting spring lengths
-creatures that contract and expand their muscles to move
-various ways to visualize simulation with matplotlib
\ No newline at end of file
diff --git a/softbodies.py b/softbodies.py
index d6e6041..ce74f33 100644
--- a/softbodies.py
+++ b/softbodies.py
@@ -1,5 +1,4 @@
 from __future__ import annotations
-from typing import Callable
 from vectors import Vector
 
 
@@ -78,4 +77,10 @@ class Link:
 
     def integrate(self, time: float) -> None:
         self.nodes[0].integrate(time)
-        self.nodes[1].integrate(time)
\ No newline at end of file
+        self.nodes[1].integrate(time)
+
+
+if __name__ == "__main__":
+    from time import sleep
+    print("Do not run me! This is just a dependency program")
+    sleep(5)
\ No newline at end of file
diff --git a/structures.py b/structures.py
index 2b04dd3..9b95abf 100644
--- a/structures.py
+++ b/structures.py
@@ -127,3 +127,9 @@ class Wheel(Structure):
 
         nodes = [node for buffer in nodes_mesh for node in buffer]
         super().__init__(nodes, links)
+
+
+if __name__ == "__main__":
+    from time import sleep
+    print("Do not run me! This is just a dependency program")
+    sleep(5)
\ No newline at end of file
diff --git a/vectors.py b/vectors.py
index 2ac6e9d..edfdee0 100644
--- a/vectors.py
+++ b/vectors.py
@@ -124,3 +124,9 @@ class Vector:
     def copy(self) -> Vector:
         """Copy the vector instance."""
         return Vector(self.x, self.y)
+
+
+if __name__ == "__main__":
+    from time import sleep
+    print("Do not run me! This is just a dependency program")
+    sleep(5)
\ No newline at end of file

commit eaf3250aab755453b5e344607cfa743eb3a386be
Author: Daxonus <elias@dobrin.net>
Date:   Mon May 30 18:33:11 2022 -0700

    added triangle example file

diff --git a/output.mp4 b/output.mp4
index b697eb4..fce40f4 100644
Binary files a/output.mp4 and b/output.mp4 differ
diff --git a/sb_square.py b/sb_square_launch.py
similarity index 94%
rename from sb_square.py
rename to sb_square_launch.py
index 8d307c5..a787e37 100644
--- a/sb_square.py
+++ b/sb_square_launch.py
@@ -8,10 +8,10 @@ from vectors import Vector
 
 print("This program will simulate the physics of a softbody square mesh.")
 sleep(1)
-print("The object is dropped from a height of 0.5 meters and is then launched diagonally.")
+print("The object is dropped from a height of 0.5 meters and is then launched diagonally.\n")
 sleep(1)
 
-print("Enter the number of horizontal grid elements in the mesh.")
+print("Enter the number of lateral grid elements in the mesh.")
 grid_x = 1
 while True:
     try:
@@ -21,7 +21,7 @@ while True:
     except:
         continue
 
-print("Enter the number of vertical grid elements in the mesh.")
+print("Enter the number of medial grid elements in the mesh.")
 grid_y = 1
 while True:
     try:
@@ -31,7 +31,7 @@ while True:
     except:
         continue
 
-print("Integrating Hooke's law twice...")
+print("Solving differential equations...")
 
 structure = Tower(width=0.1 * grid_x, height=0.1 * grid_y, grid=(grid_x, grid_y), mass=0.1, stiffness=50, dampening=1)
 structure.translate(Vector(0.5, 0.5))
diff --git a/sb_triangle_launch.py b/sb_triangle_launch.py
new file mode 100644
index 0000000..0eb8ff9
--- /dev/null
+++ b/sb_triangle_launch.py
@@ -0,0 +1,111 @@
+import os
+from math import pi, tau
+from time import sleep
+import cairo
+import ffmpeg
+from structures import Pyramid
+from vectors import Vector
+
+print("This program will simulate the physics of a softbody triangle mesh.")
+sleep(1)
+print("The object is dropped from a height of 0.5 meters and is then launched diagonally.\n")
+sleep(1)
+
+print("Enter the number of edge grid elements in the mesh.")
+grid = 1
+while True:
+    try:
+        grid = int(input("[1-7]: "))
+        assert 1 <= grid <= 7
+        break
+    except:
+        continue
+
+print("Solving differential equations...")
+
+structure = Pyramid(width=0.1 * grid, grid=grid, mass=0.1, stiffness=100, dampening=1)
+structure.translate(Vector(0.5, 0.5))
+structure.rotate(pi / 12, center=Vector(0.5, 0.5))
+nodes, links = structure.get_components()
+
+camera_position = Vector(0.5, 0.5)
+camera_zoom = 0.9
+
+
+os.makedirs("output", exist_ok=True)
+for png in os.scandir("output"):
+    os.remove(png)
+
+for i in range(250):
+    if i == 100:
+        for node in nodes:
+            node.velocity.x += 3
+            node.velocity.y += 5
+
+    for s in range(10):
+        for node in nodes:
+            node.force.set(Vector(0, -9.8 * node.mass))
+        for link in links:
+            link.nodes[0].force.add(link.get_force() * (link.nodes[0].position - link.nodes[1].position) / Vector.dist(
+                link.nodes[0].position, link.nodes[1].position))
+            link.nodes[1].force.add(link.get_force() * (link.nodes[1].position - link.nodes[0].position) / Vector.dist(
+                link.nodes[0].position, link.nodes[1].position))
+
+        for node in nodes:
+            force_normal = Vector(0, 0)
+            if node.position.x < 0:
+                force_normal.x += 100 * abs(node.position.x)
+            elif node.position.x > 1:
+                force_normal.x -= 100 * abs(1 - node.position.x)
+            if node.position.y < 0:
+                force_normal.y += 100 * abs(node.position.y)
+            elif node.position.y > 1:
+                force_normal.y -= 100 * abs(1 - node.position.y)
+            try:
+                force_friction = -0.25 * force_normal.len() * (node.velocity / node.velocity.len())
+            except ZeroDivisionError:
+                force_friction = Vector(0, 0)
+            node.force += force_normal + force_friction
+
+        for node in nodes:
+            node.integrate(time=0.0005)
+
+    surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 500, 500)
+    context = cairo.Context(surface)
+    context.scale(500, 500)
+    context.rectangle(0, 0, 1, 1)
+    context.set_source_rgb(1, 1, 1)
+    context.fill()
+    context.translate(0.5, 0.5)
+    context.scale(1, -1)
+    context.scale(camera_zoom, camera_zoom)
+    context.translate(-camera_position.x, -camera_position.y)
+
+    context.rectangle(0, 0, 1, 1)
+    context.set_source_rgb(0, 0, 0)
+    context.set_line_width(0.01)
+    context.stroke()
+
+    for link in links:
+        context.move_to(link.nodes[0].position.x, link.nodes[0].position.y)
+        context.line_to(link.nodes[1].position.x, link.nodes[1].position.y)
+        context.set_source_rgb(0, 0, 0)
+        context.set_line_width(0.01 * (link.length / link.get_length()))
+        context.stroke()
+
+    for node in nodes:
+        amt = node.velocity.len()
+        context.arc(node.position.x, node.position.y, 0.01, 0, tau)
+        context.set_source_rgb(1, 1 - amt / 5, 1 - amt / 5)
+        context.fill_preserve()
+        context.set_source_rgb(0, 0, 0)
+        context.set_line_width(0.005)
+        context.stroke()
+
+    surface.write_to_png(f"output/{i:06d}.png")
+
+ffmpeg.input("output/%06d.png", pattern_type="sequence", framerate=60).output("output.mp4").run(overwrite_output=True)
+for png in os.scandir("output"):
+    os.remove(png)
+os.rmdir("output")
+os.startfile("output.mp4")
\ No newline at end of file

commit d4b8d2401d98ce0bea1aec277ab9b7f214d96969
Author: Daxonus <elias@dobrin.net>
Date:   Mon May 30 18:15:51 2022 -0700

    further improved first example program

diff --git a/.gitignore b/.gitignore
index 82195aa..570b976 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,2 +1,3 @@
+output.mp4
 venv
 .idea
\ No newline at end of file
diff --git a/output.mp4 b/output.mp4
index 90a4320..b697eb4 100644
Binary files a/output.mp4 and b/output.mp4 differ
diff --git a/sb_square.py b/sb_square.py
index 4393562..8d307c5 100644
--- a/sb_square.py
+++ b/sb_square.py
@@ -8,7 +8,7 @@ from vectors import Vector
 
 print("This program will simulate the physics of a softbody square mesh.")
 sleep(1)
-print("The object is dropped from a height of 0.5 meters and is untouched except by the walls.")
+print("The object is dropped from a height of 0.5 meters and is then launched diagonally.")
 sleep(1)
 
 print("Enter the number of horizontal grid elements in the mesh.")
@@ -31,7 +31,7 @@ while True:
     except:
         continue
 
-print("Calculating...")
+print("Integrating Hooke's law twice...")
 
 structure = Tower(width=0.1 * grid_x, height=0.1 * grid_y, grid=(grid_x, grid_y), mass=0.1, stiffness=50, dampening=1)
 structure.translate(Vector(0.5, 0.5))
@@ -42,7 +42,9 @@ camera_position = Vector(0.5, 0.5)
 camera_zoom = 0.9
 
 
-os.mkdir("output")
+os.makedirs("output", exist_ok=True)
+for png in os.scandir("output"):
+    os.remove(png)
 
 for i in range(250):
     if i == 100:

commit b22dff5a26f9ad889bee7547ca6524528f6722f8
Author: Daxonus <elias@dobrin.net>
Date:   Mon May 30 18:02:10 2022 -0700

    made example program

diff --git a/output.mp4 b/output.mp4
new file mode 100644
index 0000000..90a4320
Binary files /dev/null and b/output.mp4 differ
diff --git a/main.py b/sb_square.py
similarity index 69%
rename from main.py
rename to sb_square.py
index ea0506c..4393562 100644
--- a/main.py
+++ b/sb_square.py
@@ -1,27 +1,43 @@
 import os
 from math import pi, tau
-from random import random
+from time import sleep
 import cairo
 import ffmpeg
-from structures import Structure, Tower, Pyramid, Wheel
+from structures import Tower
 from vectors import Vector
 
-
-structure = Tower(width=0.3, height=0.5, grid=(3, 5), mass=0.1, stiffness=50, dampening=1)
-# structure = Pyramid(width=0.5, grid=5, mass=0.1, stiffness=50, dampening=1)
-# structure = Wheel(radius=0.25, rings=5, slices=5, mass=0.1, stiffness=100, dampening=1)
+print("This program will simulate the physics of a softbody square mesh.")
+sleep(1)
+print("The object is dropped from a height of 0.5 meters and is untouched except by the walls.")
+sleep(1)
+
+print("Enter the number of horizontal grid elements in the mesh.")
+grid_x = 1
+while True:
+    try:
+        grid_x = int(input("[1-7]: "))
+        assert 1 <= grid_x <= 7
+        break
+    except:
+        continue
+
+print("Enter the number of vertical grid elements in the mesh.")
+grid_y = 1
+while True:
+    try:
+        grid_y = int(input("[1-7]: "))
+        assert 1 <= grid_y <= 7
+        break
+    except:
+        continue
+
+print("Calculating...")
+
+structure = Tower(width=0.1 * grid_x, height=0.1 * grid_y, grid=(grid_x, grid_y), mass=0.1, stiffness=50, dampening=1)
 structure.translate(Vector(0.5, 0.5))
-structure.rotate(pi / 6, center=Vector(0.5, 0.5))
-
-# softbody = pyramid(position=Vector(0.5, 0.6), width=0.5, grid=6, mass=0.1, stiffness=100, dampening=1)
-# softbody = wheel(position=Vector(0.5, 0.5), radius=0.25, rings=3, slices=10, mass=0.1, stiffness=200, dampening=1)
+structure.rotate(pi / 12, center=Vector(0.5, 0.5))
 nodes, links = structure.get_components()
 
-ln = [link.length for link in links]
-for node in nodes:
-    node.velocity.x += 4
-    node.velocity.y += 3
-
 camera_position = Vector(0.5, 0.5)
 camera_zoom = 0.9
 
@@ -29,6 +45,11 @@ camera_zoom = 0.9
 os.mkdir("output")
 
 for i in range(250):
+    if i == 100:
+        for node in nodes:
+            node.velocity.x += 3
+            node.velocity.y += 5
+
     for s in range(10):
         for node in nodes:
             node.force.set(Vector(0, -9.8 * node.mass))
@@ -48,16 +69,17 @@ for i in range(250):
                 force_normal.y += 100 * abs(node.position.y)
             elif node.position.y > 1:
                 force_normal.y -= 100 * abs(1 - node.position.y)
-            force_friction = -0.25 * force_normal.len() * (node.velocity / node.velocity.len())
+            try:
+                force_friction = -0.25 * force_normal.len() * (node.velocity / node.velocity.len())
+            except ZeroDivisionError:
+                force_friction = Vector(0, 0)
             node.force += force_normal + force_friction
 
         for node in nodes:
             node.integrate(time=0.0005)
 
-
     surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 500, 500)
     context = cairo.Context(surface)
-
     context.scale(500, 500)
     context.rectangle(0, 0, 1, 1)
     context.set_source_rgb(1, 1, 1)
@@ -94,3 +116,4 @@ ffmpeg.input("output/%06d.png", pattern_type="sequence", framerate=60).output("o
 for png in os.scandir("output"):
     os.remove(png)
 os.rmdir("output")
+os.startfile("output.mp4")
\ No newline at end of file

commit 22bc703ef12bc4b1dba09adebc21286063f5e9f4
Author: Daxonus <elias@dobrin.net>
Date:   Thu May 19 11:43:21 2022 -0700

    realized that rendering path might be in different working directory

diff --git a/.gitignore b/.gitignore
index 570b976..82195aa 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,3 +1,2 @@
-output.mp4
 venv
 .idea
\ No newline at end of file

commit 692a09843bf06d96a0bd2b3c25610669f2c3d7d3
Author: Daxonus <elias@dobrin.net>
Date:   Mon May 16 09:25:16 2022 -0700

    fixed rendering pipeline

diff --git a/.gitignore b/.gitignore
index 1927850..570b976 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,4 +1,3 @@
-venv/
-output/
 output.mp4
+venv
 .idea
\ No newline at end of file
diff --git a/main.py b/main.py
index bfc33b5..ea0506c 100644
--- a/main.py
+++ b/main.py
@@ -26,6 +26,8 @@ camera_position = Vector(0.5, 0.5)
 camera_zoom = 0.9
 
 
+os.mkdir("output")
+
 for i in range(250):
     for s in range(10):
         for node in nodes:
@@ -88,7 +90,7 @@ for i in range(250):
 
     surface.write_to_png(f"output/{i:06d}.png")
 
-
 ffmpeg.input("output/%06d.png", pattern_type="sequence", framerate=60).output("output.mp4").run(overwrite_output=True)
 for png in os.scandir("output"):
     os.remove(png)
+os.rmdir("output")

commit 5a2a7629ae673047e9a04a34bf2594178d5be3f5
Author: Daxonus <elias@dobrin.net>
Date:   Mon May 9 20:44:12 2022 -0700

    added normal force and friction force

diff --git a/main.py b/main.py
index 6ef58bd..bfc33b5 100644
--- a/main.py
+++ b/main.py
@@ -7,7 +7,9 @@ from structures import Structure, Tower, Pyramid, Wheel
 from vectors import Vector
 
 
-structure = Tower(width=0.1, height=0.5, grid=(1, 5), mass=0.1, stiffness=50, dampening=1)
+structure = Tower(width=0.3, height=0.5, grid=(3, 5), mass=0.1, stiffness=50, dampening=1)
+# structure = Pyramid(width=0.5, grid=5, mass=0.1, stiffness=50, dampening=1)
+# structure = Wheel(radius=0.25, rings=5, slices=5, mass=0.1, stiffness=100, dampening=1)
 structure.translate(Vector(0.5, 0.5))
 structure.rotate(pi / 6, center=Vector(0.5, 0.5))
 
@@ -24,7 +26,7 @@ camera_position = Vector(0.5, 0.5)
 camera_zoom = 0.9
 
 
-for i in range(500):
+for i in range(250):
     for s in range(10):
         for node in nodes:
             node.force.set(Vector(0, -9.8 * node.mass))
@@ -35,17 +37,17 @@ for i in range(500):
                 link.nodes[0].position, link.nodes[1].position))
 
         for node in nodes:
+            force_normal = Vector(0, 0)
             if node.position.x < 0:
-                node.force.x += 500 * abs(node.position.x)
-            if node.position.x > 1:
-                node.force.x -= 500 * abs(1 - node.position.x)
+                force_normal.x += 100 * abs(node.position.x)
+            elif node.position.x > 1:
+                force_normal.x -= 100 * abs(1 - node.position.x)
             if node.position.y < 0:
-                node.force.y += 500 * abs(node.position.y)
-            if node.position.y > 1:
-                node.force.y -= 500 * abs(1 - node.position.y)
-
-        # nodes[0].force.set(Vector(0, 0))
-        # nodes[0].velocity.set(Vector(0, 0))
+                force_normal.y += 100 * abs(node.position.y)
+            elif node.position.y > 1:
+                force_normal.y -= 100 * abs(1 - node.position.y)
+            force_friction = -0.25 * force_normal.len() * (node.velocity / node.velocity.len())
+            node.force += force_normal + force_friction
 
         for node in nodes:
             node.integrate(time=0.0005)

commit cd4f203b18a7091fde55853eca61f6f28fd142c3
Author: Daxonus <elias@dobrin.net>
Date:   Sun May 8 11:37:40 2022 -0700

    Update .gitignore

diff --git a/.gitignore b/.gitignore
index e841d78..1927850 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,3 +1,4 @@
 venv/
 output/
-output.mp4
\ No newline at end of file
+output.mp4
+.idea
\ No newline at end of file

commit 39b2d73b788ccc95738dd8e23198cba96435ee64
Author: Daxonus <elias@dobrin.net>
Date:   Sun May 8 11:37:31 2022 -0700

    trash

diff --git a/.idea/.gitignore b/.idea/.gitignore
deleted file mode 100644
index 13566b8..0000000
--- a/.idea/.gitignore
+++ /dev/null
@@ -1,8 +0,0 @@
-# Default ignored files
-/shelf/
-/workspace.xml
-# Editor-based HTTP Client requests
-/httpRequests/
-# Datasource local storage ignored files
-/dataSources/
-/dataSources.local.xml
diff --git a/.idea/inspectionProfiles/profiles_settings.xml b/.idea/inspectionProfiles/profiles_settings.xml
deleted file mode 100644
index 105ce2d..0000000
--- a/.idea/inspectionProfiles/profiles_settings.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<component name="InspectionProjectProfileManager">
-  <settings>
-    <option name="USE_PROJECT_PROFILE" value="false" />
-    <version value="1.0" />
-  </settings>
-</component>
\ No newline at end of file
diff --git a/.idea/misc.xml b/.idea/misc.xml
deleted file mode 100644
index dc9ea49..0000000
--- a/.idea/misc.xml
+++ /dev/null
@@ -1,4 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.10" project-jdk-type="Python SDK" />
-</project>
\ No newline at end of file
diff --git a/.idea/modules.xml b/.idea/modules.xml
deleted file mode 100644
index e88184b..0000000
--- a/.idea/modules.xml
+++ /dev/null
@@ -1,8 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="ProjectModuleManager">
-    <modules>
-      <module fileurl="file://$PROJECT_DIR$/.idea/softbodies.iml" filepath="$PROJECT_DIR$/.idea/softbodies.iml" />
-    </modules>
-  </component>
-</project>
\ No newline at end of file
diff --git a/.idea/softbodies.iml b/.idea/softbodies.iml
deleted file mode 100644
index d0876a7..0000000
--- a/.idea/softbodies.iml
+++ /dev/null
@@ -1,8 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<module type="PYTHON_MODULE" version="4">
-  <component name="NewModuleRootManager">
-    <content url="file://$MODULE_DIR$" />
-    <orderEntry type="inheritedJdk" />
-    <orderEntry type="sourceFolder" forTests="false" />
-  </component>
-</module>
\ No newline at end of file
diff --git a/.idea/vcs.xml b/.idea/vcs.xml
deleted file mode 100644
index 94a25f7..0000000
--- a/.idea/vcs.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="VcsDirectoryMappings">
-    <mapping directory="$PROJECT_DIR$" vcs="Git" />
-  </component>
-</project>
\ No newline at end of file
diff --git a/__pycache__/points.cpython-310.pyc b/__pycache__/points.cpython-310.pyc
deleted file mode 100644
index 08d760a..0000000
Binary files a/__pycache__/points.cpython-310.pyc and /dev/null differ
diff --git a/__pycache__/softbodies.cpython-310.pyc b/__pycache__/softbodies.cpython-310.pyc
deleted file mode 100644
index 0ff535f..0000000
Binary files a/__pycache__/softbodies.cpython-310.pyc and /dev/null differ
diff --git a/__pycache__/structures.cpython-310.pyc b/__pycache__/structures.cpython-310.pyc
deleted file mode 100644
index ca456a1..0000000
Binary files a/__pycache__/structures.cpython-310.pyc and /dev/null differ
diff --git a/__pycache__/test.cpython-310.pyc b/__pycache__/test.cpython-310.pyc
deleted file mode 100644
index 7e91431..0000000
Binary files a/__pycache__/test.cpython-310.pyc and /dev/null differ
diff --git a/__pycache__/vectors.cpython-310.pyc b/__pycache__/vectors.cpython-310.pyc
deleted file mode 100644
index af552bb..0000000
Binary files a/__pycache__/vectors.cpython-310.pyc and /dev/null differ

commit 8a1390ec61b9c4e0292cdb1a29236cbcfccf9e8c
Author: Daxonus <elias@dobrin.net>
Date:   Wed Apr 27 12:26:33 2022 -0700

    small velocity visualization

diff --git a/main.py b/main.py
index b70a82c..6ef58bd 100644
--- a/main.py
+++ b/main.py
@@ -10,13 +10,14 @@ from vectors import Vector
 structure = Tower(width=0.1, height=0.5, grid=(1, 5), mass=0.1, stiffness=50, dampening=1)
 structure.translate(Vector(0.5, 0.5))
 structure.rotate(pi / 6, center=Vector(0.5, 0.5))
+
 # softbody = pyramid(position=Vector(0.5, 0.6), width=0.5, grid=6, mass=0.1, stiffness=100, dampening=1)
 # softbody = wheel(position=Vector(0.5, 0.5), radius=0.25, rings=3, slices=10, mass=0.1, stiffness=200, dampening=1)
 nodes, links = structure.get_components()
 
 ln = [link.length for link in links]
 for node in nodes:
-    node.velocity.x += 2
+    node.velocity.x += 4
     node.velocity.y += 3
 
 camera_position = Vector(0.5, 0.5)
@@ -43,8 +44,8 @@ for i in range(500):
             if node.position.y > 1:
                 node.force.y -= 500 * abs(1 - node.position.y)
 
-        nodes[0].force.set(Vector(0, 0))
-        nodes[0].velocity.set(Vector(0, 0))
+        # nodes[0].force.set(Vector(0, 0))
+        # nodes[0].velocity.set(Vector(0, 0))
 
         for node in nodes:
             node.integrate(time=0.0005)
@@ -75,8 +76,9 @@ for i in range(500):
         context.stroke()
 
     for node in nodes:
+        amt = node.velocity.len()
         context.arc(node.position.x, node.position.y, 0.01, 0, tau)
-        context.set_source_rgb(1, 1, 1)
+        context.set_source_rgb(1, 1 - amt / 5, 1 - amt / 5)
         context.fill_preserve()
         context.set_source_rgb(0, 0, 0)
         context.set_line_width(0.005)
diff --git a/softbodies.py b/softbodies.py
index 081005a..d6e6041 100644
--- a/softbodies.py
+++ b/softbodies.py
@@ -39,18 +39,18 @@ class Node:
 class Link:
     """A massless Hookean spring that features a pair of spring stiffness and dampening forces."""
     nodes: tuple[Node, Node]
+    length: float
     stiffness: float
     dampening: float
-    length: float
 
     def __init__(self, nodes: tuple[Node, Node], stiffness: float, dampening: float, length: float = None) -> None:
         self.nodes = nodes
-        self.stiffness = stiffness
-        self.dampening = dampening
         if length is None:
             self.length = Vector.dist(nodes[0].position, nodes[1].position)
         else:
             self.length = length
+        self.stiffness = stiffness
+        self.dampening = dampening
 
     def get_length(self) -> float:
         """Get the momentary length of the link."""
diff --git a/structures.py b/structures.py
index a846331..2b04dd3 100644
--- a/structures.py
+++ b/structures.py
@@ -49,51 +49,57 @@ class Structure(Softbody):
 
 
 class Tower(Structure):
+    nodes_tower: list[list[Node]]
+
     def __init__(self, width: float, height: float, grid: tuple[int, int], mass: float, stiffness: float, dampening: float) -> None:
-        nodes_mesh = []
+        nodes_tower = []
         for x in range(grid[0] + 1):
-            nodes_mesh.append([])
+            nodes_tower.append([])
             for y in range(grid[1] + 1):
                 node_mass = mass / ((grid[0] + 1) * (grid[1] + 1))
                 node_position = Vector(width * (x / grid[0] - 0.5),
                                        height * (y / grid[1] - 0.5))
                 node = Node(node_mass, node_position)
-                nodes_mesh[x].append(node)
+                nodes_tower[x].append(node)
         links = []
         for x in range(grid[0]):
             for y in range(grid[1] + 1):
-                links.append(Link((nodes_mesh[x][y], nodes_mesh[x + 1][y]), stiffness, dampening))
+                links.append(Link((nodes_tower[x][y], nodes_tower[x + 1][y]), stiffness, dampening))
         for x in range(grid[0] + 1):
             for y in range(grid[1]):
-                links.append(Link((nodes_mesh[x][y], nodes_mesh[x][y + 1]), stiffness, dampening))
+                links.append(Link((nodes_tower[x][y], nodes_tower[x][y + 1]), stiffness, dampening))
         for x in range(grid[0]):
             for y in range(grid[1]):
-                links.append(Link((nodes_mesh[x][y], nodes_mesh[x + 1][y + 1]), stiffness, dampening))
-                links.append(Link((nodes_mesh[x + 1][y], nodes_mesh[x][y + 1]), stiffness, dampening))
-        nodes = [node for buffer in nodes_mesh for node in buffer]
+                links.append(Link((nodes_tower[x][y], nodes_tower[x + 1][y + 1]), stiffness, dampening))
+                links.append(Link((nodes_tower[x + 1][y], nodes_tower[x][y + 1]), stiffness, dampening))
+        nodes = [node for buffer in nodes_tower for node in buffer]
         super().__init__(nodes, links)
+        self.nodes_tower = nodes_tower
 
 
 class Pyramid(Structure):
+    nodes_pyramid: list[list[Node]]
+
     def __init__(self, width: float, grid: int, mass: float, stiffness: float, dampening: float) -> None:
         height = (sqrt(3) / 2) * width
-        nodes_mesh = []
+        nodes_pyramid = []
         for y in range(grid + 1):
-            nodes_mesh.append([])
+            nodes_pyramid.append([])
             for x in range(grid + 1 - y):
                 node_mass = mass / ((grid + 1) * (grid + 2) / 2)
                 node_position = Vector(width * ((x + 0.5 * y) / grid - 0.5),
                                        height * (y / grid - 0.5))
                 node = Node(node_mass, node_position)
-                nodes_mesh[y].append(node)
+                nodes_pyramid[y].append(node)
         links = []
         for y in range(grid):
             for x in range(grid - y):
-                links.append(Link((nodes_mesh[y][x], nodes_mesh[y + 1][x]), stiffness, dampening))
-                links.append(Link((nodes_mesh[y][x], nodes_mesh[y][x + 1]), stiffness, dampening))
-                links.append(Link((nodes_mesh[y][-x - 1], nodes_mesh[y + 1][-x - 1]), stiffness, dampening))
-        nodes = [node for buffer in nodes_mesh for node in buffer]
+                links.append(Link((nodes_pyramid[y][x], nodes_pyramid[y + 1][x]), stiffness, dampening))
+                links.append(Link((nodes_pyramid[y][x], nodes_pyramid[y][x + 1]), stiffness, dampening))
+                links.append(Link((nodes_pyramid[y][-x - 1], nodes_pyramid[y + 1][-x - 1]), stiffness, dampening))
+        nodes = [node for buffer in nodes_pyramid for node in buffer]
         super().__init__(nodes, links)
+        self.nodes_pyramid = nodes_pyramid
 
 
 class Wheel(Structure):

commit cb107968917eeea6add580eee5f07463630163d8
Author: Daxonus <elias@dobrin.net>
Date:   Tue Apr 26 11:35:31 2022 -0700

    added softbody class (might be changed)

diff --git a/main.py b/main.py
index 795bcd5..b70a82c 100644
--- a/main.py
+++ b/main.py
@@ -12,8 +12,7 @@ structure.translate(Vector(0.5, 0.5))
 structure.rotate(pi / 6, center=Vector(0.5, 0.5))
 # softbody = pyramid(position=Vector(0.5, 0.6), width=0.5, grid=6, mass=0.1, stiffness=100, dampening=1)
 # softbody = wheel(position=Vector(0.5, 0.5), radius=0.25, rings=3, slices=10, mass=0.1, stiffness=200, dampening=1)
-nodes = structure.nodes
-links = structure.links
+nodes, links = structure.get_components()
 
 ln = [link.length for link in links]
 for node in nodes:
diff --git a/softbodies.py b/softbodies.py
index 77d78fd..081005a 100644
--- a/softbodies.py
+++ b/softbodies.py
@@ -3,6 +3,19 @@ from typing import Callable
 from vectors import Vector
 
 
+class Softbody:
+    nodes: list[Node]
+    links: list[Link]
+
+    def __init__(self, nodes: list[Node], links: list[Link]) -> None:
+        self.nodes = nodes
+        self.links = links
+
+    def integrate(self, time: float) -> None:
+        for node in self.nodes:
+            node.integrate(time)
+
+
 class Node:
     """A point mass particle that implements Euler integration."""
     mass: float
diff --git a/structures.py b/structures.py
index 6e873a6..a846331 100644
--- a/structures.py
+++ b/structures.py
@@ -1,16 +1,26 @@
 from __future__ import annotations
 from math import sqrt, cos, sin, atan2, tau
-from softbodies import Node, Link
+from softbodies import Softbody, Node, Link
 from vectors import Vector
 
 
-class Structure:
+class Structure(Softbody):
     nodes: list[Node]
     links: list[Link]
 
     def __init__(self, nodes: list[Node], links: list[Link]) -> None:
-        self.nodes = nodes
-        self.links = links
+        super().__init__(nodes, links)
+
+    def get_components(self) -> tuple[list[Node], list[Link]]:
+        return self.nodes, self.links
+
+    def get_total_mass(self) -> float:
+        total_mass = sum(node.mass for node in self.nodes)
+        return total_mass
+
+    def get_center_mass(self) -> Vector:
+        center_mass = sum(node.mass * node.position for node in self.nodes)
+        return center_mass
 
     def translate(self, vector: Vector) -> None:
         for node in self.nodes:

commit 0713535e3dc0c221012016e75fd6bab607b4190a
Author: Daxonus <elias@dobrin.net>
Date:   Tue Apr 26 09:27:08 2022 -0700

    spinning box?

diff --git a/main.py b/main.py
index e5b3676..795bcd5 100644
--- a/main.py
+++ b/main.py
@@ -7,8 +7,9 @@ from structures import Structure, Tower, Pyramid, Wheel
 from vectors import Vector
 
 
-structure = Tower(width=0.3, height=0.3, grid=(3, 3), mass=0.1, stiffness=50, dampening=1)
-structure.move(Vector(0.5, 0.5))
+structure = Tower(width=0.1, height=0.5, grid=(1, 5), mass=0.1, stiffness=50, dampening=1)
+structure.translate(Vector(0.5, 0.5))
+structure.rotate(pi / 6, center=Vector(0.5, 0.5))
 # softbody = pyramid(position=Vector(0.5, 0.6), width=0.5, grid=6, mass=0.1, stiffness=100, dampening=1)
 # softbody = wheel(position=Vector(0.5, 0.5), radius=0.25, rings=3, slices=10, mass=0.1, stiffness=200, dampening=1)
 nodes = structure.nodes
@@ -16,16 +17,14 @@ links = structure.links
 
 ln = [link.length for link in links]
 for node in nodes:
-    node.position.y -= 0.35
+    node.velocity.x += 2
+    node.velocity.y += 3
 
 camera_position = Vector(0.5, 0.5)
 camera_zoom = 0.9
 
 
-for i in range(100):
-    if i % 30 == 0:
-        for l, link in enumerate(links):
-            link.length = ln[l] * (1 + 0.2 * (random() - 0.5))
+for i in range(500):
     for s in range(10):
         for node in nodes:
             node.force.set(Vector(0, -9.8 * node.mass))
@@ -45,9 +44,13 @@ for i in range(100):
             if node.position.y > 1:
                 node.force.y -= 500 * abs(1 - node.position.y)
 
+        nodes[0].force.set(Vector(0, 0))
+        nodes[0].velocity.set(Vector(0, 0))
+
         for node in nodes:
             node.integrate(time=0.0005)
 
+
     surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 500, 500)
     context = cairo.Context(surface)
 
diff --git a/structures.py b/structures.py
index 9116e38..6e873a6 100644
--- a/structures.py
+++ b/structures.py
@@ -12,30 +12,30 @@ class Structure:
         self.nodes = nodes
         self.links = links
 
-    def move(self, vector: Vector) -> None:
+    def translate(self, vector: Vector) -> None:
         for node in self.nodes:
             node.position += vector
 
     def scale(self, factor: float, center: Vector = None) -> None:
         if center is None:
             center = Vector(0, 0)
-        self.move(-center)
+        self.translate(-center)
         for node in self.nodes:
             node.position *= factor
         for link in self.links:
             link.length *= factor
-        self.move(center)
+        self.translate(center)
 
     def rotate(self, radians: float, center: Vector = None) -> None:
         if center is None:
             center = Vector(0, 0)
-        self.move(-center)
+        self.translate(-center)
         for node in self.nodes:
             node_angle = atan2(node.position.y, node.position.x)
             node_radius = node.position.len()
             node.position.x = node_radius * cos(node_angle + radians)
             node.position.y = node_radius * sin(node_angle + radians)
-        self.move(center)
+        self.translate(center)
 
 
 class Tower(Structure):

commit d43b75b2f160e1ed81a6d802e5e843029553a63a
Author: Daxonus <elias@dobrin.net>
Date:   Mon Apr 25 20:36:37 2022 -0700

    well done

diff --git a/main.py b/main.py
index d77ae27..e5b3676 100644
--- a/main.py
+++ b/main.py
@@ -3,28 +3,29 @@ from math import pi, tau
 from random import random
 import cairo
 import ffmpeg
-from structures import tower, pyramid, wheel, translate, scale, rotate
+from structures import Structure, Tower, Pyramid, Wheel
 from vectors import Vector
 
 
-softbody = tower(position=Vector(0.5, 0.5), width=0.3, height=0.3, grid=(3, 3), mass=0.1, stiffness=50, dampening=1)
-# softbody = pyramid(position=Vector(0.5, 0.6), width=0.3, grid=6, mass=0.1, stiffness=100, dampening=1)
+structure = Tower(width=0.3, height=0.3, grid=(3, 3), mass=0.1, stiffness=50, dampening=1)
+structure.move(Vector(0.5, 0.5))
+# softbody = pyramid(position=Vector(0.5, 0.6), width=0.5, grid=6, mass=0.1, stiffness=100, dampening=1)
 # softbody = wheel(position=Vector(0.5, 0.5), radius=0.25, rings=3, slices=10, mass=0.1, stiffness=200, dampening=1)
-rotate(softbody, rotation=pi / 6, center=Vector(0.5, 0.5))
-nodes, links = softbody
-ln = [link.length_natural for link in links]
+nodes = structure.nodes
+links = structure.links
+
+ln = [link.length for link in links]
 for node in nodes:
-    node.velocity.x += 0.5
-    node.velocity.y += 2
+    node.position.y -= 0.35
 
 camera_position = Vector(0.5, 0.5)
 camera_zoom = 0.9
 
 
-for i in range(1000):
+for i in range(100):
     if i % 30 == 0:
         for l, link in enumerate(links):
-            link.length_natural = ln[l] * (1 + 0.7 * (random() - 0.5))
+            link.length = ln[l] * (1 + 0.2 * (random() - 0.5))
     for s in range(10):
         for node in nodes:
             node.force.set(Vector(0, -9.8 * node.mass))
@@ -68,7 +69,7 @@ for i in range(1000):
         context.move_to(link.nodes[0].position.x, link.nodes[0].position.y)
         context.line_to(link.nodes[1].position.x, link.nodes[1].position.y)
         context.set_source_rgb(0, 0, 0)
-        context.set_line_width(0.01 * (link.length_natural / link.get_length()))
+        context.set_line_width(0.01 * (link.length / link.get_length()))
         context.stroke()
 
     for node in nodes:
diff --git a/softbodies.py b/softbodies.py
index e3eded6..77d78fd 100644
--- a/softbodies.py
+++ b/softbodies.py
@@ -28,16 +28,16 @@ class Link:
     nodes: tuple[Node, Node]
     stiffness: float
     dampening: float
-    length_natural: float
+    length: float
 
-    def __init__(self, nodes: tuple[Node, Node], stiffness: float, dampening: float, length_natural: float = None) -> None:
+    def __init__(self, nodes: tuple[Node, Node], stiffness: float, dampening: float, length: float = None) -> None:
         self.nodes = nodes
         self.stiffness = stiffness
         self.dampening = dampening
-        if length_natural is None:
-            self.length_natural = Vector.dist(nodes[0].position, nodes[1].position)
+        if length is None:
+            self.length = Vector.dist(nodes[0].position, nodes[1].position)
         else:
-            self.length_natural = length_natural
+            self.length = length
 
     def get_length(self) -> float:
         """Get the momentary length of the link."""
@@ -49,7 +49,7 @@ class Link:
 
     def get_displacement(self) -> float:
         """Get the expansion/contraction of the link from its resting configuration (positive/negative)."""
-        return self.get_length() - self.length_natural
+        return self.get_length() - self.length
 
     def get_stiffness_force(self) -> float:
         """Get the spring stiffness force expansion/contraction (positive/negative)."""
diff --git a/structures.py b/structures.py
index acdbadf..9116e38 100644
--- a/structures.py
+++ b/structures.py
@@ -1,113 +1,113 @@
 from __future__ import annotations
 from math import sqrt, cos, sin, atan2, tau
-from random import random
 from softbodies import Node, Link
 from vectors import Vector
 
-Softbody = tuple[list[Node], list[Link]]
 
+class Structure:
+    nodes: list[Node]
+    links: list[Link]
 
-def translate(softbody: Softbody, translation: Vector) -> None:
-    nodes, links = softbody
-    for node in nodes:
-        node.position += translation
+    def __init__(self, nodes: list[Node], links: list[Link]) -> None:
+        self.nodes = nodes
+        self.links = links
 
+    def move(self, vector: Vector) -> None:
+        for node in self.nodes:
+            node.position += vector
 
-def scale(softbody: Softbody, factor: float, center: Vector = None) -> None:
-    nodes, links = softbody
-    if center is None:
-        center = Vector(0, 0)
-    translate(softbody, -center)
-    for node in nodes:
-        node.position *= factor
-    for link in links:
-        link.length_natural *= factor
-    translate(softbody, center)
+    def scale(self, factor: float, center: Vector = None) -> None:
+        if center is None:
+            center = Vector(0, 0)
+        self.move(-center)
+        for node in self.nodes:
+            node.position *= factor
+        for link in self.links:
+            link.length *= factor
+        self.move(center)
 
+    def rotate(self, radians: float, center: Vector = None) -> None:
+        if center is None:
+            center = Vector(0, 0)
+        self.move(-center)
+        for node in self.nodes:
+            node_angle = atan2(node.position.y, node.position.x)
+            node_radius = node.position.len()
+            node.position.x = node_radius * cos(node_angle + radians)
+            node.position.y = node_radius * sin(node_angle + radians)
+        self.move(center)
 
-def rotate(softbody: Softbody, rotation: float, center: Vector = None) -> None:
-    nodes, links = softbody
-    if center is None:
-        center = Vector(0, 0)
-    translate(softbody, -center)
-    for node in nodes:
-        node_angle = atan2(node.position.y, node.position.x)
-        node_radius = node.position.len()
-        node.position.x = node_radius * cos(node_angle + rotation)
-        node.position.y = node_radius * sin(node_angle + rotation)
-    translate(softbody, center)
 
+class Tower(Structure):
+    def __init__(self, width: float, height: float, grid: tuple[int, int], mass: float, stiffness: float, dampening: float) -> None:
+        nodes_mesh = []
+        for x in range(grid[0] + 1):
+            nodes_mesh.append([])
+            for y in range(grid[1] + 1):
+                node_mass = mass / ((grid[0] + 1) * (grid[1] + 1))
+                node_position = Vector(width * (x / grid[0] - 0.5),
+                                       height * (y / grid[1] - 0.5))
+                node = Node(node_mass, node_position)
+                nodes_mesh[x].append(node)
+        links = []
+        for x in range(grid[0]):
+            for y in range(grid[1] + 1):
+                links.append(Link((nodes_mesh[x][y], nodes_mesh[x + 1][y]), stiffness, dampening))
+        for x in range(grid[0] + 1):
+            for y in range(grid[1]):
+                links.append(Link((nodes_mesh[x][y], nodes_mesh[x][y + 1]), stiffness, dampening))
+        for x in range(grid[0]):
+            for y in range(grid[1]):
+                links.append(Link((nodes_mesh[x][y], nodes_mesh[x + 1][y + 1]), stiffness, dampening))
+                links.append(Link((nodes_mesh[x + 1][y], nodes_mesh[x][y + 1]), stiffness, dampening))
+        nodes = [node for buffer in nodes_mesh for node in buffer]
+        super().__init__(nodes, links)
 
-def tower(position: Vector, width: float, height: float, grid: tuple[int, int], mass: float, stiffness: float, dampening: float) -> Softbody:
-    nodes_mesh = []
-    for x in range(grid[0] + 1):
-        nodes_mesh.append([])
-        for y in range(grid[1] + 1):
-            node_mass = mass / ((grid[0] + 1) * (grid[1] + 1))
-            node_position = Vector(position.x + width * (x / grid[0] - 0.5),
-                                   position.y + height * (y / grid[1] - 0.5))
-            node = Node(node_mass, node_position)
-            nodes_mesh[x].append(node)
-    links = []
-    for x in range(grid[0]):
-        for y in range(grid[1] + 1):
-            links.append(Link((nodes_mesh[x][y], nodes_mesh[x + 1][y]), stiffness, dampening))
-    for x in range(grid[0] + 1):
-        for y in range(grid[1]):
-            links.append(Link((nodes_mesh[x][y], nodes_mesh[x][y + 1]), stiffness, dampening))
-    for x in range(grid[0]):
-        for y in range(grid[1]):
-            links.append(Link((nodes_mesh[x][y], nodes_mesh[x + 1][y + 1]), stiffness, dampening))
-            links.append(Link((nodes_mesh[x + 1][y], nodes_mesh[x][y + 1]), stiffness, dampening))
-    nodes = [node for buffer in nodes_mesh for node in buffer]
-    softbody = (nodes, links)
-    return softbody
 
+class Pyramid(Structure):
+    def __init__(self, width: float, grid: int, mass: float, stiffness: float, dampening: float) -> None:
+        height = (sqrt(3) / 2) * width
+        nodes_mesh = []
+        for y in range(grid + 1):
+            nodes_mesh.append([])
+            for x in range(grid + 1 - y):
+                node_mass = mass / ((grid + 1) * (grid + 2) / 2)
+                node_position = Vector(width * ((x + 0.5 * y) / grid - 0.5),
+                                       height * (y / grid - 0.5))
+                node = Node(node_mass, node_position)
+                nodes_mesh[y].append(node)
+        links = []
+        for y in range(grid):
+            for x in range(grid - y):
+                links.append(Link((nodes_mesh[y][x], nodes_mesh[y + 1][x]), stiffness, dampening))
+                links.append(Link((nodes_mesh[y][x], nodes_mesh[y][x + 1]), stiffness, dampening))
+                links.append(Link((nodes_mesh[y][-x - 1], nodes_mesh[y + 1][-x - 1]), stiffness, dampening))
+        nodes = [node for buffer in nodes_mesh for node in buffer]
+        super().__init__(nodes, links)
 
-def pyramid(position: Vector, width: float, grid: int, mass: float, stiffness: float, dampening: float) -> Softbody:
-    height = (sqrt(3) / 2) * width
-    nodes_mesh = []
-    for y in range(grid + 1):
-        nodes_mesh.append([])
-        for x in range(grid + 1 - y):
-            node_mass = mass / ((grid + 1) * (grid + 2) / 2)
-            node_position = Vector(position.x + width * ((x + 0.5 * y) / grid - 0.5),
-                                   position.y + height * (y / grid - 0.5))
-            node = Node(node_mass, node_position)
-            nodes_mesh[y].append(node)
-    links = []
-    for y in range(grid):
-        for x in range(grid - y):
-            links.append(Link((nodes_mesh[y][x], nodes_mesh[y + 1][x]), stiffness, dampening))
-            links.append(Link((nodes_mesh[y][x], nodes_mesh[y][x + 1]), stiffness, dampening))
-            links.append(Link((nodes_mesh[y][-x - 1], nodes_mesh[y + 1][-x - 1]), stiffness, dampening))
-    nodes = [node for buffer in nodes_mesh for node in buffer]
-    softbody = (nodes, links)
-    return softbody
 
-
-def wheel(position: Vector, radius: float, rings: int, slices: int, mass: float, stiffness: float, dampening: float) -> Softbody:
-    node_mass = mass / (rings * slices + 1)
-    nodes_mesh = [[Node(node_mass, position.copy())]]
-    for r in range(1, rings + 1):
-        nodes_mesh.append([])
-        for s in range(slices):
-            ang = (s / slices) * tau
-            rad = (r / rings) * radius
-            node_position = Vector(position.x + rad * cos(ang),
-                                   position.y + rad * sin(ang))
-            node = Node(node_mass, node_position)
-            nodes_mesh[r].append(node)
-    links = []
-    for r in range(1, rings + 1):
-        for s in range(slices):
-            links.append(Link((nodes_mesh[r][s], nodes_mesh[r][(s + 1) % slices]), stiffness, dampening))
-    for s in range(slices):
-        links.append(Link((nodes_mesh[0][0], nodes_mesh[1][s]), stiffness, dampening))
-    for r in range(1, rings):
+class Wheel(Structure):
+    def __init__(self, radius: float, rings: int, slices: int, mass: float, stiffness: float, dampening: float) -> None:
+        node_mass = mass / (rings * slices + 1)
+        nodes_mesh = [[Node(node_mass, Vector(0, 0))]]
+        for r in range(1, rings + 1):
+            nodes_mesh.append([])
+            for s in range(slices):
+                ang = (s / slices) * tau
+                rad = (r / rings) * radius
+                node_position = Vector(rad * cos(ang),
+                                       rad * sin(ang))
+                node = Node(node_mass, node_position)
+                nodes_mesh[r].append(node)
+        links = []
+        for r in range(1, rings + 1):
+            for s in range(slices):
+                links.append(Link((nodes_mesh[r][s], nodes_mesh[r][(s + 1) % slices]), stiffness, dampening))
         for s in range(slices):
-            links.append(Link((nodes_mesh[r][s], nodes_mesh[r + 1][s]), stiffness, dampening))
+            links.append(Link((nodes_mesh[0][0], nodes_mesh[1][s]), stiffness, dampening))
+        for r in range(1, rings):
+            for s in range(slices):
+                links.append(Link((nodes_mesh[r][s], nodes_mesh[r + 1][s]), stiffness, dampening))
 
-    nodes = [node for buffer in nodes_mesh for node in buffer]
-    softbody = (nodes, links)
-    return softbody
\ No newline at end of file
+        nodes = [node for buffer in nodes_mesh for node in buffer]
+        super().__init__(nodes, links)

commit c1ed2dbab581d0821eeab64987c6a8857895219e
Author: Daxonus <elias@dobrin.net>
Date:   Mon Apr 25 16:36:03 2022 -0700

    morph soft body :D

diff --git a/main.py b/main.py
index 841ff30..d77ae27 100644
--- a/main.py
+++ b/main.py
@@ -1,26 +1,30 @@
 import os
 from math import pi, tau
+from random import random
 import cairo
 import ffmpeg
 from structures import tower, pyramid, wheel, translate, scale, rotate
 from vectors import Vector
 
 
-softbody = tower(position=Vector(0.5, 0.7), width=0.5, height=0.5, grid=(5, 5), mass=0.1, stiffness=50, dampening=1)
+softbody = tower(position=Vector(0.5, 0.5), width=0.3, height=0.3, grid=(3, 3), mass=0.1, stiffness=50, dampening=1)
 # softbody = pyramid(position=Vector(0.5, 0.6), width=0.3, grid=6, mass=0.1, stiffness=100, dampening=1)
 # softbody = wheel(position=Vector(0.5, 0.5), radius=0.25, rings=3, slices=10, mass=0.1, stiffness=200, dampening=1)
 rotate(softbody, rotation=pi / 6, center=Vector(0.5, 0.5))
 nodes, links = softbody
-
+ln = [link.length_natural for link in links]
 for node in nodes:
     node.velocity.x += 0.5
-    node.velocity.y += 8
+    node.velocity.y += 2
 
 camera_position = Vector(0.5, 0.5)
 camera_zoom = 0.9
 
 
 for i in range(1000):
+    if i % 30 == 0:
+        for l, link in enumerate(links):
+            link.length_natural = ln[l] * (1 + 0.7 * (random() - 0.5))
     for s in range(10):
         for node in nodes:
             node.force.set(Vector(0, -9.8 * node.mass))

commit 16fb93176f587fb7ae1b330d8ade2d25dd5a6c13
Author: Daxonus <elias@dobrin.net>
Date:   Mon Apr 25 16:12:57 2022 -0700

    box

diff --git a/main.py b/main.py
index 561f9e2..841ff30 100644
--- a/main.py
+++ b/main.py
@@ -6,21 +6,21 @@ from structures import tower, pyramid, wheel, translate, scale, rotate
 from vectors import Vector
 
 
-softbody = tower(position=Vector(0.5, 0.5), width=0.5, height=0.5, grid=(5, 5), mass=0.1, stiffness=50, dampening=1)
+softbody = tower(position=Vector(0.5, 0.7), width=0.5, height=0.5, grid=(5, 5), mass=0.1, stiffness=50, dampening=1)
 # softbody = pyramid(position=Vector(0.5, 0.6), width=0.3, grid=6, mass=0.1, stiffness=100, dampening=1)
-# softbody = wheel(position=Vector(0, 0.5), radius=0.25, rings=3, slices=10, mass=0.1, stiffness=100, dampening=1)
+# softbody = wheel(position=Vector(0.5, 0.5), radius=0.25, rings=3, slices=10, mass=0.1, stiffness=200, dampening=1)
 rotate(softbody, rotation=pi / 6, center=Vector(0.5, 0.5))
 nodes, links = softbody
 
 for node in nodes:
-    node.velocity.x += 2
+    node.velocity.x += 0.5
+    node.velocity.y += 8
 
 camera_position = Vector(0.5, 0.5)
-camera_zoom = 1
+camera_zoom = 0.9
 
 
-
-for i in range(500):
+for i in range(1000):
     for s in range(10):
         for node in nodes:
             node.force.set(Vector(0, -9.8 * node.mass))
@@ -48,18 +48,14 @@ for i in range(500):
 
     context.scale(500, 500)
     context.rectangle(0, 0, 1, 1)
-    context.set_source_rgb(1, 0.94, 0.79)
+    context.set_source_rgb(1, 1, 1)
     context.fill()
     context.translate(0.5, 0.5)
     context.scale(1, -1)
     context.scale(camera_zoom, camera_zoom)
     context.translate(-camera_position.x, -camera_position.y)
 
-    context.rectangle(-1000, -10, 2000, 10)
-    context.set_source_rgb(1, 1, 1)
-    context.fill()
-    context.move_to(-1000, 0)
-    context.line_to(1000, 0)
+    context.rectangle(0, 0, 1, 1)
     context.set_source_rgb(0, 0, 0)
     context.set_line_width(0.01)
     context.stroke()
@@ -68,8 +64,7 @@ for i in range(500):
         context.move_to(link.nodes[0].position.x, link.nodes[0].position.y)
         context.line_to(link.nodes[1].position.x, link.nodes[1].position.y)
         context.set_source_rgb(0, 0, 0)
-        context.set_line_width(0.01 * (link.resting_length / link.get_length()))
-        context.set_line_cap(cairo.LINE_CAP_ROUND)
+        context.set_line_width(0.01 * (link.length_natural / link.get_length()))
         context.stroke()
 
     for node in nodes:
@@ -77,7 +72,7 @@ for i in range(500):
         context.set_source_rgb(1, 1, 1)
         context.fill_preserve()
         context.set_source_rgb(0, 0, 0)
-        context.set_line_width(0.01)
+        context.set_line_width(0.005)
         context.stroke()
 
     surface.write_to_png(f"output/{i:06d}.png")
diff --git a/softbodies.py b/softbodies.py
index 20a20eb..e3eded6 100644
--- a/softbodies.py
+++ b/softbodies.py
@@ -26,18 +26,18 @@ class Node:
 class Link:
     """A massless Hookean spring that features a pair of spring stiffness and dampening forces."""
     nodes: tuple[Node, Node]
-    resting_length: float
     stiffness: float
     dampening: float
+    length_natural: float
 
-    def __init__(self, nodes: tuple[Node, Node], stiffness: float, dampening: float, resting_length: float = None) -> None:
+    def __init__(self, nodes: tuple[Node, Node], stiffness: float, dampening: float, length_natural: float = None) -> None:
         self.nodes = nodes
-        if resting_length is None:
-            self.resting_length = Vector.dist(nodes[0].position, nodes[1].position)
-        else:
-            self.resting_length = resting_length
         self.stiffness = stiffness
         self.dampening = dampening
+        if length_natural is None:
+            self.length_natural = Vector.dist(nodes[0].position, nodes[1].position)
+        else:
+            self.length_natural = length_natural
 
     def get_length(self) -> float:
         """Get the momentary length of the link."""
@@ -49,7 +49,7 @@ class Link:
 
     def get_displacement(self) -> float:
         """Get the expansion/contraction of the link from its resting configuration (positive/negative)."""
-        return self.get_length() - self.resting_length
+        return self.get_length() - self.length_natural
 
     def get_stiffness_force(self) -> float:
         """Get the spring stiffness force expansion/contraction (positive/negative)."""
diff --git a/structures.py b/structures.py
index b314a29..acdbadf 100644
--- a/structures.py
+++ b/structures.py
@@ -21,7 +21,7 @@ def scale(softbody: Softbody, factor: float, center: Vector = None) -> None:
     for node in nodes:
         node.position *= factor
     for link in links:
-        link.resting_length *= factor
+        link.length_natural *= factor
     translate(softbody, center)
 
 

commit 32d82a72d125a64a4677163fc63bf681153a829c
Author: Daxonus <elias@dobrin.net>
Date:   Mon Apr 25 09:16:36 2022 -0700

    more collision boundaries

diff --git a/main.py b/main.py
index 34d53e6..561f9e2 100644
--- a/main.py
+++ b/main.py
@@ -6,14 +6,16 @@ from structures import tower, pyramid, wheel, translate, scale, rotate
 from vectors import Vector
 
 
-# softbody = tower(position=Vector(0, 0.5), width=0.5, height=0.5, grid=(5, 5), mass=0.1, stiffness=50, dampening=1)
-# softbody = pyramid(position=Vector(0, 0.5), width=0.5, grid=6, mass=0.1, stiffness=100, dampening=1)
-softbody = wheel(position=Vector(0, 0.5), radius=0.25, rings=3, slices=10, mass=0.1, stiffness=100, dampening=1)
-# rotate(softbody, rotation=pi / 6, center=Vector(0, 1))
+softbody = tower(position=Vector(0.5, 0.5), width=0.5, height=0.5, grid=(5, 5), mass=0.1, stiffness=50, dampening=1)
+# softbody = pyramid(position=Vector(0.5, 0.6), width=0.3, grid=6, mass=0.1, stiffness=100, dampening=1)
+# softbody = wheel(position=Vector(0, 0.5), radius=0.25, rings=3, slices=10, mass=0.1, stiffness=100, dampening=1)
+rotate(softbody, rotation=pi / 6, center=Vector(0.5, 0.5))
 nodes, links = softbody
 
+for node in nodes:
+    node.velocity.x += 2
 
-camera_position = Vector(0, 0.2)
+camera_position = Vector(0.5, 0.5)
 camera_zoom = 1
 
 
@@ -29,16 +31,22 @@ for i in range(500):
                 link.nodes[0].position, link.nodes[1].position))
 
         for node in nodes:
+            if node.position.x < 0:
+                node.force.x += 500 * abs(node.position.x)
+            if node.position.x > 1:
+                node.force.x -= 500 * abs(1 - node.position.x)
             if node.position.y < 0:
-                node.force.y -= 500 * node.position.y
+                node.force.y += 500 * abs(node.position.y)
+            if node.position.y > 1:
+                node.force.y -= 500 * abs(1 - node.position.y)
 
         for node in nodes:
             node.integrate(time=0.0005)
 
-    surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 250, 250)
+    surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 500, 500)
     context = cairo.Context(surface)
 
-    context.scale(250, 250)
+    context.scale(500, 500)
     context.rectangle(0, 0, 1, 1)
     context.set_source_rgb(1, 0.94, 0.79)
     context.fill()

commit 0bbdd2e6ea77c408dfd9fa70f35a60b0bd2396a8
Author: Daxonus <elias@dobrin.net>
Date:   Sun Apr 24 17:45:38 2022 -0700

    got bugs fixed

diff --git a/main.py b/main.py
index b945a93..34d53e6 100644
--- a/main.py
+++ b/main.py
@@ -1,24 +1,25 @@
 import os
-from math import tau
+from math import pi, tau
 import cairo
 import ffmpeg
-from structures import tower, pyramid, wheel
+from structures import tower, pyramid, wheel, translate, scale, rotate
 from vectors import Vector
 
 
-#softbody = tower(position=Vector(0, 0), width=1, height=1, grid=(10, 10), mass=1, stiffness=100, dampening=1)
-softbody = pyramid(position=Vector(0, 1), width=0.5, grid=6, mass=0.1, stiffness=100, dampening=1)
-#softbody = wheel(position=Vector(0, 0), radius=0.5, rings=7, slices=10, mass=1, stiffness=400, dampening=1)
+# softbody = tower(position=Vector(0, 0.5), width=0.5, height=0.5, grid=(5, 5), mass=0.1, stiffness=50, dampening=1)
+# softbody = pyramid(position=Vector(0, 0.5), width=0.5, grid=6, mass=0.1, stiffness=100, dampening=1)
+softbody = wheel(position=Vector(0, 0.5), radius=0.25, rings=3, slices=10, mass=0.1, stiffness=100, dampening=1)
+# rotate(softbody, rotation=pi / 6, center=Vector(0, 1))
 nodes, links = softbody
 
 
-camera_position = Vector(0, 0)
+camera_position = Vector(0, 0.2)
 camera_zoom = 1
 
 
 
 for i in range(500):
-    for s in range(5):
+    for s in range(10):
         for node in nodes:
             node.force.set(Vector(0, -9.8 * node.mass))
         for link in links:
@@ -32,7 +33,7 @@ for i in range(500):
                 node.force.y -= 500 * node.position.y
 
         for node in nodes:
-            node.integrate(time=0.001)
+            node.integrate(time=0.0005)
 
     surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 250, 250)
     context = cairo.Context(surface)
diff --git a/structures.py b/structures.py
index 4a4988d..b314a29 100644
--- a/structures.py
+++ b/structures.py
@@ -13,21 +13,29 @@ def translate(softbody: Softbody, translation: Vector) -> None:
         node.position += translation
 
 
-def scale(softbody: Softbody, factor: float) -> None:
+def scale(softbody: Softbody, factor: float, center: Vector = None) -> None:
     nodes, links = softbody
+    if center is None:
+        center = Vector(0, 0)
+    translate(softbody, -center)
     for node in nodes:
         node.position *= factor
     for link in links:
         link.resting_length *= factor
+    translate(softbody, center)
 
 
-def rotate(softbody: Softbody, rotation: float) -> None:
+def rotate(softbody: Softbody, rotation: float, center: Vector = None) -> None:
     nodes, links = softbody
+    if center is None:
+        center = Vector(0, 0)
+    translate(softbody, -center)
     for node in nodes:
         node_angle = atan2(node.position.y, node.position.x)
         node_radius = node.position.len()
         node.position.x = node_radius * cos(node_angle + rotation)
         node.position.y = node_radius * sin(node_angle + rotation)
+    translate(softbody, center)
 
 
 def tower(position: Vector, width: float, height: float, grid: tuple[int, int], mass: float, stiffness: float, dampening: float) -> Softbody:

commit 626a68f80b17c4645ad94e1e77c3aa6f685e9ab7
Author: Daxonus <elias@dobrin.net>
Date:   Sun Apr 24 17:16:03 2022 -0700

    transform functions in structures

diff --git a/__pycache__/structures.cpython-310.pyc b/__pycache__/structures.cpython-310.pyc
index db9268d..ca456a1 100644
Binary files a/__pycache__/structures.cpython-310.pyc and b/__pycache__/structures.cpython-310.pyc differ
diff --git a/main.py b/main.py
index 9d88626..b945a93 100644
--- a/main.py
+++ b/main.py
@@ -1,6 +1,5 @@
 import os
 from math import tau
-from scipy.constants import g
 import cairo
 import ffmpeg
 from structures import tower, pyramid, wheel
@@ -8,55 +7,69 @@ from vectors import Vector
 
 
 #softbody = tower(position=Vector(0, 0), width=1, height=1, grid=(10, 10), mass=1, stiffness=100, dampening=1)
-softbody = pyramid(position=Vector(0, 0), width=1, grid=6, mass=1, stiffness=100, dampening=1)
+softbody = pyramid(position=Vector(0, 1), width=0.5, grid=6, mass=0.1, stiffness=100, dampening=1)
 #softbody = wheel(position=Vector(0, 0), radius=0.5, rings=7, slices=10, mass=1, stiffness=400, dampening=1)
 nodes, links = softbody
 
+
 camera_position = Vector(0, 0)
-camera_zoom = 0.5
+camera_zoom = 1
 
 
 
 for i in range(500):
     for s in range(5):
         for node in nodes:
-            node.force.set(Vector(0, -node.mass * g))
+            node.force.set(Vector(0, -9.8 * node.mass))
         for link in links:
             link.nodes[0].force.add(link.get_force() * (link.nodes[0].position - link.nodes[1].position) / Vector.dist(
                 link.nodes[0].position, link.nodes[1].position))
             link.nodes[1].force.add(link.get_force() * (link.nodes[1].position - link.nodes[0].position) / Vector.dist(
                 link.nodes[0].position, link.nodes[1].position))
-        nodes[0].force.set(Vector(0, 0))
+
+        for node in nodes:
+            if node.position.y < 0:
+                node.force.y -= 500 * node.position.y
+
         for node in nodes:
             node.integrate(time=0.001)
 
     surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 250, 250)
-    ctx = cairo.Context(surface)
+    context = cairo.Context(surface)
+
+    context.scale(250, 250)
+    context.rectangle(0, 0, 1, 1)
+    context.set_source_rgb(1, 0.94, 0.79)
+    context.fill()
+    context.translate(0.5, 0.5)
+    context.scale(1, -1)
+    context.scale(camera_zoom, camera_zoom)
+    context.translate(-camera_position.x, -camera_position.y)
 
-    ctx.scale(250, 250)
-    ctx.rectangle(0, 0, 1, 1)
-    ctx.set_source_rgb(1, 0.94, 0.79)
-    ctx.fill()
-    ctx.translate(0.5, 0.5)
-    ctx.scale(1, -1)
-    ctx.scale(camera_zoom, camera_zoom)
-    ctx.translate(-camera_position.x, -camera_position.y)
+    context.rectangle(-1000, -10, 2000, 10)
+    context.set_source_rgb(1, 1, 1)
+    context.fill()
+    context.move_to(-1000, 0)
+    context.line_to(1000, 0)
+    context.set_source_rgb(0, 0, 0)
+    context.set_line_width(0.01)
+    context.stroke()
 
     for link in links:
-        ctx.move_to(link.nodes[0].position.x, link.nodes[0].position.y)
-        ctx.line_to(link.nodes[1].position.x, link.nodes[1].position.y)
-        ctx.set_source_rgb(0, 0, 0)
-        ctx.set_line_width(0.03 * (link.resting_length / link.get_length()))
-        ctx.set_line_cap(cairo.LINE_CAP_ROUND)
-        ctx.stroke()
+        context.move_to(link.nodes[0].position.x, link.nodes[0].position.y)
+        context.line_to(link.nodes[1].position.x, link.nodes[1].position.y)
+        context.set_source_rgb(0, 0, 0)
+        context.set_line_width(0.01 * (link.resting_length / link.get_length()))
+        context.set_line_cap(cairo.LINE_CAP_ROUND)
+        context.stroke()
 
     for node in nodes:
-        ctx.arc(node.position.x, node.position.y, 0.03, 0, tau)
-        ctx.set_source_rgb(1, 1, 1)
-        ctx.fill_preserve()
-        ctx.set_source_rgb(0, 0, 0)
-        ctx.set_line_width(0.02)
-        ctx.stroke()
+        context.arc(node.position.x, node.position.y, 0.01, 0, tau)
+        context.set_source_rgb(1, 1, 1)
+        context.fill_preserve()
+        context.set_source_rgb(0, 0, 0)
+        context.set_line_width(0.01)
+        context.stroke()
 
     surface.write_to_png(f"output/{i:06d}.png")
 
diff --git a/structures.py b/structures.py
index 9301daa..4a4988d 100644
--- a/structures.py
+++ b/structures.py
@@ -7,16 +7,27 @@ from vectors import Vector
 Softbody = tuple[list[Node], list[Link]]
 
 
-def structure(softbody: Softbody, position: Vector, scale: float, rotation: float) -> Softbody:
+def translate(softbody: Softbody, translation: Vector) -> None:
+    nodes, links = softbody
+    for node in nodes:
+        node.position += translation
+
+
+def scale(softbody: Softbody, factor: float) -> None:
+    nodes, links = softbody
+    for node in nodes:
+        node.position *= factor
+    for link in links:
+        link.resting_length *= factor
+
+
+def rotate(softbody: Softbody, rotation: float) -> None:
     nodes, links = softbody
     for node in nodes:
         node_angle = atan2(node.position.y, node.position.x)
-        node_radius = node.position.dist(Vector(0, 0))
+        node_radius = node.position.len()
         node.position.x = node_radius * cos(node_angle + rotation)
         node.position.y = node_radius * sin(node_angle + rotation)
-        node.position *= scale
-        node.position += position
-    return nodes, links
 
 
 def tower(position: Vector, width: float, height: float, grid: tuple[int, int], mass: float, stiffness: float, dampening: float) -> Softbody:
@@ -42,7 +53,7 @@ def tower(position: Vector, width: float, height: float, grid: tuple[int, int],
             links.append(Link((nodes_mesh[x + 1][y], nodes_mesh[x][y + 1]), stiffness, dampening))
     nodes = [node for buffer in nodes_mesh for node in buffer]
     softbody = (nodes, links)
-    return structure(softbody, position=Vector(0, 0), scale=1, rotation=0)
+    return softbody
 
 
 def pyramid(position: Vector, width: float, grid: int, mass: float, stiffness: float, dampening: float) -> Softbody:
@@ -64,7 +75,7 @@ def pyramid(position: Vector, width: float, grid: int, mass: float, stiffness: f
             links.append(Link((nodes_mesh[y][-x - 1], nodes_mesh[y + 1][-x - 1]), stiffness, dampening))
     nodes = [node for buffer in nodes_mesh for node in buffer]
     softbody = (nodes, links)
-    return structure(softbody, position=Vector(0, 0), rotation=0, scale=1)
+    return softbody
 
 
 def wheel(position: Vector, radius: float, rings: int, slices: int, mass: float, stiffness: float, dampening: float) -> Softbody:
@@ -91,4 +102,4 @@ def wheel(position: Vector, radius: float, rings: int, slices: int, mass: float,
 
     nodes = [node for buffer in nodes_mesh for node in buffer]
     softbody = (nodes, links)
-    return structure(softbody, position=Vector(0, 0), scale=1, rotation=0)
\ No newline at end of file
+    return softbody
\ No newline at end of file

commit 3ffcff49df3b3ca0da60ec8fdc9963054d2a5391
Author: Daxonus <elias@dobrin.net>
Date:   Sun Apr 24 17:02:02 2022 -0700

    import and update library from softbots

diff --git a/__pycache__/softbodies.cpython-310.pyc b/__pycache__/softbodies.cpython-310.pyc
index 129df27..0ff535f 100644
Binary files a/__pycache__/softbodies.cpython-310.pyc and b/__pycache__/softbodies.cpython-310.pyc differ
diff --git a/__pycache__/structures.cpython-310.pyc b/__pycache__/structures.cpython-310.pyc
index 1b39508..db9268d 100644
Binary files a/__pycache__/structures.cpython-310.pyc and b/__pycache__/structures.cpython-310.pyc differ
diff --git a/__pycache__/vectors.cpython-310.pyc b/__pycache__/vectors.cpython-310.pyc
new file mode 100644
index 0000000..af552bb
Binary files /dev/null and b/__pycache__/vectors.cpython-310.pyc differ
diff --git a/render.py b/main.py
similarity index 95%
rename from render.py
rename to main.py
index 1017608..9d88626 100644
--- a/render.py
+++ b/main.py
@@ -28,8 +28,7 @@ for i in range(500):
                 link.nodes[0].position, link.nodes[1].position))
         nodes[0].force.set(Vector(0, 0))
         for node in nodes:
-            node.iterate(time=0.001)
-        camera_position = 0.95 * camera_position + 0.05 * nodes[17].position
+            node.integrate(time=0.001)
 
     surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 250, 250)
     ctx = cairo.Context(surface)
diff --git a/softbodies.py b/softbodies.py
index 20bfd7d..20a20eb 100644
--- a/softbodies.py
+++ b/softbodies.py
@@ -1,4 +1,5 @@
 from __future__ import annotations
+from typing import Callable
 from vectors import Vector
 
 
@@ -15,9 +16,10 @@ class Node:
         self.velocity = Vector(0, 0)
         self.force = Vector(0, 0)
 
-    def iterate(self, time: float) -> None:
+    def integrate(self, time: float) -> None:
         """Integrate the position and velocity with Euler's method."""
-        self.velocity += (self.force / self.mass) * time
+        acceleration = self.force / self.mass
+        self.velocity += acceleration * time
         self.position += self.velocity * time
 
 
@@ -61,6 +63,6 @@ class Link:
         """Get the spring force expansion/contraction (positive/negative)."""
         return self.get_stiffness_force() + self.get_dampening_force()
 
-    def iterate(self, time: float) -> None:
-        self.nodes[0].iterate(time)
-        self.nodes[1].iterate(time)
+    def integrate(self, time: float) -> None:
+        self.nodes[0].integrate(time)
+        self.nodes[1].integrate(time)
\ No newline at end of file

commit acdc10ef763d2630739e8216b98cbd00272c91b0
Author: Daxonus <elias@dobrin.net>
Date:   Sun Apr 24 16:55:24 2022 -0700

    turns out static frames is no good for softbody simulations

diff --git a/.gitignore b/.gitignore
index 833acb2..e841d78 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,3 +1,3 @@
 venv/
-render/
+output/
 output.mp4
\ No newline at end of file
diff --git a/__pycache__/points.cpython-310.pyc b/__pycache__/points.cpython-310.pyc
new file mode 100644
index 0000000..08d760a
Binary files /dev/null and b/__pycache__/points.cpython-310.pyc differ
diff --git a/__pycache__/render.cpython-310.pyc b/__pycache__/render.cpython-310.pyc
deleted file mode 100644
index cb717d9..0000000
Binary files a/__pycache__/render.cpython-310.pyc and /dev/null differ
diff --git a/__pycache__/softbodies.cpython-310.pyc b/__pycache__/softbodies.cpython-310.pyc
index f5addf6..129df27 100644
Binary files a/__pycache__/softbodies.cpython-310.pyc and b/__pycache__/softbodies.cpython-310.pyc differ
diff --git a/__pycache__/structures.cpython-310.pyc b/__pycache__/structures.cpython-310.pyc
index e74ab45..1b39508 100644
Binary files a/__pycache__/structures.cpython-310.pyc and b/__pycache__/structures.cpython-310.pyc differ
diff --git a/__pycache__/test.cpython-310.pyc b/__pycache__/test.cpython-310.pyc
new file mode 100644
index 0000000..7e91431
Binary files /dev/null and b/__pycache__/test.cpython-310.pyc differ
diff --git a/__pycache__/vectors.cpython-310.pyc b/__pycache__/vectors.cpython-310.pyc
deleted file mode 100644
index 4dac588..0000000
Binary files a/__pycache__/vectors.cpython-310.pyc and /dev/null differ
diff --git a/render.py b/render.py
index bffe09d..1017608 100644
--- a/render.py
+++ b/render.py
@@ -1,58 +1,67 @@
+import os
 from math import tau
-from time import sleep
+from scipy.constants import g
 import cairo
-import matplotlib.pyplot as plt
-import numpy as np
-from softbodies import Node, Link
+import ffmpeg
+from structures import tower, pyramid, wheel
 from vectors import Vector
 
 
-def render(frames: list[tuple[list[Node], list[Link]]], camera_position: Vector, camera_zoom: float):
-    surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 1000, 1000)
+#softbody = tower(position=Vector(0, 0), width=1, height=1, grid=(10, 10), mass=1, stiffness=100, dampening=1)
+softbody = pyramid(position=Vector(0, 0), width=1, grid=6, mass=1, stiffness=100, dampening=1)
+#softbody = wheel(position=Vector(0, 0), radius=0.5, rings=7, slices=10, mass=1, stiffness=400, dampening=1)
+nodes, links = softbody
+
+camera_position = Vector(0, 0)
+camera_zoom = 0.5
+
+
+
+for i in range(500):
+    for s in range(5):
+        for node in nodes:
+            node.force.set(Vector(0, -node.mass * g))
+        for link in links:
+            link.nodes[0].force.add(link.get_force() * (link.nodes[0].position - link.nodes[1].position) / Vector.dist(
+                link.nodes[0].position, link.nodes[1].position))
+            link.nodes[1].force.add(link.get_force() * (link.nodes[1].position - link.nodes[0].position) / Vector.dist(
+                link.nodes[0].position, link.nodes[1].position))
+        nodes[0].force.set(Vector(0, 0))
+        for node in nodes:
+            node.iterate(time=0.001)
+        camera_position = 0.95 * camera_position + 0.05 * nodes[17].position
+
+    surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 250, 250)
     ctx = cairo.Context(surface)
 
-    ctx.scale(1000, 1000)
+    ctx.scale(250, 250)
     ctx.rectangle(0, 0, 1, 1)
-    ctx.set_source_rgb(1, 1, 1)
+    ctx.set_source_rgb(1, 0.94, 0.79)
     ctx.fill()
     ctx.translate(0.5, 0.5)
     ctx.scale(1, -1)
     ctx.scale(camera_zoom, camera_zoom)
     ctx.translate(-camera_position.x, -camera_position.y)
 
-    for f, frame in enumerate(frames):
-        nodes, links = frame
-        for link in links:
-            ctx.move_to(link.nodes[0].position.x, link.nodes[0].position.y)
-            ctx.line_to(link.nodes[1].position.x, link.nodes[1].position.y)
-            ctx.set_source_rgba(0, 0, 0, 0.1)
-            if f == len(frames) - 1: ctx.set_source_rgb(0, 0, 0)
-            ctx.set_line_width(0.03 * (link.resting_length / link.get_length()))
-            ctx.set_line_cap(cairo.LINE_CAP_ROUND)
-            ctx.stroke()
-        if f != len(frames) - 1: continue
-        for node in nodes:
-            ctx.arc(node.position.x, node.position.y, 0.03, 0, tau)
-            ctx.set_source_rgb(1, 1, 1)
-            ctx.fill_preserve()
-            ctx.set_source_rgba(0, 0, 0, 1)
-            ctx.set_line_width(0.02)
-            ctx.stroke()
-
-    raw = surface.get_data().tolist()
-    counter = 0
-    image = np.empty((1000, 1000, 3), dtype=np.uint8)
-    for x in range(1000):
-        for y in range(1000):
-            for c in range(3):
-                image[x][y][2 - c] = raw[counter]
-                counter += 1
-            counter += 1
-    fig, ax = plt.subplots()
-    ax.imshow(image)
-    ax.set_title("Softbody simulation sketch")
-    plt.show()
-
-if __name__ == "__main__":
-    print("This file is a utility program that does not work on its own.")
-    sleep(5)
+    for link in links:
+        ctx.move_to(link.nodes[0].position.x, link.nodes[0].position.y)
+        ctx.line_to(link.nodes[1].position.x, link.nodes[1].position.y)
+        ctx.set_source_rgb(0, 0, 0)
+        ctx.set_line_width(0.03 * (link.resting_length / link.get_length()))
+        ctx.set_line_cap(cairo.LINE_CAP_ROUND)
+        ctx.stroke()
+
+    for node in nodes:
+        ctx.arc(node.position.x, node.position.y, 0.03, 0, tau)
+        ctx.set_source_rgb(1, 1, 1)
+        ctx.fill_preserve()
+        ctx.set_source_rgb(0, 0, 0)
+        ctx.set_line_width(0.02)
+        ctx.stroke()
+
+    surface.write_to_png(f"output/{i:06d}.png")
+
+
+ffmpeg.input("output/%06d.png", pattern_type="sequence", framerate=60).output("output.mp4").run(overwrite_output=True)
+for png in os.scandir("output"):
+    os.remove(png)
diff --git a/soft_box_medium.py b/soft_box_medium.py
deleted file mode 100644
index 2fc7b76..0000000
--- a/soft_box_medium.py
+++ /dev/null
@@ -1,32 +0,0 @@
-from copy import deepcopy
-from math import pi
-from vectors import Vector
-from structures import Tower
-from render import render
-
-tower = Tower(position=Vector(0, 0), width=1, height=1, grid=(5, 5), mass=1, stiffness=100, dampening=1)
-nodes = tower.nodes
-links = tower.links
-
-frames = []
-
-for i in range(100):
-    for s in range(1):
-        for node in nodes:
-            node.force.set(Vector(0, -9.80665 * node.mass))
-        for link in links:
-            link.nodes[0].force.add(link.get_force() * (link.nodes[0].position - link.nodes[1].position) / Vector.dist(
-                link.nodes[0].position, link.nodes[1].position))
-            link.nodes[1].force.add(link.get_force() * (link.nodes[1].position - link.nodes[0].position) / Vector.dist(
-                link.nodes[0].position, link.nodes[1].position))
-
-        nodes[0].force.set(Vector(0, 0))
-
-        for node in nodes:
-            node.iterate(time=0.005)
-
-    if i % 50 == 0:
-        frame = deepcopy((nodes, links))
-        frames.append(frame)
-
-render(frames, camera_position=Vector(0, 0), camera_zoom=0.5)
\ No newline at end of file
diff --git a/soft_box_small.py b/soft_box_small.py
deleted file mode 100644
index 5ba3277..0000000
--- a/soft_box_small.py
+++ /dev/null
@@ -1,34 +0,0 @@
-from copy import deepcopy
-from math import pi
-from vectors import Vector
-from structures import Tower
-from render import render
-
-tower = Tower(position=Vector(0, 0), width=1, height=1, grid=(3, 3), mass=1, stiffness=20, dampening=1)
-tower.rotate(pi / 2)
-nodes = tower.nodes
-links = tower.links
-
-frames = []
-
-for i in range(100):
-    for s in range(1):
-        for node in nodes:
-            node.force.set(Vector(0, -9.80665 * node.mass))
-        for link in links:
-            link.nodes[0].force.add(link.get_force() * (link.nodes[0].position - link.nodes[1].position) / Vector.dist(
-                link.nodes[0].position, link.nodes[1].position))
-            link.nodes[1].force.add(link.get_force() * (link.nodes[1].position - link.nodes[0].position) / Vector.dist(
-                link.nodes[0].position, link.nodes[1].position))
-
-        for node in tower.nodes_mesh[0]:
-            node.force.set(Vector(0, 0))
-
-        for node in nodes:
-            node.iterate(time=0.005)
-
-    if i % 20 == 0:
-        frame = deepcopy((nodes, links))
-        frames.append(frame)
-
-render(frames, camera_position=Vector(0, 0), camera_zoom=0.5)
\ No newline at end of file
diff --git a/soft_pyramid.py b/soft_pyramid.py
deleted file mode 100644
index 9b44497..0000000
--- a/soft_pyramid.py
+++ /dev/null
@@ -1,32 +0,0 @@
-from copy import deepcopy
-from math import pi
-from vectors import Vector
-from structures import Pyramid
-from render import render
-
-pyramid = Pyramid(position=Vector(0, 0), width=1, grid=5, mass=1, stiffness=100, dampening=1)
-nodes = pyramid.nodes
-links = pyramid.links
-
-frames = []
-
-for i in range(100):
-    for s in range(1):
-        for node in nodes:
-            node.force.set(Vector(0, -9.80665 * node.mass))
-        for link in links:
-            link.nodes[0].force.add(link.get_force() * (link.nodes[0].position - link.nodes[1].position) / Vector.dist(
-                link.nodes[0].position, link.nodes[1].position))
-            link.nodes[1].force.add(link.get_force() * (link.nodes[1].position - link.nodes[0].position) / Vector.dist(
-                link.nodes[0].position, link.nodes[1].position))
-
-        nodes[0].force.set(Vector(0, 0))
-
-        for node in nodes:
-            node.iterate(time=0.005)
-
-    if i % 50 == 0:
-        frame = deepcopy((nodes, links))
-        frames.append(frame)
-
-render(frames, camera_position=Vector(0, 0), camera_zoom=0.5)
\ No newline at end of file
diff --git a/soft_wheel.py b/soft_wheel.py
deleted file mode 100644
index d676484..0000000
--- a/soft_wheel.py
+++ /dev/null
@@ -1,31 +0,0 @@
-from copy import deepcopy
-from vectors import Vector
-from structures import Wheel
-from render import render
-
-wheel = Wheel(position=Vector(0, 0), radius=0.5, rings=3, slices=10, mass=1, stiffness=100, dampening=1)
-nodes = wheel.nodes
-links = wheel.links
-
-frames = []
-
-for i in range(100):
-    for s in range(1):
-        for node in nodes:
-            node.force.set(Vector(0, -9.80665 * node.mass))
-        for link in links:
-            link.nodes[0].force.add(link.get_force() * (link.nodes[0].position - link.nodes[1].position) / Vector.dist(
-                link.nodes[0].position, link.nodes[1].position))
-            link.nodes[1].force.add(link.get_force() * (link.nodes[1].position - link.nodes[0].position) / Vector.dist(
-                link.nodes[0].position, link.nodes[1].position))
-
-        nodes[0].force.set(Vector(0, 0))
-
-        for node in nodes:
-            node.iterate(time=0.005)
-
-    if i % 50 == 0:
-        frame = deepcopy((nodes, links))
-        frames.append(frame)
-
-render(frames, camera_position=Vector(0, 0), camera_zoom=0.5)
\ No newline at end of file
diff --git a/structures.py b/structures.py
index e661162..9301daa 100644
--- a/structures.py
+++ b/structures.py
@@ -7,109 +7,88 @@ from vectors import Vector
 Softbody = tuple[list[Node], list[Link]]
 
 
-class Structure:
-    nodes: list[Node]
-    links: list[Link]
+def structure(softbody: Softbody, position: Vector, scale: float, rotation: float) -> Softbody:
+    nodes, links = softbody
+    for node in nodes:
+        node_angle = atan2(node.position.y, node.position.x)
+        node_radius = node.position.dist(Vector(0, 0))
+        node.position.x = node_radius * cos(node_angle + rotation)
+        node.position.y = node_radius * sin(node_angle + rotation)
+        node.position *= scale
+        node.position += position
+    return nodes, links
 
-    def __init__(self, nodes: list[Node], links: list[Link]) -> None:
-        self.nodes = nodes
-        self.links = links
 
-    def translate(self, translation: Vector) -> None:
-        for node in self.nodes:
-            node.position += translation
+def tower(position: Vector, width: float, height: float, grid: tuple[int, int], mass: float, stiffness: float, dampening: float) -> Softbody:
+    nodes_mesh = []
+    for x in range(grid[0] + 1):
+        nodes_mesh.append([])
+        for y in range(grid[1] + 1):
+            node_mass = mass / ((grid[0] + 1) * (grid[1] + 1))
+            node_position = Vector(position.x + width * (x / grid[0] - 0.5),
+                                   position.y + height * (y / grid[1] - 0.5))
+            node = Node(node_mass, node_position)
+            nodes_mesh[x].append(node)
+    links = []
+    for x in range(grid[0]):
+        for y in range(grid[1] + 1):
+            links.append(Link((nodes_mesh[x][y], nodes_mesh[x + 1][y]), stiffness, dampening))
+    for x in range(grid[0] + 1):
+        for y in range(grid[1]):
+            links.append(Link((nodes_mesh[x][y], nodes_mesh[x][y + 1]), stiffness, dampening))
+    for x in range(grid[0]):
+        for y in range(grid[1]):
+            links.append(Link((nodes_mesh[x][y], nodes_mesh[x + 1][y + 1]), stiffness, dampening))
+            links.append(Link((nodes_mesh[x + 1][y], nodes_mesh[x][y + 1]), stiffness, dampening))
+    nodes = [node for buffer in nodes_mesh for node in buffer]
+    softbody = (nodes, links)
+    return structure(softbody, position=Vector(0, 0), scale=1, rotation=0)
 
-    def scale(self, factor: Vector) -> None:
-        for node in self.nodes:
-            node.position.x *= factor.x
-            node.position.y *= factor.y
-        for link in self.links:
-            link.resting_length *= factor.len
 
-    def rotate(self, radians: float) -> None:
-        for node in self.nodes:
-            node_angle = atan2(node.position.y, node.position.x)
-            node_radius = node.position.dist(Vector(0, 0))
-            node.position.x = node_radius * cos(node_angle + radians)
-            node.position.y = node_radius * sin(node_angle + radians)
+def pyramid(position: Vector, width: float, grid: int, mass: float, stiffness: float, dampening: float) -> Softbody:
+    height = (sqrt(3) / 2) * width
+    nodes_mesh = []
+    for y in range(grid + 1):
+        nodes_mesh.append([])
+        for x in range(grid + 1 - y):
+            node_mass = mass / ((grid + 1) * (grid + 2) / 2)
+            node_position = Vector(position.x + width * ((x + 0.5 * y) / grid - 0.5),
+                                   position.y + height * (y / grid - 0.5))
+            node = Node(node_mass, node_position)
+            nodes_mesh[y].append(node)
+    links = []
+    for y in range(grid):
+        for x in range(grid - y):
+            links.append(Link((nodes_mesh[y][x], nodes_mesh[y + 1][x]), stiffness, dampening))
+            links.append(Link((nodes_mesh[y][x], nodes_mesh[y][x + 1]), stiffness, dampening))
+            links.append(Link((nodes_mesh[y][-x - 1], nodes_mesh[y + 1][-x - 1]), stiffness, dampening))
+    nodes = [node for buffer in nodes_mesh for node in buffer]
+    softbody = (nodes, links)
+    return structure(softbody, position=Vector(0, 0), rotation=0, scale=1)
 
 
-class Tower(Structure):
-    nodes_mesh: list[list[Node]]
-
-    def __init__(self, position: Vector, width: float, height: float, grid: tuple[int, int], mass: float, stiffness: float, dampening: float) -> None:
-        nodes_mesh = []
-        for x in range(grid[0] + 1):
-            nodes_mesh.append([])
-            for y in range(grid[1] + 1):
-                node_mass = mass / ((grid[0] + 1) * (grid[1] + 1))
-                node_position = Vector(x / grid[0], y / grid[1])
-                node = Node(node_mass, node_position)
-                nodes_mesh[x].append(node)
-        self.nodes_mesh = nodes_mesh
-        links = []
-        for x in range(grid[0]):
-            for y in range(grid[1] + 1):
-                links.append(Link((nodes_mesh[x][y], nodes_mesh[x + 1][y]), stiffness, dampening))
-        for x in range(grid[0] + 1):
-            for y in range(grid[1]):
-                links.append(Link((nodes_mesh[x][y], nodes_mesh[x][y + 1]), stiffness, dampening))
-        for x in range(grid[0]):
-            for y in range(grid[1]):
-                links.append(Link((nodes_mesh[x][y], nodes_mesh[x + 1][y + 1]), stiffness, dampening))
-                links.append(Link((nodes_mesh[x + 1][y], nodes_mesh[x][y + 1]), stiffness, dampening))
-        nodes = [node for buffer in nodes_mesh for node in buffer]
-        super().__init__(nodes, links)
-        self.translate(Vector(-0.5, -0.5))
-        self.scale(Vector(width, height))
-        self.translate(position)
-
-
-class Pyramid(Structure):
-    def __init__(self, position: Vector, width: float, grid: int, mass: float, stiffness: float, dampening: float) -> None:
-        height = (sqrt(3) / 2) * width
-        nodes_mesh = []
-        for y in range(grid + 1):
-            nodes_mesh.append([])
-            for x in range(grid + 1 - y):
-                node_mass = mass / ((grid + 1) * (grid + 2) / 2)
-                node_position = Vector((x + 0.5 * y) / grid, y / grid)
-                node = Node(node_mass, node_position)
-                nodes_mesh[y].append(node)
-        links = []
-        for y in range(grid):
-            for x in range(grid - y):
-                links.append(Link((nodes_mesh[y][x], nodes_mesh[y + 1][x]), stiffness, dampening))
-                links.append(Link((nodes_mesh[y][x], nodes_mesh[y][x + 1]), stiffness, dampening))
-                links.append(Link((nodes_mesh[y][-x - 1], nodes_mesh[y + 1][-x - 1]), stiffness, dampening))
-        nodes = [node for buffer in nodes_mesh for node in buffer]
-        super().__init__(nodes, links)
-        self.translate(Vector(-0.5, -0.5))
-        self.scale(Vector(width, height))
-        self.translate(position)
-
-
-class Wheel(Structure):
-    def __init__(self, position: Vector, radius: float, rings: int, slices: int, mass: float, stiffness: float, dampening: float) -> None:
-        node_mass = mass / (rings * slices + 1)
-        nodes_mesh = [[Node(node_mass, position.copy())]]
-        for r in range(1, rings + 1):
-            nodes_mesh.append([])
-            for s in range(slices):
-                ang = (s / slices) * tau
-                rad = (r / rings) * radius
-                node_position = Vector(rad * cos(ang), rad * sin(ang))
-                node = Node(node_mass, node_position)
-                nodes_mesh[r].append(node)
-        links = []
-        for r in range(1, rings + 1):
-            for s in range(slices):
-                links.append(Link((nodes_mesh[r][s], nodes_mesh[r][(s + 1) % slices]), stiffness, dampening))
+def wheel(position: Vector, radius: float, rings: int, slices: int, mass: float, stiffness: float, dampening: float) -> Softbody:
+    node_mass = mass / (rings * slices + 1)
+    nodes_mesh = [[Node(node_mass, position.copy())]]
+    for r in range(1, rings + 1):
+        nodes_mesh.append([])
+        for s in range(slices):
+            ang = (s / slices) * tau
+            rad = (r / rings) * radius
+            node_position = Vector(position.x + rad * cos(ang),
+                                   position.y + rad * sin(ang))
+            node = Node(node_mass, node_position)
+            nodes_mesh[r].append(node)
+    links = []
+    for r in range(1, rings + 1):
         for s in range(slices):
-            links.append(Link((nodes_mesh[0][0], nodes_mesh[1][s]), stiffness, dampening))
-        for r in range(1, rings):
-            for s in range(slices):
-                links.append(Link((nodes_mesh[r][s], nodes_mesh[r + 1][s]), stiffness, dampening))
-        nodes = [node for buffer in nodes_mesh for node in buffer]
-        super().__init__(nodes, links)
-        self.translate(position)
\ No newline at end of file
+            links.append(Link((nodes_mesh[r][s], nodes_mesh[r][(s + 1) % slices]), stiffness, dampening))
+    for s in range(slices):
+        links.append(Link((nodes_mesh[0][0], nodes_mesh[1][s]), stiffness, dampening))
+    for r in range(1, rings):
+        for s in range(slices):
+            links.append(Link((nodes_mesh[r][s], nodes_mesh[r + 1][s]), stiffness, dampening))
+
+    nodes = [node for buffer in nodes_mesh for node in buffer]
+    softbody = (nodes, links)
+    return structure(softbody, position=Vector(0, 0), scale=1, rotation=0)
\ No newline at end of file

commit 7f238ac7d4553520889397836af78a4aaf7271b3
Author: Daxonus <elias@dobrin.net>
Date:   Sat Apr 23 21:08:54 2022 -0700

    abandon ship

diff --git a/__pycache__/points.cpython-310.pyc b/__pycache__/points.cpython-310.pyc
deleted file mode 100644
index 08d760a..0000000
Binary files a/__pycache__/points.cpython-310.pyc and /dev/null differ
diff --git a/__pycache__/render.cpython-310.pyc b/__pycache__/render.cpython-310.pyc
new file mode 100644
index 0000000..cb717d9
Binary files /dev/null and b/__pycache__/render.cpython-310.pyc differ
diff --git a/__pycache__/softbodies.cpython-310.pyc b/__pycache__/softbodies.cpython-310.pyc
index 129df27..f5addf6 100644
Binary files a/__pycache__/softbodies.cpython-310.pyc and b/__pycache__/softbodies.cpython-310.pyc differ
diff --git a/__pycache__/structures.cpython-310.pyc b/__pycache__/structures.cpython-310.pyc
index 1b39508..e74ab45 100644
Binary files a/__pycache__/structures.cpython-310.pyc and b/__pycache__/structures.cpython-310.pyc differ
diff --git a/__pycache__/test.cpython-310.pyc b/__pycache__/test.cpython-310.pyc
deleted file mode 100644
index 7e91431..0000000
Binary files a/__pycache__/test.cpython-310.pyc and /dev/null differ
diff --git a/__pycache__/vectors.cpython-310.pyc b/__pycache__/vectors.cpython-310.pyc
new file mode 100644
index 0000000..4dac588
Binary files /dev/null and b/__pycache__/vectors.cpython-310.pyc differ
diff --git a/render.py b/render.py
index b7a142d..bffe09d 100644
--- a/render.py
+++ b/render.py
@@ -7,7 +7,7 @@ from softbodies import Node, Link
 from vectors import Vector
 
 
-def render(nodes: list[Node], links: list[Link], camera_position: Vector, camera_zoom: float):
+def render(frames: list[tuple[list[Node], list[Link]]], camera_position: Vector, camera_zoom: float):
     surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 1000, 1000)
     ctx = cairo.Context(surface)
 
@@ -20,21 +20,24 @@ def render(nodes: list[Node], links: list[Link], camera_position: Vector, camera
     ctx.scale(camera_zoom, camera_zoom)
     ctx.translate(-camera_position.x, -camera_position.y)
 
-    for link in links:
-        ctx.move_to(link.nodes[0].position.x, link.nodes[0].position.y)
-        ctx.line_to(link.nodes[1].position.x, link.nodes[1].position.y)
-        ctx.set_source_rgb(0, 0, 0)
-        ctx.set_line_width(0.03 * (link.resting_length / link.get_length()))
-        ctx.set_line_cap(cairo.LINE_CAP_ROUND)
-        ctx.stroke()
-
-    for node in nodes:
-        ctx.arc(node.position.x, node.position.y, 0.03, 0, tau)
-        ctx.set_source_rgb(1, 1, 1)
-        ctx.fill_preserve()
-        ctx.set_source_rgb(0, 0, 0)
-        ctx.set_line_width(0.02)
-        ctx.stroke()
+    for f, frame in enumerate(frames):
+        nodes, links = frame
+        for link in links:
+            ctx.move_to(link.nodes[0].position.x, link.nodes[0].position.y)
+            ctx.line_to(link.nodes[1].position.x, link.nodes[1].position.y)
+            ctx.set_source_rgba(0, 0, 0, 0.1)
+            if f == len(frames) - 1: ctx.set_source_rgb(0, 0, 0)
+            ctx.set_line_width(0.03 * (link.resting_length / link.get_length()))
+            ctx.set_line_cap(cairo.LINE_CAP_ROUND)
+            ctx.stroke()
+        if f != len(frames) - 1: continue
+        for node in nodes:
+            ctx.arc(node.position.x, node.position.y, 0.03, 0, tau)
+            ctx.set_source_rgb(1, 1, 1)
+            ctx.fill_preserve()
+            ctx.set_source_rgba(0, 0, 0, 1)
+            ctx.set_line_width(0.02)
+            ctx.stroke()
 
     raw = surface.get_data().tolist()
     counter = 0
@@ -47,7 +50,7 @@ def render(nodes: list[Node], links: list[Link], camera_position: Vector, camera
             counter += 1
     fig, ax = plt.subplots()
     ax.imshow(image)
-    ax.set_title("Propagated paths from transmitter to receiver")
+    ax.set_title("Softbody simulation sketch")
     plt.show()
 
 if __name__ == "__main__":
diff --git a/soft_box_medium.py b/soft_box_medium.py
new file mode 100644
index 0000000..2fc7b76
--- /dev/null
+++ b/soft_box_medium.py
@@ -0,0 +1,32 @@
+from copy import deepcopy
+from math import pi
+from vectors import Vector
+from structures import Tower
+from render import render
+
+tower = Tower(position=Vector(0, 0), width=1, height=1, grid=(5, 5), mass=1, stiffness=100, dampening=1)
+nodes = tower.nodes
+links = tower.links
+
+frames = []
+
+for i in range(100):
+    for s in range(1):
+        for node in nodes:
+            node.force.set(Vector(0, -9.80665 * node.mass))
+        for link in links:
+            link.nodes[0].force.add(link.get_force() * (link.nodes[0].position - link.nodes[1].position) / Vector.dist(
+                link.nodes[0].position, link.nodes[1].position))
+            link.nodes[1].force.add(link.get_force() * (link.nodes[1].position - link.nodes[0].position) / Vector.dist(
+                link.nodes[0].position, link.nodes[1].position))
+
+        nodes[0].force.set(Vector(0, 0))
+
+        for node in nodes:
+            node.iterate(time=0.005)
+
+    if i % 50 == 0:
+        frame = deepcopy((nodes, links))
+        frames.append(frame)
+
+render(frames, camera_position=Vector(0, 0), camera_zoom=0.5)
\ No newline at end of file
diff --git a/soft_box_small.py b/soft_box_small.py
index 91dd86d..5ba3277 100644
--- a/soft_box_small.py
+++ b/soft_box_small.py
@@ -1,3 +1,4 @@
+from copy import deepcopy
 from math import pi
 from vectors import Vector
 from structures import Tower
@@ -8,6 +9,8 @@ tower.rotate(pi / 2)
 nodes = tower.nodes
 links = tower.links
 
+frames = []
+
 for i in range(100):
     for s in range(1):
         for node in nodes:
@@ -24,4 +27,8 @@ for i in range(100):
         for node in nodes:
             node.iterate(time=0.005)
 
-render(nodes, links, camera_position=Vector(0, 0), camera_zoom=0.5)
\ No newline at end of file
+    if i % 20 == 0:
+        frame = deepcopy((nodes, links))
+        frames.append(frame)
+
+render(frames, camera_position=Vector(0, 0), camera_zoom=0.5)
\ No newline at end of file
diff --git a/soft_pyramid.py b/soft_pyramid.py
new file mode 100644
index 0000000..9b44497
--- /dev/null
+++ b/soft_pyramid.py
@@ -0,0 +1,32 @@
+from copy import deepcopy
+from math import pi
+from vectors import Vector
+from structures import Pyramid
+from render import render
+
+pyramid = Pyramid(position=Vector(0, 0), width=1, grid=5, mass=1, stiffness=100, dampening=1)
+nodes = pyramid.nodes
+links = pyramid.links
+
+frames = []
+
+for i in range(100):
+    for s in range(1):
+        for node in nodes:
+            node.force.set(Vector(0, -9.80665 * node.mass))
+        for link in links:
+            link.nodes[0].force.add(link.get_force() * (link.nodes[0].position - link.nodes[1].position) / Vector.dist(
+                link.nodes[0].position, link.nodes[1].position))
+            link.nodes[1].force.add(link.get_force() * (link.nodes[1].position - link.nodes[0].position) / Vector.dist(
+                link.nodes[0].position, link.nodes[1].position))
+
+        nodes[0].force.set(Vector(0, 0))
+
+        for node in nodes:
+            node.iterate(time=0.005)
+
+    if i % 50 == 0:
+        frame = deepcopy((nodes, links))
+        frames.append(frame)
+
+render(frames, camera_position=Vector(0, 0), camera_zoom=0.5)
\ No newline at end of file
diff --git a/soft_wheel.py b/soft_wheel.py
new file mode 100644
index 0000000..d676484
--- /dev/null
+++ b/soft_wheel.py
@@ -0,0 +1,31 @@
+from copy import deepcopy
+from vectors import Vector
+from structures import Wheel
+from render import render
+
+wheel = Wheel(position=Vector(0, 0), radius=0.5, rings=3, slices=10, mass=1, stiffness=100, dampening=1)
+nodes = wheel.nodes
+links = wheel.links
+
+frames = []
+
+for i in range(100):
+    for s in range(1):
+        for node in nodes:
+            node.force.set(Vector(0, -9.80665 * node.mass))
+        for link in links:
+            link.nodes[0].force.add(link.get_force() * (link.nodes[0].position - link.nodes[1].position) / Vector.dist(
+                link.nodes[0].position, link.nodes[1].position))
+            link.nodes[1].force.add(link.get_force() * (link.nodes[1].position - link.nodes[0].position) / Vector.dist(
+                link.nodes[0].position, link.nodes[1].position))
+
+        nodes[0].force.set(Vector(0, 0))
+
+        for node in nodes:
+            node.iterate(time=0.005)
+
+    if i % 50 == 0:
+        frame = deepcopy((nodes, links))
+        frames.append(frame)
+
+render(frames, camera_position=Vector(0, 0), camera_zoom=0.5)
\ No newline at end of file
diff --git a/structures.py b/structures.py
index 4f29e12..e661162 100644
--- a/structures.py
+++ b/structures.py
@@ -23,6 +23,8 @@ class Structure:
         for node in self.nodes:
             node.position.x *= factor.x
             node.position.y *= factor.y
+        for link in self.links:
+            link.resting_length *= factor.len
 
     def rotate(self, radians: float) -> None:
         for node in self.nodes:

commit daa69d4d4cb229994beec964186e82886176c3b8
Author: Daxonus <elias@dobrin.net>
Date:   Sat Apr 23 18:59:40 2022 -0700

    better rendering utility

diff --git a/render.png b/render.png
deleted file mode 100644
index 2eecdc1..0000000
Binary files a/render.png and /dev/null differ
diff --git a/render.py b/render.py
index 03751f6..b7a142d 100644
--- a/render.py
+++ b/render.py
@@ -1,17 +1,19 @@
 from math import tau
-from scipy.constants import g
+from time import sleep
 import cairo
+import matplotlib.pyplot as plt
+import numpy as np
 from softbodies import Node, Link
 from vectors import Vector
 
 
 def render(nodes: list[Node], links: list[Link], camera_position: Vector, camera_zoom: float):
-    surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 250, 250)
+    surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 1000, 1000)
     ctx = cairo.Context(surface)
 
-    ctx.scale(250, 250)
+    ctx.scale(1000, 1000)
     ctx.rectangle(0, 0, 1, 1)
-    ctx.set_source_rgb(1, 0.94, 0.79)
+    ctx.set_source_rgb(1, 1, 1)
     ctx.fill()
     ctx.translate(0.5, 0.5)
     ctx.scale(1, -1)
@@ -34,4 +36,20 @@ def render(nodes: list[Node], links: list[Link], camera_position: Vector, camera
         ctx.set_line_width(0.02)
         ctx.stroke()
 
-    surface.write_to_png(f"render.png")
+    raw = surface.get_data().tolist()
+    counter = 0
+    image = np.empty((1000, 1000, 3), dtype=np.uint8)
+    for x in range(1000):
+        for y in range(1000):
+            for c in range(3):
+                image[x][y][2 - c] = raw[counter]
+                counter += 1
+            counter += 1
+    fig, ax = plt.subplots()
+    ax.imshow(image)
+    ax.set_title("Propagated paths from transmitter to receiver")
+    plt.show()
+
+if __name__ == "__main__":
+    print("This file is a utility program that does not work on its own.")
+    sleep(5)
diff --git a/soft_box_small.py b/soft_box_small.py
index 93040e3..91dd86d 100644
--- a/soft_box_small.py
+++ b/soft_box_small.py
@@ -1,13 +1,15 @@
+from math import pi
 from vectors import Vector
 from structures import Tower
 from render import render
 
-structure = Tower(position=Vector(0, 0), width=1, height=1, grid=(5, 5), mass=1, stiffness=100, dampening=1)
-nodes = structure.nodes
-links = structure.links
+tower = Tower(position=Vector(0, 0), width=1, height=1, grid=(3, 3), mass=1, stiffness=20, dampening=1)
+tower.rotate(pi / 2)
+nodes = tower.nodes
+links = tower.links
 
 for i in range(100):
-    for s in range(5):
+    for s in range(1):
         for node in nodes:
             node.force.set(Vector(0, -9.80665 * node.mass))
         for link in links:
@@ -15,8 +17,11 @@ for i in range(100):
                 link.nodes[0].position, link.nodes[1].position))
             link.nodes[1].force.add(link.get_force() * (link.nodes[1].position - link.nodes[0].position) / Vector.dist(
                 link.nodes[0].position, link.nodes[1].position))
-        nodes[0].force.set(Vector(0, 0))
+
+        for node in tower.nodes_mesh[0]:
+            node.force.set(Vector(0, 0))
+
         for node in nodes:
-            node.iterate(time=0.001)
+            node.iterate(time=0.005)
 
 render(nodes, links, camera_position=Vector(0, 0), camera_zoom=0.5)
\ No newline at end of file
diff --git a/structures.py b/structures.py
index c947d23..4f29e12 100644
--- a/structures.py
+++ b/structures.py
@@ -33,6 +33,8 @@ class Structure:
 
 
 class Tower(Structure):
+    nodes_mesh: list[list[Node]]
+
     def __init__(self, position: Vector, width: float, height: float, grid: tuple[int, int], mass: float, stiffness: float, dampening: float) -> None:
         nodes_mesh = []
         for x in range(grid[0] + 1):
@@ -42,6 +44,7 @@ class Tower(Structure):
                 node_position = Vector(x / grid[0], y / grid[1])
                 node = Node(node_mass, node_position)
                 nodes_mesh[x].append(node)
+        self.nodes_mesh = nodes_mesh
         links = []
         for x in range(grid[0]):
             for y in range(grid[1] + 1):

commit 5e7c140f1d5536352e117e45dead1a01adac48bf
Author: Daxonus <elias@dobrin.net>
Date:   Sat Apr 23 18:38:32 2022 -0700

    oop working

diff --git a/render.png b/render.png
new file mode 100644
index 0000000..2eecdc1
Binary files /dev/null and b/render.png differ
diff --git a/render.py b/render.py
index 893e009..03751f6 100644
--- a/render.py
+++ b/render.py
@@ -1,13 +1,11 @@
 from math import tau
 from scipy.constants import g
 import cairo
-from structures import Softbody
+from softbodies import Node, Link
 from vectors import Vector
 
 
-def render(softbody: Softbody, camera_position: Vector, camera_zoom: float):
-    nodes, links = softbody
-
+def render(nodes: list[Node], links: list[Link], camera_position: Vector, camera_zoom: float):
     surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 250, 250)
     ctx = cairo.Context(surface)
 
diff --git a/soft_box_small.py b/soft_box_small.py
index f638df4..93040e3 100644
--- a/soft_box_small.py
+++ b/soft_box_small.py
@@ -1,9 +1,10 @@
 from vectors import Vector
-from structures import tower
+from structures import Tower
 from render import render
 
-softbody = tower(position=Vector(0, 0), width=1, height=1, grid=(5, 5), mass=1, stiffness=100, dampening=1)
-nodes, links = softbody
+structure = Tower(position=Vector(0, 0), width=1, height=1, grid=(5, 5), mass=1, stiffness=100, dampening=1)
+nodes = structure.nodes
+links = structure.links
 
 for i in range(100):
     for s in range(5):
@@ -18,4 +19,4 @@ for i in range(100):
         for node in nodes:
             node.iterate(time=0.001)
 
-render(softbody, camera_position=Vector(0, 0), camera_zoom=0.5)
\ No newline at end of file
+render(nodes, links, camera_position=Vector(0, 0), camera_zoom=0.5)
\ No newline at end of file
diff --git a/structures.py b/structures.py
index fdb9b45..c947d23 100644
--- a/structures.py
+++ b/structures.py
@@ -21,7 +21,8 @@ class Structure:
 
     def scale(self, factor: Vector) -> None:
         for node in self.nodes:
-            node.position *= factor
+            node.position.x *= factor.x
+            node.position.y *= factor.y
 
     def rotate(self, radians: float) -> None:
         for node in self.nodes:

commit 9ff61e7a1fe8008179fdd05fee844a3a98674e03
Author: Daxonus <elias@dobrin.net>
Date:   Sat Apr 23 18:26:38 2022 -0700

    object oriented structures code

diff --git a/.gitignore b/.gitignore
index e841d78..833acb2 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,3 +1,3 @@
 venv/
-output/
+render/
 output.mp4
\ No newline at end of file
diff --git a/render.py b/render.py
index 1017608..893e009 100644
--- a/render.py
+++ b/render.py
@@ -1,35 +1,12 @@
-import os
 from math import tau
 from scipy.constants import g
 import cairo
-import ffmpeg
-from structures import tower, pyramid, wheel
+from structures import Softbody
 from vectors import Vector
 
 
-#softbody = tower(position=Vector(0, 0), width=1, height=1, grid=(10, 10), mass=1, stiffness=100, dampening=1)
-softbody = pyramid(position=Vector(0, 0), width=1, grid=6, mass=1, stiffness=100, dampening=1)
-#softbody = wheel(position=Vector(0, 0), radius=0.5, rings=7, slices=10, mass=1, stiffness=400, dampening=1)
-nodes, links = softbody
-
-camera_position = Vector(0, 0)
-camera_zoom = 0.5
-
-
-
-for i in range(500):
-    for s in range(5):
-        for node in nodes:
-            node.force.set(Vector(0, -node.mass * g))
-        for link in links:
-            link.nodes[0].force.add(link.get_force() * (link.nodes[0].position - link.nodes[1].position) / Vector.dist(
-                link.nodes[0].position, link.nodes[1].position))
-            link.nodes[1].force.add(link.get_force() * (link.nodes[1].position - link.nodes[0].position) / Vector.dist(
-                link.nodes[0].position, link.nodes[1].position))
-        nodes[0].force.set(Vector(0, 0))
-        for node in nodes:
-            node.iterate(time=0.001)
-        camera_position = 0.95 * camera_position + 0.05 * nodes[17].position
+def render(softbody: Softbody, camera_position: Vector, camera_zoom: float):
+    nodes, links = softbody
 
     surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 250, 250)
     ctx = cairo.Context(surface)
@@ -59,9 +36,4 @@ for i in range(500):
         ctx.set_line_width(0.02)
         ctx.stroke()
 
-    surface.write_to_png(f"output/{i:06d}.png")
-
-
-ffmpeg.input("output/%06d.png", pattern_type="sequence", framerate=60).output("output.mp4").run(overwrite_output=True)
-for png in os.scandir("output"):
-    os.remove(png)
+    surface.write_to_png(f"render.png")
diff --git a/soft_box_small.py b/soft_box_small.py
new file mode 100644
index 0000000..f638df4
--- /dev/null
+++ b/soft_box_small.py
@@ -0,0 +1,21 @@
+from vectors import Vector
+from structures import tower
+from render import render
+
+softbody = tower(position=Vector(0, 0), width=1, height=1, grid=(5, 5), mass=1, stiffness=100, dampening=1)
+nodes, links = softbody
+
+for i in range(100):
+    for s in range(5):
+        for node in nodes:
+            node.force.set(Vector(0, -9.80665 * node.mass))
+        for link in links:
+            link.nodes[0].force.add(link.get_force() * (link.nodes[0].position - link.nodes[1].position) / Vector.dist(
+                link.nodes[0].position, link.nodes[1].position))
+            link.nodes[1].force.add(link.get_force() * (link.nodes[1].position - link.nodes[0].position) / Vector.dist(
+                link.nodes[0].position, link.nodes[1].position))
+        nodes[0].force.set(Vector(0, 0))
+        for node in nodes:
+            node.iterate(time=0.001)
+
+render(softbody, camera_position=Vector(0, 0), camera_zoom=0.5)
\ No newline at end of file
diff --git a/structures.py b/structures.py
index 9301daa..fdb9b45 100644
--- a/structures.py
+++ b/structures.py
@@ -7,88 +7,103 @@ from vectors import Vector
 Softbody = tuple[list[Node], list[Link]]
 
 
-def structure(softbody: Softbody, position: Vector, scale: float, rotation: float) -> Softbody:
-    nodes, links = softbody
-    for node in nodes:
-        node_angle = atan2(node.position.y, node.position.x)
-        node_radius = node.position.dist(Vector(0, 0))
-        node.position.x = node_radius * cos(node_angle + rotation)
-        node.position.y = node_radius * sin(node_angle + rotation)
-        node.position *= scale
-        node.position += position
-    return nodes, links
+class Structure:
+    nodes: list[Node]
+    links: list[Link]
 
+    def __init__(self, nodes: list[Node], links: list[Link]) -> None:
+        self.nodes = nodes
+        self.links = links
 
-def tower(position: Vector, width: float, height: float, grid: tuple[int, int], mass: float, stiffness: float, dampening: float) -> Softbody:
-    nodes_mesh = []
-    for x in range(grid[0] + 1):
-        nodes_mesh.append([])
-        for y in range(grid[1] + 1):
-            node_mass = mass / ((grid[0] + 1) * (grid[1] + 1))
-            node_position = Vector(position.x + width * (x / grid[0] - 0.5),
-                                   position.y + height * (y / grid[1] - 0.5))
-            node = Node(node_mass, node_position)
-            nodes_mesh[x].append(node)
-    links = []
-    for x in range(grid[0]):
-        for y in range(grid[1] + 1):
-            links.append(Link((nodes_mesh[x][y], nodes_mesh[x + 1][y]), stiffness, dampening))
-    for x in range(grid[0] + 1):
-        for y in range(grid[1]):
-            links.append(Link((nodes_mesh[x][y], nodes_mesh[x][y + 1]), stiffness, dampening))
-    for x in range(grid[0]):
-        for y in range(grid[1]):
-            links.append(Link((nodes_mesh[x][y], nodes_mesh[x + 1][y + 1]), stiffness, dampening))
-            links.append(Link((nodes_mesh[x + 1][y], nodes_mesh[x][y + 1]), stiffness, dampening))
-    nodes = [node for buffer in nodes_mesh for node in buffer]
-    softbody = (nodes, links)
-    return structure(softbody, position=Vector(0, 0), scale=1, rotation=0)
+    def translate(self, translation: Vector) -> None:
+        for node in self.nodes:
+            node.position += translation
 
+    def scale(self, factor: Vector) -> None:
+        for node in self.nodes:
+            node.position *= factor
 
-def pyramid(position: Vector, width: float, grid: int, mass: float, stiffness: float, dampening: float) -> Softbody:
-    height = (sqrt(3) / 2) * width
-    nodes_mesh = []
-    for y in range(grid + 1):
-        nodes_mesh.append([])
-        for x in range(grid + 1 - y):
-            node_mass = mass / ((grid + 1) * (grid + 2) / 2)
-            node_position = Vector(position.x + width * ((x + 0.5 * y) / grid - 0.5),
-                                   position.y + height * (y / grid - 0.5))
-            node = Node(node_mass, node_position)
-            nodes_mesh[y].append(node)
-    links = []
-    for y in range(grid):
-        for x in range(grid - y):
-            links.append(Link((nodes_mesh[y][x], nodes_mesh[y + 1][x]), stiffness, dampening))
-            links.append(Link((nodes_mesh[y][x], nodes_mesh[y][x + 1]), stiffness, dampening))
-            links.append(Link((nodes_mesh[y][-x - 1], nodes_mesh[y + 1][-x - 1]), stiffness, dampening))
-    nodes = [node for buffer in nodes_mesh for node in buffer]
-    softbody = (nodes, links)
-    return structure(softbody, position=Vector(0, 0), rotation=0, scale=1)
+    def rotate(self, radians: float) -> None:
+        for node in self.nodes:
+            node_angle = atan2(node.position.y, node.position.x)
+            node_radius = node.position.dist(Vector(0, 0))
+            node.position.x = node_radius * cos(node_angle + radians)
+            node.position.y = node_radius * sin(node_angle + radians)
 
 
-def wheel(position: Vector, radius: float, rings: int, slices: int, mass: float, stiffness: float, dampening: float) -> Softbody:
-    node_mass = mass / (rings * slices + 1)
-    nodes_mesh = [[Node(node_mass, position.copy())]]
-    for r in range(1, rings + 1):
-        nodes_mesh.append([])
-        for s in range(slices):
-            ang = (s / slices) * tau
-            rad = (r / rings) * radius
-            node_position = Vector(position.x + rad * cos(ang),
-                                   position.y + rad * sin(ang))
-            node = Node(node_mass, node_position)
-            nodes_mesh[r].append(node)
-    links = []
-    for r in range(1, rings + 1):
-        for s in range(slices):
-            links.append(Link((nodes_mesh[r][s], nodes_mesh[r][(s + 1) % slices]), stiffness, dampening))
-    for s in range(slices):
-        links.append(Link((nodes_mesh[0][0], nodes_mesh[1][s]), stiffness, dampening))
-    for r in range(1, rings):
-        for s in range(slices):
-            links.append(Link((nodes_mesh[r][s], nodes_mesh[r + 1][s]), stiffness, dampening))
+class Tower(Structure):
+    def __init__(self, position: Vector, width: float, height: float, grid: tuple[int, int], mass: float, stiffness: float, dampening: float) -> None:
+        nodes_mesh = []
+        for x in range(grid[0] + 1):
+            nodes_mesh.append([])
+            for y in range(grid[1] + 1):
+                node_mass = mass / ((grid[0] + 1) * (grid[1] + 1))
+                node_position = Vector(x / grid[0], y / grid[1])
+                node = Node(node_mass, node_position)
+                nodes_mesh[x].append(node)
+        links = []
+        for x in range(grid[0]):
+            for y in range(grid[1] + 1):
+                links.append(Link((nodes_mesh[x][y], nodes_mesh[x + 1][y]), stiffness, dampening))
+        for x in range(grid[0] + 1):
+            for y in range(grid[1]):
+                links.append(Link((nodes_mesh[x][y], nodes_mesh[x][y + 1]), stiffness, dampening))
+        for x in range(grid[0]):
+            for y in range(grid[1]):
+                links.append(Link((nodes_mesh[x][y], nodes_mesh[x + 1][y + 1]), stiffness, dampening))
+                links.append(Link((nodes_mesh[x + 1][y], nodes_mesh[x][y + 1]), stiffness, dampening))
+        nodes = [node for buffer in nodes_mesh for node in buffer]
+        super().__init__(nodes, links)
+        self.translate(Vector(-0.5, -0.5))
+        self.scale(Vector(width, height))
+        self.translate(position)
+
 
-    nodes = [node for buffer in nodes_mesh for node in buffer]
-    softbody = (nodes, links)
-    return structure(softbody, position=Vector(0, 0), scale=1, rotation=0)
\ No newline at end of file
+class Pyramid(Structure):
+    def __init__(self, position: Vector, width: float, grid: int, mass: float, stiffness: float, dampening: float) -> None:
+        height = (sqrt(3) / 2) * width
+        nodes_mesh = []
+        for y in range(grid + 1):
+            nodes_mesh.append([])
+            for x in range(grid + 1 - y):
+                node_mass = mass / ((grid + 1) * (grid + 2) / 2)
+                node_position = Vector((x + 0.5 * y) / grid, y / grid)
+                node = Node(node_mass, node_position)
+                nodes_mesh[y].append(node)
+        links = []
+        for y in range(grid):
+            for x in range(grid - y):
+                links.append(Link((nodes_mesh[y][x], nodes_mesh[y + 1][x]), stiffness, dampening))
+                links.append(Link((nodes_mesh[y][x], nodes_mesh[y][x + 1]), stiffness, dampening))
+                links.append(Link((nodes_mesh[y][-x - 1], nodes_mesh[y + 1][-x - 1]), stiffness, dampening))
+        nodes = [node for buffer in nodes_mesh for node in buffer]
+        super().__init__(nodes, links)
+        self.translate(Vector(-0.5, -0.5))
+        self.scale(Vector(width, height))
+        self.translate(position)
+
+
+class Wheel(Structure):
+    def __init__(self, position: Vector, radius: float, rings: int, slices: int, mass: float, stiffness: float, dampening: float) -> None:
+        node_mass = mass / (rings * slices + 1)
+        nodes_mesh = [[Node(node_mass, position.copy())]]
+        for r in range(1, rings + 1):
+            nodes_mesh.append([])
+            for s in range(slices):
+                ang = (s / slices) * tau
+                rad = (r / rings) * radius
+                node_position = Vector(rad * cos(ang), rad * sin(ang))
+                node = Node(node_mass, node_position)
+                nodes_mesh[r].append(node)
+        links = []
+        for r in range(1, rings + 1):
+            for s in range(slices):
+                links.append(Link((nodes_mesh[r][s], nodes_mesh[r][(s + 1) % slices]), stiffness, dampening))
+        for s in range(slices):
+            links.append(Link((nodes_mesh[0][0], nodes_mesh[1][s]), stiffness, dampening))
+        for r in range(1, rings):
+            for s in range(slices):
+                links.append(Link((nodes_mesh[r][s], nodes_mesh[r + 1][s]), stiffness, dampening))
+        nodes = [node for buffer in nodes_mesh for node in buffer]
+        super().__init__(nodes, links)
+        self.translate(position)
\ No newline at end of file

commit f650a4dc65d42a9382b18bb5607afd9ac2b60cab
Author: Daxonus <elias@dobrin.net>
Date:   Sat Apr 23 17:34:49 2022 -0700

    removed garbage

diff --git a/bridge.py b/bridge.py
deleted file mode 100644
index 1ff34b1..0000000
--- a/bridge.py
+++ /dev/null
@@ -1,189 +0,0 @@
-from __future__ import annotations
-from math import sqrt
-import numpy as np
-from scipy.constants import g
-import pygame
-from vectors import Vector
-
-
-class System:
-    nodes: list[Node]
-    links: list[Link]
-
-    def __init__(self, nodes: list[Node], links: list[Link]) -> None:
-        self.nodes = nodes
-        self.links = links
-
-    def __str__(self) -> str:
-        return f"Nodes {self.nodes}\nLinks {self.links}"
-
-    def iterate(self, delta_time: float) -> None:
-        for node in self.nodes:
-            node.iterate(delta_time)
-
-
-class Node:
-    mass: float
-    position: Vector
-    velocity: Vector
-    acceleration: Vector
-    force: Vector
-
-    def __init__(self, mass: float, position: Vector, velocity: Vector, acceleration: Vector, force: Vector) -> None:
-        self.mass = mass
-        self.position = position
-        self.velocity = velocity
-        self.acceleration = acceleration
-        self.force = force
-
-    def __repr__(self) -> str:
-        return f"Node{self.position}"
-
-    def update_acceleration(self) -> None:
-        self.acceleration = self.force / self.mass
-
-    def iterate(self, delta_time) -> None:
-        self.update_acceleration()
-        self.velocity += self.acceleration * delta_time
-        self.position += self.velocity * delta_time
-
-
-class Link:
-    nodes: tuple[Node, Node]
-    resting_distance: float
-    actual_distance: float
-    stiffness: float
-    dampening: float
-    actual_speed: float
-
-    def __init__(self, nodes: tuple[Node, Node], resting_distance: float, actual_distance: float, stiffness: float, dampening: float, actual_speed: float) -> None:
-        self.nodes = nodes
-        self.resting_distance = resting_distance
-        self.actual_distance = actual_distance
-        self.stiffness = stiffness
-        self.dampening = dampening
-        self.actual_speed = actual_speed
-
-    def __repr__(self) -> str:
-        return f"{self.nodes[0].position} <- Link -> {self.nodes[1].position}"
-
-    def get_unit_vector(self) -> Vector:
-        return (self.nodes[0].position - self.nodes[1].position) / self.resting_distance
-
-    def get_displacement(self) -> float:
-        return self.actual_distance - self.resting_distance
-
-    def get_stiffness_force(self) -> float:
-        return -self.stiffness * self.get_displacement()
-
-    def get_dampening_force(self) -> float:
-        return -self.dampening * self.actual_speed
-
-    def get_spring_force(self) -> float:
-        return self.get_stiffness_force() + self.get_dampening_force()
-
-    def update_actual_distance(self) -> float:
-        previous_distance = self.actual_distance
-        self.actual_distance = Vector.dist(self.nodes[0].position, self.nodes[1].position)
-        return previous_distance
-
-    def update_actual_speed(self, delta_time: float) -> None:
-        previous_distance = self.update_actual_distance()
-        self.actual_speed = (self.actual_distance - previous_distance) / delta_time
-
-    def apply_forces(self) -> None:
-        self.nodes[0].force += self.get_spring_force() * self.get_unit_vector()
-        self.nodes[1].force -= self.get_spring_force() * self.get_unit_vector()
-
-
-nodes = [Node(mass=10, position=Vector(0, 0), velocity=Vector(0, 0), acceleration=Vector(0, 0), force=Vector(0, 0)),
-         Node(mass=10, position=Vector(1, 0), velocity=Vector(0, 0), acceleration=Vector(0, 0), force=Vector(0, 0)),
-         Node(mass=10, position=Vector(2, 0), velocity=Vector(0, 0), acceleration=Vector(0, 0), force=Vector(0, 0)),
-         Node(mass=10, position=Vector(3, 0), velocity=Vector(0, 0), acceleration=Vector(0, 0), force=Vector(0, 0)),
-         Node(mass=10, position=Vector(4, 0), velocity=Vector(0, 0), acceleration=Vector(0, 0), force=Vector(0, 0)),
-         Node(mass=10, position=Vector(5, 0), velocity=Vector(0, 0), acceleration=Vector(0, 0), force=Vector(0, 0)),
-         Node(mass=10, position=Vector(6, 0), velocity=Vector(0, 0), acceleration=Vector(0, 0), force=Vector(0, 0)),
-         Node(mass=10, position=Vector(7, 0), velocity=Vector(0, 0), acceleration=Vector(0, 0), force=Vector(0, 0)),
-         Node(mass=10, position=Vector(8, 0), velocity=Vector(0, 0), acceleration=Vector(0, 0), force=Vector(0, 0)),
-         Node(mass=10, position=Vector(9, 0), velocity=Vector(0, 0), acceleration=Vector(0, 0), force=Vector(0, 0)),
-         Node(mass=10, position=Vector(10, 0), velocity=Vector(0, 0), acceleration=Vector(0, 0), force=Vector(0, 0)),
-
-         Node(mass=10, position=Vector(0, -2), velocity=Vector(0, 0), acceleration=Vector(0, 0), force=Vector(0, 0)),
-         Node(mass=10, position=Vector(10, -2), velocity=Vector(0, 0), acceleration=Vector(0, 0), force=Vector(0, 0))]
-
-links = [Link(nodes=(nodes[0], nodes[1]), resting_distance=1, actual_distance=1, stiffness=2000, dampening=100, actual_speed=1),
-         Link(nodes=(nodes[1], nodes[2]), resting_distance=1, actual_distance=1, stiffness=2000, dampening=100, actual_speed=1),
-         Link(nodes=(nodes[2], nodes[3]), resting_distance=1, actual_distance=1, stiffness=2000, dampening=100, actual_speed=1),
-         Link(nodes=(nodes[3], nodes[4]), resting_distance=1, actual_distance=1, stiffness=2000, dampening=100, actual_speed=1),
-         Link(nodes=(nodes[4], nodes[5]), resting_distance=1, actual_distance=1, stiffness=2000, dampening=100, actual_speed=1),
-         Link(nodes=(nodes[5], nodes[6]), resting_distance=1, actual_distance=1, stiffness=2000, dampening=100, actual_speed=1),
-         Link(nodes=(nodes[6], nodes[7]), resting_distance=1, actual_distance=1, stiffness=2000, dampening=100, actual_speed=1),
-         Link(nodes=(nodes[7], nodes[8]), resting_distance=1, actual_distance=1, stiffness=2000, dampening=100, actual_speed=1),
-         Link(nodes=(nodes[8], nodes[9]), resting_distance=1, actual_distance=1, stiffness=2000, dampening=100, actual_speed=1),
-         Link(nodes=(nodes[9], nodes[10]), resting_distance=1, actual_distance=1, stiffness=2000, dampening=100, actual_speed=1),
-
-         Link(nodes=(nodes[11], nodes[3]), resting_distance=4, actual_distance=1, stiffness=2000, dampening=100, actual_speed=1),
-         Link(nodes=(nodes[12], nodes[7]), resting_distance=4, actual_distance=1, stiffness=2000, dampening=100, actual_speed=1)]
-
-system = System(nodes=nodes, links=links)
-
-
-iteration = 1
-iterations = 30000
-delta_time = 0.001
-
-
-
-view_minimum = Vector(-2, -6)
-view_maximum = Vector(12, 8)
-
-pygame.init()
-screen = pygame.display.set_mode([500, 500])
-
-def transformed(point: Vector) -> Vector:
-    return Vector(500 * (point.x - view_minimum.x) / (view_maximum.x - view_minimum.x),
-                  500 * (1 - (point.y - view_minimum.y) / (view_maximum.y - view_minimum.y)))
-
-running = True
-
-for i in range(iterations):
-    for node in system.nodes:
-        node.force.set(Vector(0, 0, 0))
-
-    for node in system.nodes:
-        node.force.y -= node.mass * g
-
-    for link in system.links:
-        link.update_actual_speed(delta_time)
-        link.apply_forces()
-
-    for node in system.nodes:
-        node.iterate(delta_time)
-
-    system.nodes[0].position.set(Vector(0, 0))
-    system.nodes[10].position.set(Vector(10, 0))
-    system.nodes[11].position.set(Vector(0, -2))
-    system.nodes[12].position.set(Vector(10, -2))
-
-    for event in pygame.event.get():
-        if event.type == pygame.QUIT:
-            running = False
-
-    if not running:
-        break
-
-    screen.fill((255, 255, 255))
-
-    for link in system.links:
-        t1 = transformed(link.nodes[0].position)
-        t2 = transformed(link.nodes[1].position)
-        pygame.draw.line(screen, (255, 0, 0), (t1.x, t1.y), (t2.x, t2.y), 3)
-
-    for node in system.nodes:
-        t1 = transformed(node.position)
-        pygame.draw.circle(screen, (0, 0, 255), (t1.x, t1.y), 3)
-
-    pygame.display.flip()
-    iteration += 1
-
-pygame.quit()
\ No newline at end of file
diff --git a/cloth_1.py b/cloth_1.py
deleted file mode 100644
index ab4653e..0000000
--- a/cloth_1.py
+++ /dev/null
@@ -1,137 +0,0 @@
-from math import nan, isnan, isqrt
-from time import sleep
-from scipy.constants import g
-import pygame
-from vectors import Vector
-
-cloth_nodes: int = 25
-nodes_references: list[list[int]] = [[y * isqrt(cloth_nodes) + x for x in range(isqrt(cloth_nodes))] for y in range(isqrt(cloth_nodes))]
-
-nodes: int = cloth_nodes
-nodes_mass: list[float] = [1 for n in range(cloth_nodes)]
-nodes_position: list[Vector] = [Vector(x, y) for y in range(isqrt(cloth_nodes)) for x in range(isqrt(cloth_nodes))]
-nodes_velocity: list[Vector] = [Vector(0, 0) for n in range(cloth_nodes)]
-nodes_acceleration: list[Vector] = [Vector(0, 0) for n in range(cloth_nodes)]
-nodes_force: list[Vector] = [Vector(0, 0) for n in range(cloth_nodes)]
-
-links: int = 2 * (isqrt(cloth_nodes) * (isqrt(cloth_nodes) - 1) + (isqrt(cloth_nodes) - 1) ** 2)
-links_nodes: list[tuple[int, int]] = []
-links_resting: list[float] = []
-links_distance: list[float] = []
-links_stiffness: list[float] = []
-links_dampening: list[float] = []
-links_speed: list[float] = []
-
-# Adding horizontal springs
-for y in range(isqrt(cloth_nodes)):
-    for x in range(isqrt(cloth_nodes) - 1):
-        links_nodes.append((nodes_references[y][x], nodes_references[y][x + 1]))
-        links_resting.append(0.9)
-        links_distance.append(1)
-        links_stiffness.append(200)
-        links_dampening.append(5)
-        links_speed.append(0)
-
-# Adding vertical springs
-for x in range(isqrt(cloth_nodes)):
-    for y in range(isqrt(cloth_nodes) - 1):
-        links_nodes.append((nodes_references[y][x], nodes_references[y + 1][x]))
-        links_resting.append(0.9)
-        links_distance.append(1)
-        links_stiffness.append(200)
-        links_dampening.append(5)
-        links_speed.append(0)
-
-# Adding diagonal springs
-for x in range(isqrt(cloth_nodes) - 1):
-    for y in range(isqrt(cloth_nodes) - 1):
-        links_nodes.append((nodes_references[x][y], nodes_references[x + 1][y + 1]))
-        links_resting.append(1.3)
-        links_distance.append(1)
-        links_stiffness.append(200)
-        links_dampening.append(5)
-        links_speed.append(0)
-for x in range(isqrt(cloth_nodes) - 1):
-    for y in range(isqrt(cloth_nodes) - 1):
-        links_nodes.append((nodes_references[x][y + 1], nodes_references[x + 1][y]))
-        links_resting.append(1.3)
-        links_distance.append(1)
-        links_stiffness.append(200)
-        links_dampening.append(5)
-        links_speed.append(0)
-
-iterations: int = 10000
-time_step: float = 0.001
-view_minimum = Vector(-1, -2)
-view_maximum = Vector(6, 5)
-
-
-
-pygame.init()
-screen = pygame.display.set_mode([500, 500])
-
-
-def transform(point: Vector) -> Vector:
-    return Vector(500 * (point.x - view_minimum.x) / (view_maximum.x - view_minimum.x),
-                  500 * (1 - (point.y - view_minimum.y) / (view_maximum.y - view_minimum.y)))
-
-running = True
-
-for i in range(iterations):
-    # Clearing forces
-    for n in range(nodes):
-        nodes_force[n].set(Vector(0, 0))
-
-    # Force of gravity
-    for n in range(nodes):
-        nodes_force[n].y -= nodes_mass[n] * g
-
-    for l in range(links):
-        link_nodes = links_nodes[l]
-        link_distance = Vector.dist(nodes_position[link_nodes[0]], nodes_position[link_nodes[1]])
-
-        # Finding speed of expansion/contraction before distance set
-        links_speed[l] = (link_distance - links_distance[l]) / time_step
-        links_distance[l] = link_distance
-        force_stiffness = -links_stiffness[l] * (link_distance - links_resting[l])
-        force_dampening = links_dampening[l] * links_speed[l]
-        # Force of spring (one-sided)
-        force_spring = (force_stiffness - force_dampening) * (nodes_position[link_nodes[0]] - nodes_position[link_nodes[1]]) / link_distance
-        nodes_force[link_nodes[0]].add(force_spring)
-        nodes_force[link_nodes[1]].sub(force_spring)
-
-    # Integration
-    for n in range(nodes):
-        if n == 24:
-            nodes_force[n].set(Vector(0, 0))
-
-
-        nodes_acceleration[n] = nodes_force[n] / nodes_mass[n]
-        nodes_velocity[n] += nodes_acceleration[n] * time_step
-        nodes_position[n] += nodes_velocity[n] * time_step
-
-    # Conditions
-    # enter here
-
-    for event in pygame.event.get():
-        if event.type == pygame.QUIT:
-            running = False
-
-    if not running:
-        break
-
-    screen.fill((255, 255, 255))
-
-    for l in range(links):
-        link_nodes = links_nodes[l]
-        transformed_1 = transform(nodes_position[link_nodes[0]])
-        transformed_2 = transform(nodes_position[link_nodes[1]])
-        pygame.draw.line(screen, (255, 0, 0), (transformed_1.x, transformed_1.y), (transformed_2.x, transformed_2.y), 3)
-
-    for n in range(nodes):
-        transformed = transform(nodes_position[n])
-        pygame.draw.circle(screen, (0, 0, 255), (transformed.x, transformed.y), 5)
-
-    pygame.display.flip()
-
-pygame.quit()
diff --git a/cloth_2.py b/cloth_2.py
deleted file mode 100644
index cafa3e0..0000000
--- a/cloth_2.py
+++ /dev/null
@@ -1,140 +0,0 @@
-from math import nan, isnan, isqrt, sin
-from time import sleep
-from scipy.constants import g
-import pygame
-from vectors import Vector
-
-cloth_nodes: int = 25
-nodes_references: list[list[int]] = [[y * isqrt(cloth_nodes) + x for x in range(isqrt(cloth_nodes))] for y in range(isqrt(cloth_nodes))]
-
-nodes: int = cloth_nodes
-nodes_mass: list[float] = [1 for n in range(cloth_nodes)]
-nodes_position: list[Vector] = [Vector(x, y) for y in range(isqrt(cloth_nodes)) for x in range(isqrt(cloth_nodes))]
-nodes_velocity: list[Vector] = [Vector(0, 0) for n in range(cloth_nodes)]
-nodes_acceleration: list[Vector] = [Vector(0, 0) for n in range(cloth_nodes)]
-nodes_force: list[Vector] = [Vector(0, 0) for n in range(cloth_nodes)]
-
-links: int = 2 * (isqrt(cloth_nodes) * (isqrt(cloth_nodes) - 1) + (isqrt(cloth_nodes) - 1) ** 2)
-links_nodes: list[tuple[int, int]] = []
-links_resting: list[float] = []
-links_distance: list[float] = []
-links_stiffness: list[float] = []
-links_dampening: list[float] = []
-links_speed: list[float] = []
-
-# Adding horizontal springs
-for y in range(isqrt(cloth_nodes)):
-    for x in range(isqrt(cloth_nodes) - 1):
-        links_nodes.append((nodes_references[y][x], nodes_references[y][x + 1]))
-        links_resting.append(0.9)
-        links_distance.append(1)
-        links_stiffness.append(200)
-        links_dampening.append(30)
-        links_speed.append(0)
-
-# Adding vertical springs
-for x in range(isqrt(cloth_nodes)):
-    for y in range(isqrt(cloth_nodes) - 1):
-        links_nodes.append((nodes_references[y][x], nodes_references[y + 1][x]))
-        links_resting.append(0.9)
-        links_distance.append(1)
-        links_stiffness.append(200)
-        links_dampening.append(30)
-        links_speed.append(0)
-
-# Adding diagonal springs
-for x in range(isqrt(cloth_nodes) - 1):
-    for y in range(isqrt(cloth_nodes) - 1):
-        links_nodes.append((nodes_references[x][y], nodes_references[x + 1][y + 1]))
-        links_resting.append(1.3)
-        links_distance.append(1)
-        links_stiffness.append(200)
-        links_dampening.append(30)
-        links_speed.append(0)
-for x in range(isqrt(cloth_nodes) - 1):
-    for y in range(isqrt(cloth_nodes) - 1):
-        links_nodes.append((nodes_references[x][y + 1], nodes_references[x + 1][y]))
-        links_resting.append(1.3)
-        links_distance.append(1)
-        links_stiffness.append(200)
-        links_dampening.append(30)
-        links_speed.append(0)
-
-iteration: int = 1
-iterations: int = 10000
-time_step: float = 0.001
-view_minimum = Vector(-1, -2)
-view_maximum = Vector(6, 5)
-
-
-
-pygame.init()
-screen = pygame.display.set_mode([500, 500])
-
-
-def transform(point: Vector) -> Vector:
-    return Vector(500 * (point.x - view_minimum.x) / (view_maximum.x - view_minimum.x),
-                  500 * (1 - (point.y - view_minimum.y) / (view_maximum.y - view_minimum.y)))
-
-running = True
-
-for i in range(iterations):
-    # Clearing forces
-    for n in range(nodes):
-        nodes_force[n].set(Vector(0, 0))
-
-    # Force of gravity
-    for n in range(nodes):
-        nodes_force[n].y -= nodes_mass[n] * g
-
-    for l in range(links):
-        link_nodes = links_nodes[l]
-        link_distance = Vector.dist(nodes_position[link_nodes[0]], nodes_position[link_nodes[1]])
-
-        # Finding speed of expansion/contraction before distance set
-        links_speed[l] = (link_distance - links_distance[l]) / time_step
-        links_distance[l] = link_distance
-        force_stiffness = -links_stiffness[l] * (link_distance - links_resting[l])
-        force_dampening = links_dampening[l] * links_speed[l]
-        # Force of spring (one-sided)
-        force_spring = (force_stiffness - force_dampening) * (nodes_position[link_nodes[0]] - nodes_position[link_nodes[1]]) / link_distance
-        nodes_force[link_nodes[0]].add(force_spring)
-        nodes_force[link_nodes[1]].sub(force_spring)
-
-    # Integration
-    for n in range(nodes):
-        if n == 24:
-            nodes_position[n].set(Vector(4 + 2 * sin(0.002 * iteration), 4))
-            continue
-
-        nodes_acceleration[n] = nodes_force[n] / nodes_mass[n]
-        nodes_velocity[n] += nodes_acceleration[n] * time_step
-        nodes_position[n] += nodes_velocity[n] * time_step
-
-    # Conditions
-    # enter here
-
-
-    for event in pygame.event.get():
-        if event.type == pygame.QUIT:
-            running = False
-
-    if not running:
-        break
-
-    screen.fill((255, 255, 255))
-
-    for l in range(links):
-        link_nodes = links_nodes[l]
-        transformed_1 = transform(nodes_position[link_nodes[0]])
-        transformed_2 = transform(nodes_position[link_nodes[1]])
-        pygame.draw.line(screen, (255, 0, 0), (transformed_1.x, transformed_1.y), (transformed_2.x, transformed_2.y), 3)
-
-    for n in range(nodes):
-        transformed = transform(nodes_position[n])
-        pygame.draw.circle(screen, (0, 0, 255), (transformed.x, transformed.y), 5)
-
-    pygame.display.flip()
-    iteration += 1
-
-pygame.quit()
diff --git a/cloth_3.py b/cloth_3.py
deleted file mode 100644
index f00baad..0000000
--- a/cloth_3.py
+++ /dev/null
@@ -1,140 +0,0 @@
-from math import nan, isnan, isqrt, sin, cos
-from time import sleep
-from scipy.constants import g
-import pygame
-from vectors import Vector
-
-cloth_nodes: int = 25
-nodes_references: list[list[int]] = [[y * isqrt(cloth_nodes) + x for x in range(isqrt(cloth_nodes))] for y in range(isqrt(cloth_nodes))]
-
-nodes: int = cloth_nodes
-nodes_mass: list[float] = [1 for n in range(cloth_nodes)]
-nodes_position: list[Vector] = [Vector(x, y) for y in range(isqrt(cloth_nodes)) for x in range(isqrt(cloth_nodes))]
-nodes_velocity: list[Vector] = [Vector(0, 0) for n in range(cloth_nodes)]
-nodes_acceleration: list[Vector] = [Vector(0, 0) for n in range(cloth_nodes)]
-nodes_force: list[Vector] = [Vector(0, 0) for n in range(cloth_nodes)]
-
-links: int = 2 * (isqrt(cloth_nodes) * (isqrt(cloth_nodes) - 1) + (isqrt(cloth_nodes) - 1) ** 2)
-links_nodes: list[tuple[int, int]] = []
-links_resting: list[float] = []
-links_distance: list[float] = []
-links_stiffness: list[float] = []
-links_dampening: list[float] = []
-links_speed: list[float] = []
-
-# Adding horizontal springs
-for y in range(isqrt(cloth_nodes)):
-    for x in range(isqrt(cloth_nodes) - 1):
-        links_nodes.append((nodes_references[y][x], nodes_references[y][x + 1]))
-        links_resting.append(0.9)
-        links_distance.append(1)
-        links_stiffness.append(200)
-        links_dampening.append(50)
-        links_speed.append(0)
-
-# Adding vertical springs
-for x in range(isqrt(cloth_nodes)):
-    for y in range(isqrt(cloth_nodes) - 1):
-        links_nodes.append((nodes_references[y][x], nodes_references[y + 1][x]))
-        links_resting.append(0.9)
-        links_distance.append(1)
-        links_stiffness.append(200)
-        links_dampening.append(50)
-        links_speed.append(0)
-
-# Adding diagonal springs
-for x in range(isqrt(cloth_nodes) - 1):
-    for y in range(isqrt(cloth_nodes) - 1):
-        links_nodes.append((nodes_references[x][y], nodes_references[x + 1][y + 1]))
-        links_resting.append(1.3)
-        links_distance.append(1)
-        links_stiffness.append(200)
-        links_dampening.append(50)
-        links_speed.append(0)
-for x in range(isqrt(cloth_nodes) - 1):
-    for y in range(isqrt(cloth_nodes) - 1):
-        links_nodes.append((nodes_references[x][y + 1], nodes_references[x + 1][y]))
-        links_resting.append(1.3)
-        links_distance.append(1)
-        links_stiffness.append(200)
-        links_dampening.append(50)
-        links_speed.append(0)
-
-iteration: int = 1
-iterations: int = 10000
-time_step: float = 0.001
-view_minimum = Vector(-1, -2)
-view_maximum = Vector(6, 5)
-
-
-
-pygame.init()
-screen = pygame.display.set_mode([500, 500])
-
-
-def transform(point: Vector) -> Vector:
-    return Vector(500 * (point.x - view_minimum.x) / (view_maximum.x - view_minimum.x),
-                  500 * (1 - (point.y - view_minimum.y) / (view_maximum.y - view_minimum.y)))
-
-running = True
-
-for i in range(iterations):
-    # Clearing forces
-    for n in range(nodes):
-        nodes_force[n].set(Vector(0, 0))
-
-    # Force of gravity
-    for n in range(nodes):
-        nodes_force[n].y -= nodes_mass[n] * g
-
-    for l in range(links):
-        link_nodes = links_nodes[l]
-        link_distance = Vector.dist(nodes_position[link_nodes[0]], nodes_position[link_nodes[1]])
-
-        # Finding speed of expansion/contraction before distance set
-        links_speed[l] = (link_distance - links_distance[l]) / time_step
-        links_distance[l] = link_distance
-        force_stiffness = -links_stiffness[l] * (link_distance - links_resting[l])
-        force_dampening = links_dampening[l] * links_speed[l]
-        # Force of spring (one-sided)
-        force_spring = (force_stiffness - force_dampening) * (nodes_position[link_nodes[0]] - nodes_position[link_nodes[1]]) / link_distance
-        nodes_force[link_nodes[0]].add(force_spring)
-        nodes_force[link_nodes[1]].sub(force_spring)
-
-    # Integration
-    for n in range(nodes):
-        if n == 24:
-            nodes_position[n].set(Vector(3 + 1 * cos(0.004 * iteration), 4 + 1 * sin(0.004 * iteration)))
-            continue
-
-        nodes_acceleration[n] = nodes_force[n] / nodes_mass[n]
-        nodes_velocity[n] += nodes_acceleration[n] * time_step
-        nodes_position[n] += nodes_velocity[n] * time_step
-
-    # Conditions
-    # enter here
-
-
-    for event in pygame.event.get():
-        if event.type == pygame.QUIT:
-            running = False
-
-    if not running:
-        break
-
-    screen.fill((255, 255, 255))
-
-    for l in range(links):
-        link_nodes = links_nodes[l]
-        transformed_1 = transform(nodes_position[link_nodes[0]])
-        transformed_2 = transform(nodes_position[link_nodes[1]])
-        pygame.draw.line(screen, (255, 0, 0), (transformed_1.x, transformed_1.y), (transformed_2.x, transformed_2.y), 3)
-
-    for n in range(nodes):
-        transformed = transform(nodes_position[n])
-        pygame.draw.circle(screen, (0, 0, 255), (transformed.x, transformed.y), 5)
-
-    pygame.display.flip()
-    iteration += 1
-
-pygame.quit()
diff --git a/cloth_4.py b/cloth_4.py
deleted file mode 100644
index b861ba6..0000000
--- a/cloth_4.py
+++ /dev/null
@@ -1,140 +0,0 @@
-from math import isqrt
-from time import sleep
-from scipy.constants import g
-import pygame
-from vectors import Vector
-
-cloth_nodes: int = 25
-nodes_references: list[list[int]] = [[y * isqrt(cloth_nodes) + x for x in range(isqrt(cloth_nodes))] for y in range(isqrt(cloth_nodes))]
-
-nodes: int = cloth_nodes
-nodes_mass: list[float] = [1 for n in range(cloth_nodes)]
-nodes_position: list[Vector] = [Vector(x, y) for y in range(isqrt(cloth_nodes)) for x in range(isqrt(cloth_nodes))]
-nodes_velocity: list[Vector] = [Vector(0, 0) for n in range(cloth_nodes)]
-nodes_acceleration: list[Vector] = [Vector(0, 0) for n in range(cloth_nodes)]
-nodes_force: list[Vector] = [Vector(0, 0) for n in range(cloth_nodes)]
-
-links: int = 2 * (isqrt(cloth_nodes) * (isqrt(cloth_nodes) - 1) + (isqrt(cloth_nodes) - 1) ** 2)
-links_nodes: list[tuple[int, int]] = []
-links_resting: list[float] = []
-links_distance: list[float] = []
-links_stiffness: list[float] = []
-links_dampening: list[float] = []
-links_speed: list[float] = []
-
-# Adding horizontal springs
-for y in range(isqrt(cloth_nodes)):
-    for x in range(isqrt(cloth_nodes) - 1):
-        links_nodes.append((nodes_references[y][x], nodes_references[y][x + 1]))
-        links_resting.append(0.9)
-        links_distance.append(1)
-        links_stiffness.append(200)
-        links_dampening.append(0)
-        links_speed.append(0)
-
-# Adding vertical springs
-for x in range(isqrt(cloth_nodes)):
-    for y in range(isqrt(cloth_nodes) - 1):
-        links_nodes.append((nodes_references[y][x], nodes_references[y + 1][x]))
-        links_resting.append(0.9)
-        links_distance.append(1)
-        links_stiffness.append(200)
-        links_dampening.append(0)
-        links_speed.append(0)
-
-# Adding diagonal springs
-for x in range(isqrt(cloth_nodes) - 1):
-    for y in range(isqrt(cloth_nodes) - 1):
-        links_nodes.append((nodes_references[x][y], nodes_references[x + 1][y + 1]))
-        links_resting.append(1.3)
-        links_distance.append(1)
-        links_stiffness.append(200)
-        links_dampening.append(0)
-        links_speed.append(0)
-for x in range(isqrt(cloth_nodes) - 1):
-    for y in range(isqrt(cloth_nodes) - 1):
-        links_nodes.append((nodes_references[x][y + 1], nodes_references[x + 1][y]))
-        links_resting.append(1.3)
-        links_distance.append(1)
-        links_stiffness.append(200)
-        links_dampening.append(0)
-        links_speed.append(0)
-
-iteration: int = 1
-iterations: int = 10000
-time_step: float = 0.001
-view_minimum = Vector(-1, -2)
-view_maximum = Vector(6, 5)
-
-
-
-pygame.init()
-screen = pygame.display.set_mode([500, 500])
-
-
-def transform(point: Vector) -> Vector:
-    return Vector(500 * (point.x - view_minimum.x) / (view_maximum.x - view_minimum.x),
-                  500 * (1 - (point.y - view_minimum.y) / (view_maximum.y - view_minimum.y)))
-
-running = True
-
-for i in range(iterations):
-    # Clearing forces
-    for n in range(nodes):
-        nodes_force[n].set(Vector(0, 0))
-
-    # Force of gravity
-    for n in range(nodes):
-        nodes_force[n].y -= nodes_mass[n] * g
-
-    for l in range(links):
-        link_nodes = links_nodes[l]
-        link_distance = Vector.dist(nodes_position[link_nodes[0]], nodes_position[link_nodes[1]])
-
-        # Finding speed of expansion/contraction before distance set
-        links_speed[l] = (link_distance - links_distance[l]) / time_step
-        links_distance[l] = link_distance
-        force_stiffness = -links_stiffness[l] * (link_distance - links_resting[l])
-        force_dampening = links_dampening[l] * links_speed[l]
-        # Force of spring (one-sided)
-        force_spring = (force_stiffness - force_dampening) * (nodes_position[link_nodes[0]] - nodes_position[link_nodes[1]]) / link_distance
-        nodes_force[link_nodes[0]].add(force_spring)
-        nodes_force[link_nodes[1]].sub(force_spring)
-
-    # Integration
-    for n in range(nodes):
-        if n == 24:
-            nodes_position[n].set(Vector(4, 4))
-            continue
-
-        nodes_acceleration[n] = nodes_force[n] / nodes_mass[n]
-        nodes_velocity[n] += nodes_acceleration[n] * time_step
-        nodes_position[n] += nodes_velocity[n] * time_step
-
-    # Conditions
-    # enter here
-
-
-    for event in pygame.event.get():
-        if event.type == pygame.QUIT:
-            running = False
-
-    if not running:
-        break
-
-    screen.fill((255, 255, 255))
-
-    for l in range(links):
-        link_nodes = links_nodes[l]
-        transformed_1 = transform(nodes_position[link_nodes[0]])
-        transformed_2 = transform(nodes_position[link_nodes[1]])
-        pygame.draw.line(screen, (255, 0, 0), (transformed_1.x, transformed_1.y), (transformed_2.x, transformed_2.y), 3)
-
-    for n in range(nodes):
-        transformed = transform(nodes_position[n])
-        pygame.draw.circle(screen, (0, 0, 255), (transformed.x, transformed.y), 5)
-
-    pygame.display.flip()
-    iteration += 1
-
-pygame.quit()
diff --git a/dump.py b/dump.py
deleted file mode 100644
index a38bc8d..0000000
--- a/dump.py
+++ /dev/null
@@ -1,28 +0,0 @@
-from test import softbody
-from rich.console import Console
-from rich.table import Table
-
-console = Console()
-
-table = Table(show_header=True, header_style="bold magenta")
-table.add_column("Date", style="dim", width=12)
-table.add_column("Title")
-table.add_column("Production Budget", justify="right")
-table.add_column("Box Office", justify="right")
-table.add_row(
-    "Dec 20, 2019", "Star Wars: The Rise of Skywalker", "$275,000,000", "$375,126,118"
-)
-table.add_row(
-    "May 25, 2018",
-    "[red]Solo[/red]: A Star Wars Story",
-    "$275,000,000",
-    "$393,151,347",
-)
-table.add_row(
-    "Dec 15, 2017",
-    "Star Wars Ep. VIII: The Last Jedi",
-    "$262,000,000",
-    "[bold]$1,332,539,889[/bold]",
-)
-
-console.print(table)
\ No newline at end of file
diff --git a/render.py b/render.py
index c8284d8..1017608 100644
--- a/render.py
+++ b/render.py
@@ -7,9 +7,9 @@ from structures import tower, pyramid, wheel
 from vectors import Vector
 
 
-softbody = tower(position=Vector(0, 0), width=1, height=1, grid=(5, 5), mass=1, stiffness=100, dampening=1)
+#softbody = tower(position=Vector(0, 0), width=1, height=1, grid=(10, 10), mass=1, stiffness=100, dampening=1)
 softbody = pyramid(position=Vector(0, 0), width=1, grid=6, mass=1, stiffness=100, dampening=1)
-softbody = wheel(position=Vector(0, 0), radius=0.5, rings=3, slices=10, mass=1, stiffness=100, dampening=1)
+#softbody = wheel(position=Vector(0, 0), radius=0.5, rings=7, slices=10, mass=1, stiffness=400, dampening=1)
 nodes, links = softbody
 
 camera_position = Vector(0, 0)
@@ -17,15 +17,19 @@ camera_zoom = 0.5
 
 
 
-for i in range(100):
-    for node in nodes:
-        node.force.set(Vector(0, -node.mass * g))
-    for link in links:
-        link.nodes[0].force.add(link.get_force() * (link.nodes[0].position - link.nodes[1].position) / Vector.dist(link.nodes[0].position, link.nodes[1].position))
-        link.nodes[1].force.add(link.get_force() * (link.nodes[1].position - link.nodes[0].position) / Vector.dist(link.nodes[0].position, link.nodes[1].position))
-    nodes[0].force.set(Vector(0, 0))
-    for node in nodes:
-        node.iterate(time=0.005)
+for i in range(500):
+    for s in range(5):
+        for node in nodes:
+            node.force.set(Vector(0, -node.mass * g))
+        for link in links:
+            link.nodes[0].force.add(link.get_force() * (link.nodes[0].position - link.nodes[1].position) / Vector.dist(
+                link.nodes[0].position, link.nodes[1].position))
+            link.nodes[1].force.add(link.get_force() * (link.nodes[1].position - link.nodes[0].position) / Vector.dist(
+                link.nodes[0].position, link.nodes[1].position))
+        nodes[0].force.set(Vector(0, 0))
+        for node in nodes:
+            node.iterate(time=0.001)
+        camera_position = 0.95 * camera_position + 0.05 * nodes[17].position
 
     surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 250, 250)
     ctx = cairo.Context(surface)

commit 338cc61be0339597142c1d52c8d46ae328605cf1
Author: Daxonus <elias@dobrin.net>
Date:   Sat Apr 23 15:45:03 2022 -0700

    made wheel structure :))))

diff --git a/render.py b/render.py
index 5dfbb59..c8284d8 100644
--- a/render.py
+++ b/render.py
@@ -3,12 +3,13 @@ from math import tau
 from scipy.constants import g
 import cairo
 import ffmpeg
-from structures import tower, pyramid, blob
+from structures import tower, pyramid, wheel
 from vectors import Vector
 
 
 softbody = tower(position=Vector(0, 0), width=1, height=1, grid=(5, 5), mass=1, stiffness=100, dampening=1)
 softbody = pyramid(position=Vector(0, 0), width=1, grid=6, mass=1, stiffness=100, dampening=1)
+softbody = wheel(position=Vector(0, 0), radius=0.5, rings=3, slices=10, mass=1, stiffness=100, dampening=1)
 nodes, links = softbody
 
 camera_position = Vector(0, 0)
diff --git a/structures.py b/structures.py
index 839a1cc..9301daa 100644
--- a/structures.py
+++ b/structures.py
@@ -27,7 +27,8 @@ def tower(position: Vector, width: float, height: float, grid: tuple[int, int],
             node_mass = mass / ((grid[0] + 1) * (grid[1] + 1))
             node_position = Vector(position.x + width * (x / grid[0] - 0.5),
                                    position.y + height * (y / grid[1] - 0.5))
-            nodes_mesh[x].append(Node(node_mass, node_position))
+            node = Node(node_mass, node_position)
+            nodes_mesh[x].append(node)
     links = []
     for x in range(grid[0]):
         for y in range(grid[1] + 1):
@@ -53,7 +54,8 @@ def pyramid(position: Vector, width: float, grid: int, mass: float, stiffness: f
             node_mass = mass / ((grid + 1) * (grid + 2) / 2)
             node_position = Vector(position.x + width * ((x + 0.5 * y) / grid - 0.5),
                                    position.y + height * (y / grid - 0.5))
-            nodes_mesh[y].append(Node(node_mass, node_position))
+            node = Node(node_mass, node_position)
+            nodes_mesh[y].append(node)
     links = []
     for y in range(grid):
         for x in range(grid - y):
@@ -62,6 +64,31 @@ def pyramid(position: Vector, width: float, grid: int, mass: float, stiffness: f
             links.append(Link((nodes_mesh[y][-x - 1], nodes_mesh[y + 1][-x - 1]), stiffness, dampening))
     nodes = [node for buffer in nodes_mesh for node in buffer]
     softbody = (nodes, links)
-    return structure(softbody, position, rotation=0, scale=1)
+    return structure(softbody, position=Vector(0, 0), rotation=0, scale=1)
 
 
+def wheel(position: Vector, radius: float, rings: int, slices: int, mass: float, stiffness: float, dampening: float) -> Softbody:
+    node_mass = mass / (rings * slices + 1)
+    nodes_mesh = [[Node(node_mass, position.copy())]]
+    for r in range(1, rings + 1):
+        nodes_mesh.append([])
+        for s in range(slices):
+            ang = (s / slices) * tau
+            rad = (r / rings) * radius
+            node_position = Vector(position.x + rad * cos(ang),
+                                   position.y + rad * sin(ang))
+            node = Node(node_mass, node_position)
+            nodes_mesh[r].append(node)
+    links = []
+    for r in range(1, rings + 1):
+        for s in range(slices):
+            links.append(Link((nodes_mesh[r][s], nodes_mesh[r][(s + 1) % slices]), stiffness, dampening))
+    for s in range(slices):
+        links.append(Link((nodes_mesh[0][0], nodes_mesh[1][s]), stiffness, dampening))
+    for r in range(1, rings):
+        for s in range(slices):
+            links.append(Link((nodes_mesh[r][s], nodes_mesh[r + 1][s]), stiffness, dampening))
+
+    nodes = [node for buffer in nodes_mesh for node in buffer]
+    softbody = (nodes, links)
+    return structure(softbody, position=Vector(0, 0), scale=1, rotation=0)
\ No newline at end of file

commit b1b9924303a3077cc50c4c8b9d280b411d601065
Author: Daxonus <elias@dobrin.net>
Date:   Sat Apr 23 15:10:28 2022 -0700

    pyramid mesh working and reworked

diff --git a/render.py b/render.py
index 4ddc8d9..5dfbb59 100644
--- a/render.py
+++ b/render.py
@@ -7,8 +7,8 @@ from structures import tower, pyramid, blob
 from vectors import Vector
 
 
-softbody = tower(position=Vector(0, 0), size=(1, 1), grid=(5, 5), mass=1, stiffness=100, dampening=1)
-# softbody = pyramid(position=Point(0, 0), size=(1, 1), grid=4, mass=1, stiffness=100, dampening=0)
+softbody = tower(position=Vector(0, 0), width=1, height=1, grid=(5, 5), mass=1, stiffness=100, dampening=1)
+softbody = pyramid(position=Vector(0, 0), width=1, grid=6, mass=1, stiffness=100, dampening=1)
 nodes, links = softbody
 
 camera_position = Vector(0, 0)
@@ -16,7 +16,7 @@ camera_zoom = 0.5
 
 
 
-for i in range(500):
+for i in range(100):
     for node in nodes:
         node.force.set(Vector(0, -node.mass * g))
     for link in links:
@@ -35,8 +35,8 @@ for i in range(500):
     ctx.fill()
     ctx.translate(0.5, 0.5)
     ctx.scale(1, -1)
-    ctx.translate(-camera_position.x, -camera_position.y)
     ctx.scale(camera_zoom, camera_zoom)
+    ctx.translate(-camera_position.x, -camera_position.y)
 
     for link in links:
         ctx.move_to(link.nodes[0].position.x, link.nodes[0].position.y)
diff --git a/structures.py b/structures.py
index 4554961..839a1cc 100644
--- a/structures.py
+++ b/structures.py
@@ -1,7 +1,6 @@
 from __future__ import annotations
 from math import sqrt, cos, sin, atan2, tau
 from random import random
-from typing import NewType
 from softbodies import Node, Link
 from vectors import Vector
 
@@ -20,14 +19,14 @@ def structure(softbody: Softbody, position: Vector, scale: float, rotation: floa
     return nodes, links
 
 
-def tower(position: Vector, size: tuple[float, float], grid: tuple[int, int], mass: float, stiffness: float, dampening: float) -> Softbody:
+def tower(position: Vector, width: float, height: float, grid: tuple[int, int], mass: float, stiffness: float, dampening: float) -> Softbody:
     nodes_mesh = []
     for x in range(grid[0] + 1):
         nodes_mesh.append([])
         for y in range(grid[1] + 1):
             node_mass = mass / ((grid[0] + 1) * (grid[1] + 1))
-            node_position = Vector(size[0] * (x / grid[0] - 0.5),
-                                   size[1] * (y / grid[1] - 0.5))
+            node_position = Vector(position.x + width * (x / grid[0] - 0.5),
+                                   position.y + height * (y / grid[1] - 0.5))
             nodes_mesh[x].append(Node(node_mass, node_position))
     links = []
     for x in range(grid[0]):
@@ -39,47 +38,30 @@ def tower(position: Vector, size: tuple[float, float], grid: tuple[int, int], ma
     for x in range(grid[0]):
         for y in range(grid[1]):
             links.append(Link((nodes_mesh[x][y], nodes_mesh[x + 1][y + 1]), stiffness, dampening))
-    for x in range(grid[0]):
-        for y in range(grid[1]):
             links.append(Link((nodes_mesh[x + 1][y], nodes_mesh[x][y + 1]), stiffness, dampening))
     nodes = [node for buffer in nodes_mesh for node in buffer]
-    return structure((nodes, links), position, 1, 0)
+    softbody = (nodes, links)
+    return structure(softbody, position=Vector(0, 0), scale=1, rotation=0)
 
 
-def pyramid(position: Vector, size: tuple[float, float], grid: int, mass: float, stiffness: float, dampening: float) -> Softbody:
+def pyramid(position: Vector, width: float, grid: int, mass: float, stiffness: float, dampening: float) -> Softbody:
+    height = (sqrt(3) / 2) * width
     nodes_mesh = []
     for y in range(grid + 1):
         nodes_mesh.append([])
         for x in range(grid + 1 - y):
             node_mass = mass / ((grid + 1) * (grid + 2) / 2)
-            node_position = Vector(-size[0] / 2 + x, -size[1] / 2 + y)
+            node_position = Vector(position.x + width * ((x + 0.5 * y) / grid - 0.5),
+                                   position.y + height * (y / grid - 0.5))
             nodes_mesh[y].append(Node(node_mass, node_position))
     links = []
-    for y in range(grid + 1):
-        for x in range(grid - y):
-            links.append(Link((nodes_mesh[y][x], nodes_mesh[y][x + 1]), stiffness, dampening))
     for y in range(grid):
         for x in range(grid - y):
             links.append(Link((nodes_mesh[y][x], nodes_mesh[y + 1][x]), stiffness, dampening))
-    for y in range(grid):
-        for x in range(grid - y):
-            links.append(Link((nodes_mesh[y][x + 1], nodes_mesh[y + 1][x]), stiffness, dampening))
+            links.append(Link((nodes_mesh[y][x], nodes_mesh[y][x + 1]), stiffness, dampening))
+            links.append(Link((nodes_mesh[y][-x - 1], nodes_mesh[y + 1][-x - 1]), stiffness, dampening))
     nodes = [node for buffer in nodes_mesh for node in buffer]
-    return structure((nodes, links), position, rotation=0, scale=1)
+    softbody = (nodes, links)
+    return structure(softbody, position, rotation=0, scale=1)
 
 
-def blob(position: Vector, size: float) -> Softbody:
-    nodes = []
-    for n in range(30):
-        radius = (size / 2) * sqrt(random())
-        angle = tau * random()
-        nodes.append(Node(mass=1, position=Vector(position.x + radius * cos(angle), position.y + radius * sin(angle))))
-    links = []
-    for n1 in range(30):
-        for n2 in range(n1 + 1, 30):
-            node_1 = nodes[n1]
-            node_2 = nodes[n2]
-
-            if Vector.dist(node_1.position, node_2.position) <= size / 5:
-                links.append(Link(nodes=(node_1, node_2), stiffness=200, dampening=0))
-    return structure((nodes, links), position, rotation=0, scale=1)

commit dcf6d10e6c8002b5671fbc4aeb44c68ab24b480e
Author: Daxonus <elias@dobrin.net>
Date:   Fri Apr 22 11:45:39 2022 -0700

    renamed some stuff

diff --git a/bridge.py b/bridge.py
index 76682d6..1ff34b1 100644
--- a/bridge.py
+++ b/bridge.py
@@ -3,7 +3,7 @@ from math import sqrt
 import numpy as np
 from scipy.constants import g
 import pygame
-from points import Point
+from vectors import Vector
 
 
 class System:
@@ -24,12 +24,12 @@ class System:
 
 class Node:
     mass: float
-    position: Point
-    velocity: Point
-    acceleration: Point
-    force: Point
+    position: Vector
+    velocity: Vector
+    acceleration: Vector
+    force: Vector
 
-    def __init__(self, mass: float, position: Point, velocity: Point, acceleration: Point, force: Point) -> None:
+    def __init__(self, mass: float, position: Vector, velocity: Vector, acceleration: Vector, force: Vector) -> None:
         self.mass = mass
         self.position = position
         self.velocity = velocity
@@ -67,7 +67,7 @@ class Link:
     def __repr__(self) -> str:
         return f"{self.nodes[0].position} <- Link -> {self.nodes[1].position}"
 
-    def get_unit_vector(self) -> Point:
+    def get_unit_vector(self) -> Vector:
         return (self.nodes[0].position - self.nodes[1].position) / self.resting_distance
 
     def get_displacement(self) -> float:
@@ -84,7 +84,7 @@ class Link:
 
     def update_actual_distance(self) -> float:
         previous_distance = self.actual_distance
-        self.actual_distance = Point.dist(self.nodes[0].position, self.nodes[1].position)
+        self.actual_distance = Vector.dist(self.nodes[0].position, self.nodes[1].position)
         return previous_distance
 
     def update_actual_speed(self, delta_time: float) -> None:
@@ -96,20 +96,20 @@ class Link:
         self.nodes[1].force -= self.get_spring_force() * self.get_unit_vector()
 
 
-nodes = [Node(mass=10, position=Point(0, 0), velocity=Point(0, 0), acceleration=Point(0, 0), force=Point(0, 0)),
-         Node(mass=10, position=Point(1, 0), velocity=Point(0, 0), acceleration=Point(0, 0), force=Point(0, 0)),
-         Node(mass=10, position=Point(2, 0), velocity=Point(0, 0), acceleration=Point(0, 0), force=Point(0, 0)),
-         Node(mass=10, position=Point(3, 0), velocity=Point(0, 0), acceleration=Point(0, 0), force=Point(0, 0)),
-         Node(mass=10, position=Point(4, 0), velocity=Point(0, 0), acceleration=Point(0, 0), force=Point(0, 0)),
-         Node(mass=10, position=Point(5, 0), velocity=Point(0, 0), acceleration=Point(0, 0), force=Point(0, 0)),
-         Node(mass=10, position=Point(6, 0), velocity=Point(0, 0), acceleration=Point(0, 0), force=Point(0, 0)),
-         Node(mass=10, position=Point(7, 0), velocity=Point(0, 0), acceleration=Point(0, 0), force=Point(0, 0)),
-         Node(mass=10, position=Point(8, 0), velocity=Point(0, 0), acceleration=Point(0, 0), force=Point(0, 0)),
-         Node(mass=10, position=Point(9, 0), velocity=Point(0, 0), acceleration=Point(0, 0), force=Point(0, 0)),
-         Node(mass=10, position=Point(10, 0), velocity=Point(0, 0), acceleration=Point(0, 0), force=Point(0, 0)),
+nodes = [Node(mass=10, position=Vector(0, 0), velocity=Vector(0, 0), acceleration=Vector(0, 0), force=Vector(0, 0)),
+         Node(mass=10, position=Vector(1, 0), velocity=Vector(0, 0), acceleration=Vector(0, 0), force=Vector(0, 0)),
+         Node(mass=10, position=Vector(2, 0), velocity=Vector(0, 0), acceleration=Vector(0, 0), force=Vector(0, 0)),
+         Node(mass=10, position=Vector(3, 0), velocity=Vector(0, 0), acceleration=Vector(0, 0), force=Vector(0, 0)),
+         Node(mass=10, position=Vector(4, 0), velocity=Vector(0, 0), acceleration=Vector(0, 0), force=Vector(0, 0)),
+         Node(mass=10, position=Vector(5, 0), velocity=Vector(0, 0), acceleration=Vector(0, 0), force=Vector(0, 0)),
+         Node(mass=10, position=Vector(6, 0), velocity=Vector(0, 0), acceleration=Vector(0, 0), force=Vector(0, 0)),
+         Node(mass=10, position=Vector(7, 0), velocity=Vector(0, 0), acceleration=Vector(0, 0), force=Vector(0, 0)),
+         Node(mass=10, position=Vector(8, 0), velocity=Vector(0, 0), acceleration=Vector(0, 0), force=Vector(0, 0)),
+         Node(mass=10, position=Vector(9, 0), velocity=Vector(0, 0), acceleration=Vector(0, 0), force=Vector(0, 0)),
+         Node(mass=10, position=Vector(10, 0), velocity=Vector(0, 0), acceleration=Vector(0, 0), force=Vector(0, 0)),
 
-         Node(mass=10, position=Point(0, -2), velocity=Point(0, 0), acceleration=Point(0, 0), force=Point(0, 0)),
-         Node(mass=10, position=Point(10, -2), velocity=Point(0, 0), acceleration=Point(0, 0), force=Point(0, 0))]
+         Node(mass=10, position=Vector(0, -2), velocity=Vector(0, 0), acceleration=Vector(0, 0), force=Vector(0, 0)),
+         Node(mass=10, position=Vector(10, -2), velocity=Vector(0, 0), acceleration=Vector(0, 0), force=Vector(0, 0))]
 
 links = [Link(nodes=(nodes[0], nodes[1]), resting_distance=1, actual_distance=1, stiffness=2000, dampening=100, actual_speed=1),
          Link(nodes=(nodes[1], nodes[2]), resting_distance=1, actual_distance=1, stiffness=2000, dampening=100, actual_speed=1),
@@ -134,21 +134,21 @@ delta_time = 0.001
 
 
 
-view_minimum = Point(-2, -6)
-view_maximum = Point(12, 8)
+view_minimum = Vector(-2, -6)
+view_maximum = Vector(12, 8)
 
 pygame.init()
 screen = pygame.display.set_mode([500, 500])
 
-def transformed(point: Point) -> Point:
-    return Point(500 * (point.x - view_minimum.x) / (view_maximum.x - view_minimum.x),
-                 500 * (1 - (point.y - view_minimum.y) / (view_maximum.y - view_minimum.y)))
+def transformed(point: Vector) -> Vector:
+    return Vector(500 * (point.x - view_minimum.x) / (view_maximum.x - view_minimum.x),
+                  500 * (1 - (point.y - view_minimum.y) / (view_maximum.y - view_minimum.y)))
 
 running = True
 
 for i in range(iterations):
     for node in system.nodes:
-        node.force.set(Point(0, 0, 0))
+        node.force.set(Vector(0, 0, 0))
 
     for node in system.nodes:
         node.force.y -= node.mass * g
@@ -160,10 +160,10 @@ for i in range(iterations):
     for node in system.nodes:
         node.iterate(delta_time)
 
-    system.nodes[0].position.set(Point(0, 0))
-    system.nodes[10].position.set(Point(10, 0))
-    system.nodes[11].position.set(Point(0, -2))
-    system.nodes[12].position.set(Point(10, -2))
+    system.nodes[0].position.set(Vector(0, 0))
+    system.nodes[10].position.set(Vector(10, 0))
+    system.nodes[11].position.set(Vector(0, -2))
+    system.nodes[12].position.set(Vector(10, -2))
 
     for event in pygame.event.get():
         if event.type == pygame.QUIT:
diff --git a/cloth_1.py b/cloth_1.py
index ae82891..ab4653e 100644
--- a/cloth_1.py
+++ b/cloth_1.py
@@ -2,17 +2,17 @@ from math import nan, isnan, isqrt
 from time import sleep
 from scipy.constants import g
 import pygame
-from points import Point
+from vectors import Vector
 
 cloth_nodes: int = 25
 nodes_references: list[list[int]] = [[y * isqrt(cloth_nodes) + x for x in range(isqrt(cloth_nodes))] for y in range(isqrt(cloth_nodes))]
 
 nodes: int = cloth_nodes
 nodes_mass: list[float] = [1 for n in range(cloth_nodes)]
-nodes_position: list[Point] = [Point(x, y) for y in range(isqrt(cloth_nodes)) for x in range(isqrt(cloth_nodes))]
-nodes_velocity: list[Point] = [Point(0, 0) for n in range(cloth_nodes)]
-nodes_acceleration: list[Point] = [Point(0, 0) for n in range(cloth_nodes)]
-nodes_force: list[Point] = [Point(0, 0) for n in range(cloth_nodes)]
+nodes_position: list[Vector] = [Vector(x, y) for y in range(isqrt(cloth_nodes)) for x in range(isqrt(cloth_nodes))]
+nodes_velocity: list[Vector] = [Vector(0, 0) for n in range(cloth_nodes)]
+nodes_acceleration: list[Vector] = [Vector(0, 0) for n in range(cloth_nodes)]
+nodes_force: list[Vector] = [Vector(0, 0) for n in range(cloth_nodes)]
 
 links: int = 2 * (isqrt(cloth_nodes) * (isqrt(cloth_nodes) - 1) + (isqrt(cloth_nodes) - 1) ** 2)
 links_nodes: list[tuple[int, int]] = []
@@ -62,8 +62,8 @@ for x in range(isqrt(cloth_nodes) - 1):
 
 iterations: int = 10000
 time_step: float = 0.001
-view_minimum = Point(-1, -2)
-view_maximum = Point(6, 5)
+view_minimum = Vector(-1, -2)
+view_maximum = Vector(6, 5)
 
 
 
@@ -71,16 +71,16 @@ pygame.init()
 screen = pygame.display.set_mode([500, 500])
 
 
-def transform(point: Point) -> Point:
-    return Point(500 * (point.x - view_minimum.x) / (view_maximum.x - view_minimum.x),
-                 500 * (1 - (point.y - view_minimum.y) / (view_maximum.y - view_minimum.y)))
+def transform(point: Vector) -> Vector:
+    return Vector(500 * (point.x - view_minimum.x) / (view_maximum.x - view_minimum.x),
+                  500 * (1 - (point.y - view_minimum.y) / (view_maximum.y - view_minimum.y)))
 
 running = True
 
 for i in range(iterations):
     # Clearing forces
     for n in range(nodes):
-        nodes_force[n].set(Point(0, 0))
+        nodes_force[n].set(Vector(0, 0))
 
     # Force of gravity
     for n in range(nodes):
@@ -88,7 +88,7 @@ for i in range(iterations):
 
     for l in range(links):
         link_nodes = links_nodes[l]
-        link_distance = Point.dist(nodes_position[link_nodes[0]], nodes_position[link_nodes[1]])
+        link_distance = Vector.dist(nodes_position[link_nodes[0]], nodes_position[link_nodes[1]])
 
         # Finding speed of expansion/contraction before distance set
         links_speed[l] = (link_distance - links_distance[l]) / time_step
@@ -103,7 +103,7 @@ for i in range(iterations):
     # Integration
     for n in range(nodes):
         if n == 24:
-            nodes_force[n].set(Point(0, 0))
+            nodes_force[n].set(Vector(0, 0))
 
 
         nodes_acceleration[n] = nodes_force[n] / nodes_mass[n]
diff --git a/cloth_2.py b/cloth_2.py
index 858bb5d..cafa3e0 100644
--- a/cloth_2.py
+++ b/cloth_2.py
@@ -2,17 +2,17 @@ from math import nan, isnan, isqrt, sin
 from time import sleep
 from scipy.constants import g
 import pygame
-from points import Point
+from vectors import Vector
 
 cloth_nodes: int = 25
 nodes_references: list[list[int]] = [[y * isqrt(cloth_nodes) + x for x in range(isqrt(cloth_nodes))] for y in range(isqrt(cloth_nodes))]
 
 nodes: int = cloth_nodes
 nodes_mass: list[float] = [1 for n in range(cloth_nodes)]
-nodes_position: list[Point] = [Point(x, y) for y in range(isqrt(cloth_nodes)) for x in range(isqrt(cloth_nodes))]
-nodes_velocity: list[Point] = [Point(0, 0) for n in range(cloth_nodes)]
-nodes_acceleration: list[Point] = [Point(0, 0) for n in range(cloth_nodes)]
-nodes_force: list[Point] = [Point(0, 0) for n in range(cloth_nodes)]
+nodes_position: list[Vector] = [Vector(x, y) for y in range(isqrt(cloth_nodes)) for x in range(isqrt(cloth_nodes))]
+nodes_velocity: list[Vector] = [Vector(0, 0) for n in range(cloth_nodes)]
+nodes_acceleration: list[Vector] = [Vector(0, 0) for n in range(cloth_nodes)]
+nodes_force: list[Vector] = [Vector(0, 0) for n in range(cloth_nodes)]
 
 links: int = 2 * (isqrt(cloth_nodes) * (isqrt(cloth_nodes) - 1) + (isqrt(cloth_nodes) - 1) ** 2)
 links_nodes: list[tuple[int, int]] = []
@@ -63,8 +63,8 @@ for x in range(isqrt(cloth_nodes) - 1):
 iteration: int = 1
 iterations: int = 10000
 time_step: float = 0.001
-view_minimum = Point(-1, -2)
-view_maximum = Point(6, 5)
+view_minimum = Vector(-1, -2)
+view_maximum = Vector(6, 5)
 
 
 
@@ -72,16 +72,16 @@ pygame.init()
 screen = pygame.display.set_mode([500, 500])
 
 
-def transform(point: Point) -> Point:
-    return Point(500 * (point.x - view_minimum.x) / (view_maximum.x - view_minimum.x),
-                 500 * (1 - (point.y - view_minimum.y) / (view_maximum.y - view_minimum.y)))
+def transform(point: Vector) -> Vector:
+    return Vector(500 * (point.x - view_minimum.x) / (view_maximum.x - view_minimum.x),
+                  500 * (1 - (point.y - view_minimum.y) / (view_maximum.y - view_minimum.y)))
 
 running = True
 
 for i in range(iterations):
     # Clearing forces
     for n in range(nodes):
-        nodes_force[n].set(Point(0, 0))
+        nodes_force[n].set(Vector(0, 0))
 
     # Force of gravity
     for n in range(nodes):
@@ -89,7 +89,7 @@ for i in range(iterations):
 
     for l in range(links):
         link_nodes = links_nodes[l]
-        link_distance = Point.dist(nodes_position[link_nodes[0]], nodes_position[link_nodes[1]])
+        link_distance = Vector.dist(nodes_position[link_nodes[0]], nodes_position[link_nodes[1]])
 
         # Finding speed of expansion/contraction before distance set
         links_speed[l] = (link_distance - links_distance[l]) / time_step
@@ -104,7 +104,7 @@ for i in range(iterations):
     # Integration
     for n in range(nodes):
         if n == 24:
-            nodes_position[n].set(Point(4 + 2 * sin(0.002 * iteration), 4))
+            nodes_position[n].set(Vector(4 + 2 * sin(0.002 * iteration), 4))
             continue
 
         nodes_acceleration[n] = nodes_force[n] / nodes_mass[n]
diff --git a/cloth_3.py b/cloth_3.py
index 73a08e2..f00baad 100644
--- a/cloth_3.py
+++ b/cloth_3.py
@@ -2,17 +2,17 @@ from math import nan, isnan, isqrt, sin, cos
 from time import sleep
 from scipy.constants import g
 import pygame
-from points import Point
+from vectors import Vector
 
 cloth_nodes: int = 25
 nodes_references: list[list[int]] = [[y * isqrt(cloth_nodes) + x for x in range(isqrt(cloth_nodes))] for y in range(isqrt(cloth_nodes))]
 
 nodes: int = cloth_nodes
 nodes_mass: list[float] = [1 for n in range(cloth_nodes)]
-nodes_position: list[Point] = [Point(x, y) for y in range(isqrt(cloth_nodes)) for x in range(isqrt(cloth_nodes))]
-nodes_velocity: list[Point] = [Point(0, 0) for n in range(cloth_nodes)]
-nodes_acceleration: list[Point] = [Point(0, 0) for n in range(cloth_nodes)]
-nodes_force: list[Point] = [Point(0, 0) for n in range(cloth_nodes)]
+nodes_position: list[Vector] = [Vector(x, y) for y in range(isqrt(cloth_nodes)) for x in range(isqrt(cloth_nodes))]
+nodes_velocity: list[Vector] = [Vector(0, 0) for n in range(cloth_nodes)]
+nodes_acceleration: list[Vector] = [Vector(0, 0) for n in range(cloth_nodes)]
+nodes_force: list[Vector] = [Vector(0, 0) for n in range(cloth_nodes)]
 
 links: int = 2 * (isqrt(cloth_nodes) * (isqrt(cloth_nodes) - 1) + (isqrt(cloth_nodes) - 1) ** 2)
 links_nodes: list[tuple[int, int]] = []
@@ -63,8 +63,8 @@ for x in range(isqrt(cloth_nodes) - 1):
 iteration: int = 1
 iterations: int = 10000
 time_step: float = 0.001
-view_minimum = Point(-1, -2)
-view_maximum = Point(6, 5)
+view_minimum = Vector(-1, -2)
+view_maximum = Vector(6, 5)
 
 
 
@@ -72,16 +72,16 @@ pygame.init()
 screen = pygame.display.set_mode([500, 500])
 
 
-def transform(point: Point) -> Point:
-    return Point(500 * (point.x - view_minimum.x) / (view_maximum.x - view_minimum.x),
-                 500 * (1 - (point.y - view_minimum.y) / (view_maximum.y - view_minimum.y)))
+def transform(point: Vector) -> Vector:
+    return Vector(500 * (point.x - view_minimum.x) / (view_maximum.x - view_minimum.x),
+                  500 * (1 - (point.y - view_minimum.y) / (view_maximum.y - view_minimum.y)))
 
 running = True
 
 for i in range(iterations):
     # Clearing forces
     for n in range(nodes):
-        nodes_force[n].set(Point(0, 0))
+        nodes_force[n].set(Vector(0, 0))
 
     # Force of gravity
     for n in range(nodes):
@@ -89,7 +89,7 @@ for i in range(iterations):
 
     for l in range(links):
         link_nodes = links_nodes[l]
-        link_distance = Point.dist(nodes_position[link_nodes[0]], nodes_position[link_nodes[1]])
+        link_distance = Vector.dist(nodes_position[link_nodes[0]], nodes_position[link_nodes[1]])
 
         # Finding speed of expansion/contraction before distance set
         links_speed[l] = (link_distance - links_distance[l]) / time_step
@@ -104,7 +104,7 @@ for i in range(iterations):
     # Integration
     for n in range(nodes):
         if n == 24:
-            nodes_position[n].set(Point(3 + 1 * cos(0.004 * iteration), 4 + 1 * sin(0.004 * iteration)))
+            nodes_position[n].set(Vector(3 + 1 * cos(0.004 * iteration), 4 + 1 * sin(0.004 * iteration)))
             continue
 
         nodes_acceleration[n] = nodes_force[n] / nodes_mass[n]
diff --git a/cloth_4.py b/cloth_4.py
index d4943ad..b861ba6 100644
--- a/cloth_4.py
+++ b/cloth_4.py
@@ -2,17 +2,17 @@ from math import isqrt
 from time import sleep
 from scipy.constants import g
 import pygame
-from points import Point
+from vectors import Vector
 
 cloth_nodes: int = 25
 nodes_references: list[list[int]] = [[y * isqrt(cloth_nodes) + x for x in range(isqrt(cloth_nodes))] for y in range(isqrt(cloth_nodes))]
 
 nodes: int = cloth_nodes
 nodes_mass: list[float] = [1 for n in range(cloth_nodes)]
-nodes_position: list[Point] = [Point(x, y) for y in range(isqrt(cloth_nodes)) for x in range(isqrt(cloth_nodes))]
-nodes_velocity: list[Point] = [Point(0, 0) for n in range(cloth_nodes)]
-nodes_acceleration: list[Point] = [Point(0, 0) for n in range(cloth_nodes)]
-nodes_force: list[Point] = [Point(0, 0) for n in range(cloth_nodes)]
+nodes_position: list[Vector] = [Vector(x, y) for y in range(isqrt(cloth_nodes)) for x in range(isqrt(cloth_nodes))]
+nodes_velocity: list[Vector] = [Vector(0, 0) for n in range(cloth_nodes)]
+nodes_acceleration: list[Vector] = [Vector(0, 0) for n in range(cloth_nodes)]
+nodes_force: list[Vector] = [Vector(0, 0) for n in range(cloth_nodes)]
 
 links: int = 2 * (isqrt(cloth_nodes) * (isqrt(cloth_nodes) - 1) + (isqrt(cloth_nodes) - 1) ** 2)
 links_nodes: list[tuple[int, int]] = []
@@ -63,8 +63,8 @@ for x in range(isqrt(cloth_nodes) - 1):
 iteration: int = 1
 iterations: int = 10000
 time_step: float = 0.001
-view_minimum = Point(-1, -2)
-view_maximum = Point(6, 5)
+view_minimum = Vector(-1, -2)
+view_maximum = Vector(6, 5)
 
 
 
@@ -72,16 +72,16 @@ pygame.init()
 screen = pygame.display.set_mode([500, 500])
 
 
-def transform(point: Point) -> Point:
-    return Point(500 * (point.x - view_minimum.x) / (view_maximum.x - view_minimum.x),
-                 500 * (1 - (point.y - view_minimum.y) / (view_maximum.y - view_minimum.y)))
+def transform(point: Vector) -> Vector:
+    return Vector(500 * (point.x - view_minimum.x) / (view_maximum.x - view_minimum.x),
+                  500 * (1 - (point.y - view_minimum.y) / (view_maximum.y - view_minimum.y)))
 
 running = True
 
 for i in range(iterations):
     # Clearing forces
     for n in range(nodes):
-        nodes_force[n].set(Point(0, 0))
+        nodes_force[n].set(Vector(0, 0))
 
     # Force of gravity
     for n in range(nodes):
@@ -89,7 +89,7 @@ for i in range(iterations):
 
     for l in range(links):
         link_nodes = links_nodes[l]
-        link_distance = Point.dist(nodes_position[link_nodes[0]], nodes_position[link_nodes[1]])
+        link_distance = Vector.dist(nodes_position[link_nodes[0]], nodes_position[link_nodes[1]])
 
         # Finding speed of expansion/contraction before distance set
         links_speed[l] = (link_distance - links_distance[l]) / time_step
@@ -104,7 +104,7 @@ for i in range(iterations):
     # Integration
     for n in range(nodes):
         if n == 24:
-            nodes_position[n].set(Point(4, 4))
+            nodes_position[n].set(Vector(4, 4))
             continue
 
         nodes_acceleration[n] = nodes_force[n] / nodes_mass[n]
diff --git a/points.py b/points.py
deleted file mode 100644
index 79c917c..0000000
--- a/points.py
+++ /dev/null
@@ -1,126 +0,0 @@
-"""Python module for dealing with two-dimensional cartesian coordinates and vector operations."""
-
-from __future__ import annotations
-from math import hypot
-from collections.abc import Iterator
-
-
-class Point:
-    """Two-dimensional point represented in cartesian coordinates."""
-    x: float
-    y: float
-
-    def __init__(self, x: float, y: float) -> None:
-        """Instantiate a point from cartesian coordinates."""
-        self.x = x
-        self.y = y
-
-    def __iter__(self) -> Iterator[float]:
-        """Iterate through the pair of coordinates."""
-        yield self.x
-        yield self.y
-
-    def __str__(self) -> str:
-        return f"({self.x}, {self.y})"
-
-    def __add__(self, point: Point, /) -> Point:
-        """(+) Add caller point with parameter point, without modification to point."""
-        return self.copy().add(point)
-
-    def __iadd__(self, point: Point, /) -> Point:
-        """(+=) Add caller point with parameter point, with modification to caller point."""
-        return self.add(point)
-
-    def __sub__(self, point: Point, /) -> Point:
-        """(-) Subtract parameter point from caller point, without modification to point."""
-        return self.copy().sub(point)
-
-    def __isub__(self, point: Point, /) -> Point:
-        """(-=) Subtract parameter point from caller point, with modification to caller point."""
-        return self.sub(point)
-
-    def __mul__(self, multiplier: float, /) -> Point:
-        """(*) Multiply point coordinates by a number, without modification to point."""
-        return self.copy().mul(multiplier)
-
-    def __rmul__(self, multiplier: float, /) -> Point:
-        """(*) Multiply point coordinates by a number, without modification to point."""
-        return self.copy().mul(multiplier)
-
-    def __imul__(self, multiplier: float, /) -> Point:
-        """(*=) Multiply point coordinates by a number, with modification to point."""
-        return self.mul(multiplier)
-
-    def __truediv__(self, divisor: float, /) -> Point:
-        """(/) Divide point coordinates by a number, without modification to point."""
-        return self.copy().div(divisor)
-
-    def __itruediv__(self, divisor: float, /) -> Point:
-        """(/=) Divide point coordinates by a number, with modification to point."""
-        return self.div(divisor)
-
-    def __pos__(self) -> Point:
-        """(+) Return the same point instance."""
-        return self
-
-    def __neg__(self) -> Point:
-        """(-) Flip the sign of point coordinates, without modification to point."""
-        return self.copy().mul(-1)
-
-    def __matmul__(self, point: Point, /) -> float:
-        """(@) Find the dot product of two points as vectors."""
-        return self.dot(point)
-
-    def __mod__(self, point: Point, /) -> float:
-        """(%) Find the cross product of two points as vectors."""
-        return self.cross(point)
-
-    def set(self, point: Point, /) -> Point:
-        """Set coordinates of caller point to match parameter point."""
-        self.x = point.x
-        self.y = point.y
-        return self
-
-    def add(self, point: Point, /) -> Point:
-        """Add caller point with parameter point, with modification to caller point."""
-        self.x += point.x
-        self.y += point.y
-        return self
-
-    def sub(self, point: Point, /) -> Point:
-        """Subtract parameter point from caller point, with modification to caller point."""
-        self.x -= point.x
-        self.y -= point.y
-        return self
-
-    def mul(self, multiplier: float, /) -> Point:
-        """Multiply point coordinates by a number, with modification to point."""
-        self.x *= multiplier
-        self.y *= multiplier
-        return self
-
-    def div(self, divisor: float, /) -> Point:
-        """Divide point coordinates by a number, with modification to point."""
-        self.x /= divisor
-        self.y /= divisor
-        return self
-
-    def len(self) -> float:
-        """Find the distance to the origin."""
-        return hypot(self.x, self.y)
-
-    def dist(self, point: Point, /) -> float:
-        """Find the distance between two points."""
-        return hypot(self.x - point.x, self.y - point.y)
-
-    def dot(self, point: Point, /) -> float:
-        """Find the dot product of two points."""
-        return self.x * point.x + self.y * point.y
-
-    def cross(self, point: Point, /) -> float:
-        """Find the cross product of two points."""
-        return self.x * point.y - self.y * point.x
-
-    def copy(self) -> Point:
-        """Copy the point instance."""
-        return Point(self.x, self.y)
diff --git a/render.py b/render.py
index 35a1e9d..4ddc8d9 100644
--- a/render.py
+++ b/render.py
@@ -1,30 +1,35 @@
+import os
 from math import tau
 from scipy.constants import g
 import cairo
 import ffmpeg
-from structures import tower
-from points import Point
+from structures import tower, pyramid, blob
+from vectors import Vector
 
-softbody = tower(position=Point(0, 0), size=(1, 1), grid=(4, 4), mass=1, stiffness=100, dampening=0)
+
+softbody = tower(position=Vector(0, 0), size=(1, 1), grid=(5, 5), mass=1, stiffness=100, dampening=1)
+# softbody = pyramid(position=Point(0, 0), size=(1, 1), grid=4, mass=1, stiffness=100, dampening=0)
 nodes, links = softbody
 
-camera_position = Point(0, 0)
+camera_position = Vector(0, 0)
 camera_zoom = 0.5
 
-for i in range(1000):
+
+
+for i in range(500):
     for node in nodes:
-        node.force.set(Point(0, -node.mass * g))
+        node.force.set(Vector(0, -node.mass * g))
     for link in links:
-        link.nodes[0].force.add(link.get_force() * (link.nodes[0].position - link.nodes[1].position) / Point.dist(link.nodes[0].position, link.nodes[1].position))
-        link.nodes[1].force.add(link.get_force() * (link.nodes[1].position - link.nodes[0].position) / Point.dist(link.nodes[0].position, link.nodes[1].position))
-    nodes[0].force.set(Point(0, 0))
+        link.nodes[0].force.add(link.get_force() * (link.nodes[0].position - link.nodes[1].position) / Vector.dist(link.nodes[0].position, link.nodes[1].position))
+        link.nodes[1].force.add(link.get_force() * (link.nodes[1].position - link.nodes[0].position) / Vector.dist(link.nodes[0].position, link.nodes[1].position))
+    nodes[0].force.set(Vector(0, 0))
     for node in nodes:
         node.iterate(time=0.005)
 
-    surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 500, 500)
+    surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 250, 250)
     ctx = cairo.Context(surface)
 
-    ctx.scale(500, 500)
+    ctx.scale(250, 250)
     ctx.rectangle(0, 0, 1, 1)
     ctx.set_source_rgb(1, 0.94, 0.79)
     ctx.fill()
@@ -37,7 +42,7 @@ for i in range(1000):
         ctx.move_to(link.nodes[0].position.x, link.nodes[0].position.y)
         ctx.line_to(link.nodes[1].position.x, link.nodes[1].position.y)
         ctx.set_source_rgb(0, 0, 0)
-        ctx.set_line_width(0.03)
+        ctx.set_line_width(0.03 * (link.resting_length / link.get_length()))
         ctx.set_line_cap(cairo.LINE_CAP_ROUND)
         ctx.stroke()
 
@@ -51,4 +56,7 @@ for i in range(1000):
 
     surface.write_to_png(f"output/{i:06d}.png")
 
-ffmpeg.input("output/%06d.png", pattern_type="sequence", framerate=60).output("output.mp4").run()
+
+ffmpeg.input("output/%06d.png", pattern_type="sequence", framerate=60).output("output.mp4").run(overwrite_output=True)
+for png in os.scandir("output"):
+    os.remove(png)
diff --git a/softbodies.py b/softbodies.py
index a51d6e1..20bfd7d 100644
--- a/softbodies.py
+++ b/softbodies.py
@@ -1,19 +1,19 @@
 from __future__ import annotations
-from points import Point
+from vectors import Vector
 
 
 class Node:
     """A point mass particle that implements Euler integration."""
     mass: float
-    position: Point
-    velocity: Point
-    force: Point
+    position: Vector
+    velocity: Vector
+    force: Vector
 
-    def __init__(self, mass: float, position: Point) -> None:
+    def __init__(self, mass: float, position: Vector) -> None:
         self.mass = mass
         self.position = position
-        self.velocity = Point(0, 0)
-        self.force = Point(0, 0)
+        self.velocity = Vector(0, 0)
+        self.force = Vector(0, 0)
 
     def iterate(self, time: float) -> None:
         """Integrate the position and velocity with Euler's method."""
@@ -31,7 +31,7 @@ class Link:
     def __init__(self, nodes: tuple[Node, Node], stiffness: float, dampening: float, resting_length: float = None) -> None:
         self.nodes = nodes
         if resting_length is None:
-            self.resting_length = Point.dist(nodes[0].position, nodes[1].position)
+            self.resting_length = Vector.dist(nodes[0].position, nodes[1].position)
         else:
             self.resting_length = resting_length
         self.stiffness = stiffness
@@ -39,11 +39,11 @@ class Link:
 
     def get_length(self) -> float:
         """Get the momentary length of the link."""
-        return Point.dist(self.nodes[0].position, self.nodes[1].position)
+        return Vector.dist(self.nodes[0].position, self.nodes[1].position)
 
     def get_speed(self) -> float:
         """Get the speed of the expansion/contraction of the link (positive/negative)."""
-        return Point.dot(self.nodes[0].position - self.nodes[1].position, self.nodes[0].velocity - self.nodes[1].velocity) / self.get_length()
+        return Vector.dot(self.nodes[0].position - self.nodes[1].position, self.nodes[0].velocity - self.nodes[1].velocity) / self.get_length()
 
     def get_displacement(self) -> float:
         """Get the expansion/contraction of the link from its resting configuration (positive/negative)."""
diff --git a/structures.py b/structures.py
index d0d37c4..4554961 100644
--- a/structures.py
+++ b/structures.py
@@ -3,16 +3,16 @@ from math import sqrt, cos, sin, atan2, tau
 from random import random
 from typing import NewType
 from softbodies import Node, Link
-from points import Point
+from vectors import Vector
 
 Softbody = tuple[list[Node], list[Link]]
 
 
-def structure(softbody: Softbody, position: Point, scale: float, rotation: float) -> Softbody:
+def structure(softbody: Softbody, position: Vector, scale: float, rotation: float) -> Softbody:
     nodes, links = softbody
     for node in nodes:
         node_angle = atan2(node.position.y, node.position.x)
-        node_radius = node.position.dist(Point(0, 0))
+        node_radius = node.position.dist(Vector(0, 0))
         node.position.x = node_radius * cos(node_angle + rotation)
         node.position.y = node_radius * sin(node_angle + rotation)
         node.position *= scale
@@ -20,14 +20,14 @@ def structure(softbody: Softbody, position: Point, scale: float, rotation: float
     return nodes, links
 
 
-def tower(position: Point, size: tuple[float, float], grid: tuple[int, int], mass: float, stiffness: float, dampening: float) -> Softbody:
+def tower(position: Vector, size: tuple[float, float], grid: tuple[int, int], mass: float, stiffness: float, dampening: float) -> Softbody:
     nodes_mesh = []
     for x in range(grid[0] + 1):
         nodes_mesh.append([])
         for y in range(grid[1] + 1):
             node_mass = mass / ((grid[0] + 1) * (grid[1] + 1))
-            node_position = Point(size[0] * (x / grid[0] - 0.5),
-                                  size[1] * (y / grid[1] - 0.5))
+            node_position = Vector(size[0] * (x / grid[0] - 0.5),
+                                   size[1] * (y / grid[1] - 0.5))
             nodes_mesh[x].append(Node(node_mass, node_position))
     links = []
     for x in range(grid[0]):
@@ -46,13 +46,13 @@ def tower(position: Point, size: tuple[float, float], grid: tuple[int, int], mas
     return structure((nodes, links), position, 1, 0)
 
 
-def pyramid(position: Point, size: tuple[float, float], grid: int, mass: float, stiffness: float, dampening: float) -> Softbody:
+def pyramid(position: Vector, size: tuple[float, float], grid: int, mass: float, stiffness: float, dampening: float) -> Softbody:
     nodes_mesh = []
     for y in range(grid + 1):
         nodes_mesh.append([])
         for x in range(grid + 1 - y):
             node_mass = mass / ((grid + 1) * (grid + 2) / 2)
-            node_position = Point(-size[0] / 2 + x, -size[1] / 2 + y)
+            node_position = Vector(-size[0] / 2 + x, -size[1] / 2 + y)
             nodes_mesh[y].append(Node(node_mass, node_position))
     links = []
     for y in range(grid + 1):
@@ -68,18 +68,18 @@ def pyramid(position: Point, size: tuple[float, float], grid: int, mass: float,
     return structure((nodes, links), position, rotation=0, scale=1)
 
 
-def blob(position: Point, size: float) -> Softbody:
+def blob(position: Vector, size: float) -> Softbody:
     nodes = []
     for n in range(30):
         radius = (size / 2) * sqrt(random())
         angle = tau * random()
-        nodes.append(Node(mass=1, position=Point(position.x + radius * cos(angle), position.y + radius * sin(angle))))
+        nodes.append(Node(mass=1, position=Vector(position.x + radius * cos(angle), position.y + radius * sin(angle))))
     links = []
     for n1 in range(30):
         for n2 in range(n1 + 1, 30):
             node_1 = nodes[n1]
             node_2 = nodes[n2]
 
-            if Point.dist(node_1.position, node_2.position) <= size / 3:
+            if Vector.dist(node_1.position, node_2.position) <= size / 5:
                 links.append(Link(nodes=(node_1, node_2), stiffness=200, dampening=0))
     return structure((nodes, links), position, rotation=0, scale=1)
diff --git a/test.py b/test.py
deleted file mode 100644
index dfc9144..0000000
--- a/test.py
+++ /dev/null
@@ -1,65 +0,0 @@
-from time import sleep
-from scipy.constants import g
-import pygame
-from softbodies import Softbody, Node, Link, Point
-from structures import Tower, Pyramid, Blob
-
-nodes = [Node(mass=1, position=Point(1, 1)),
-         Node(mass=1, position=Point(1, -1)),
-         Node(mass=1, position=Point(-1, -1)),
-         Node(mass=1, position=Point(-1, 1))]
-links = [Link(nodes=(nodes[0], nodes[1]), stiffness=100, dampening=1),
-         Link(nodes=(nodes[1], nodes[2]), stiffness=100, dampening=1),
-         Link(nodes=(nodes[2], nodes[3]), stiffness=100, dampening=1),
-         Link(nodes=(nodes[3], nodes[0]), stiffness=100, dampening=1),
-         Link(nodes=(nodes[0], nodes[2]), stiffness=100, dampening=1, resting_length=2),
-         Link(nodes=(nodes[1], nodes[3]), stiffness=100, dampening=1, resting_length=2)]
-#softbody = Softbody(nodes=nodes, links=links)
-softbody = Tower(position=Point(0, 0), size=(1, 7), grid=(1, 7), mass=100, stiffness=5000, dampening=10)
-#softbody = Pyramid(position=Point(0, 0), size=(2, 2), grid=3, mass=1, stiffness=100, dampening=0)
-#softbody = Blob(position=Point(0, 0), size=2)
-camera_position = Point(0, -2)
-camera_zoom = 0.1
-
-
-def transformed(position: Point) -> tuple[float, float]:
-    return (500 * (camera_zoom * (position.x - camera_position.x) + 0.5),
-            500 - (500 * (camera_zoom * (position.y - camera_position.y) + 0.5)))
-
-
-pygame.init()
-screen = pygame.display.set_mode((500, 500))
-
-clock = pygame.time.Clock()
-
-running = True
-
-while running:
-    for event in pygame.event.get():
-        if event.type == pygame.QUIT:
-            running = False
-
-    for n in range(5):
-        for node in softbody.nodes:
-            node.force.set(Point(0, -node.mass * g))
-        for link in softbody.links:
-            force = link.get_force()
-            link.nodes[0].force.add(
-                force * (link.nodes[0].position - link.nodes[1].position) / Point.dist(link.nodes[0].position,
-                                                                                       link.nodes[1].position))
-            link.nodes[1].force.add(
-                force * (link.nodes[1].position - link.nodes[0].position) / Point.dist(link.nodes[0].position,
-                                                                                       link.nodes[1].position))
-        softbody.nodes[0].force.set(Point(0, 0))
-        softbody.iterate(time=0.005)
-
-    screen.fill((0, 0, 0))
-
-    for link in softbody.links:
-        pygame.draw.line(screen, color=(0, 0, 255), start_pos=transformed(link.nodes[0].position), end_pos=transformed(link.nodes[1].position), width=3)
-
-    for node in softbody.nodes:
-        pygame.draw.circle(screen, color=(255, 0, 0), center=transformed(node.position), radius=3)
-
-    pygame.display.flip()
-    sleep(1 / 30)
\ No newline at end of file
diff --git a/vectors.py b/vectors.py
new file mode 100644
index 0000000..2ac6e9d
--- /dev/null
+++ b/vectors.py
@@ -0,0 +1,126 @@
+"""Python module for dealing with two-dimensional cartesian coordinates and vector operations."""
+
+from __future__ import annotations
+from math import hypot
+from collections.abc import Iterator
+
+
+class Vector:
+    """Two-dimensional vector represented in cartesian coordinates."""
+    x: float
+    y: float
+
+    def __init__(self, x: float, y: float) -> None:
+        """Instantiate a vector from cartesian coordinates."""
+        self.x = x
+        self.y = y
+
+    def __iter__(self) -> Iterator[float]:
+        """Iterate through the pair of coordinates."""
+        yield self.x
+        yield self.y
+
+    def __str__(self) -> str:
+        return f"({self.x}, {self.y})"
+
+    def __add__(self, vector: Vector, /) -> Vector:
+        """(+) Add caller vector with parameter vector, without modification to vector."""
+        return self.copy().add(vector)
+
+    def __iadd__(self, vector: Vector, /) -> Vector:
+        """(+=) Add caller vector with parameter vector, with modification to caller vector."""
+        return self.add(vector)
+
+    def __sub__(self, vector: Vector, /) -> Vector:
+        """(-) Subtract parameter vector from caller vector, without modification to vector."""
+        return self.copy().sub(vector)
+
+    def __isub__(self, vector: Vector, /) -> Vector:
+        """(-=) Subtract parameter vector from caller vector, with modification to caller vector."""
+        return self.sub(vector)
+
+    def __mul__(self, multiplier: float, /) -> Vector:
+        """(*) Multiply vector coordinates by a number, without modification to vector."""
+        return self.copy().mul(multiplier)
+
+    def __rmul__(self, multiplier: float, /) -> Vector:
+        """(*) Multiply vector coordinates by a number, without modification to vector."""
+        return self.copy().mul(multiplier)
+
+    def __imul__(self, multiplier: float, /) -> Vector:
+        """(*=) Multiply vector coordinates by a number, with modification to vector."""
+        return self.mul(multiplier)
+
+    def __truediv__(self, divisor: float, /) -> Vector:
+        """(/) Divide vector coordinates by a number, without modification to vector."""
+        return self.copy().div(divisor)
+
+    def __itruediv__(self, divisor: float, /) -> Vector:
+        """(/=) Divide vector coordinates by a number, with modification to vector."""
+        return self.div(divisor)
+
+    def __pos__(self) -> Vector:
+        """(+) Return the same vector instance."""
+        return self
+
+    def __neg__(self) -> Vector:
+        """(-) Flip the sign of vector coordinates, without modification to vector."""
+        return self.copy().mul(-1)
+
+    def __matmul__(self, vector: Vector, /) -> float:
+        """(@) Find the dot product of two vectors as vectors."""
+        return self.dot(vector)
+
+    def __mod__(self, vector: Vector, /) -> float:
+        """(%) Find the cross product of two vectors as vectors."""
+        return self.cross(vector)
+
+    def set(self, vector: Vector, /) -> Vector:
+        """Set coordinates of caller vector to match parameter vector."""
+        self.x = vector.x
+        self.y = vector.y
+        return self
+
+    def add(self, vector: Vector, /) -> Vector:
+        """Add caller vector with parameter vector, with modification to caller vector."""
+        self.x += vector.x
+        self.y += vector.y
+        return self
+
+    def sub(self, vector: Vector, /) -> Vector:
+        """Subtract parameter vector from caller vector, with modification to caller vector."""
+        self.x -= vector.x
+        self.y -= vector.y
+        return self
+
+    def mul(self, multiplier: float, /) -> Vector:
+        """Multiply vector coordinates by a number, with modification to vector."""
+        self.x *= multiplier
+        self.y *= multiplier
+        return self
+
+    def div(self, divisor: float, /) -> Vector:
+        """Divide vector coordinates by a number, with modification to vector."""
+        self.x /= divisor
+        self.y /= divisor
+        return self
+
+    def len(self) -> float:
+        """Find the distance to the origin."""
+        return hypot(self.x, self.y)
+
+    def dist(self, vector: Vector, /) -> float:
+        """Find the distance between two vectors."""
+        return hypot(self.x - vector.x, self.y - vector.y)
+
+    def dot(self, vector: Vector, /) -> float:
+        """Find the dot product of two vectors."""
+        return self.x * vector.x + self.y * vector.y
+
+    def cross(self, vector: Vector, /) -> float:
+        """Find the cross product of two vectors."""
+        return self.x * vector.y - self.y * vector.x
+
+    def copy(self) -> Vector:
+        """Copy the vector instance."""
+        return Vector(self.x, self.y)

commit 5223875ae0a3286bb98fe06af7fbe6ca59869be9
Author: Daxonus <elias@dobrin.net>
Date:   Wed Apr 20 12:28:22 2022 -0700

    added ideas

diff --git a/.gitignore b/.gitignore
index eba74f4..e841d78 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1 +1,3 @@
-venv/
\ No newline at end of file
+venv/
+output/
+output.mp4
\ No newline at end of file
diff --git a/__pycache__/points.cpython-310.pyc b/__pycache__/points.cpython-310.pyc
index ac11a62..08d760a 100644
Binary files a/__pycache__/points.cpython-310.pyc and b/__pycache__/points.cpython-310.pyc differ
diff --git a/__pycache__/softbodies.cpython-310.pyc b/__pycache__/softbodies.cpython-310.pyc
index 1da69ff..129df27 100644
Binary files a/__pycache__/softbodies.cpython-310.pyc and b/__pycache__/softbodies.cpython-310.pyc differ
diff --git a/__pycache__/structures.cpython-310.pyc b/__pycache__/structures.cpython-310.pyc
index 040032b..1b39508 100644
Binary files a/__pycache__/structures.cpython-310.pyc and b/__pycache__/structures.cpython-310.pyc differ
diff --git a/ideas.txt b/ideas.txt
new file mode 100644
index 0000000..146cfb7
--- /dev/null
+++ b/ideas.txt
@@ -0,0 +1,7 @@
+nice rendering of softbody structures
+making lots of variations of spring meshes
+friction
+collisions
+collisions that modify the resting spring lengths
+creatures that contract and expand their muscles to move
+various ways to visualize simulation with matplotlib
\ No newline at end of file

commit d711a238fc43360fa627f5bbda0ca45e8cbb727b
Author: Daxonus <elias@dobrin.net>
Date:   Sat Apr 16 16:01:46 2022 -0700

    fix

diff --git a/render.py b/render.py
index 899792c..35a1e9d 100644
--- a/render.py
+++ b/render.py
@@ -2,27 +2,29 @@ from math import tau
 from scipy.constants import g
 import cairo
 import ffmpeg
-from structures import Tower
+from structures import tower
 from points import Point
 
-softbody = Tower(position=Point(0, 0), size=(1, 1), grid=(4, 4), mass=1, stiffness=100, dampening=0)
+softbody = tower(position=Point(0, 0), size=(1, 1), grid=(4, 4), mass=1, stiffness=100, dampening=0)
+nodes, links = softbody
 
 camera_position = Point(0, 0)
 camera_zoom = 0.5
 
 for i in range(1000):
-    for node in softbody.nodes:
+    for node in nodes:
         node.force.set(Point(0, -node.mass * g))
-    for link in softbody.links:
+    for link in links:
         link.nodes[0].force.add(link.get_force() * (link.nodes[0].position - link.nodes[1].position) / Point.dist(link.nodes[0].position, link.nodes[1].position))
         link.nodes[1].force.add(link.get_force() * (link.nodes[1].position - link.nodes[0].position) / Point.dist(link.nodes[0].position, link.nodes[1].position))
-    softbody.nodes[0].force.set(Point(0, 0))
-    softbody.iterate(time=0.005)
+    nodes[0].force.set(Point(0, 0))
+    for node in nodes:
+        node.iterate(time=0.005)
 
-    surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 1000, 1000)
+    surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 500, 500)
     ctx = cairo.Context(surface)
 
-    ctx.scale(1000, 1000)
+    ctx.scale(500, 500)
     ctx.rectangle(0, 0, 1, 1)
     ctx.set_source_rgb(1, 0.94, 0.79)
     ctx.fill()
@@ -31,7 +33,7 @@ for i in range(1000):
     ctx.translate(-camera_position.x, -camera_position.y)
     ctx.scale(camera_zoom, camera_zoom)
 
-    for link in softbody.links:
+    for link in links:
         ctx.move_to(link.nodes[0].position.x, link.nodes[0].position.y)
         ctx.line_to(link.nodes[1].position.x, link.nodes[1].position.y)
         ctx.set_source_rgb(0, 0, 0)
@@ -39,7 +41,7 @@ for i in range(1000):
         ctx.set_line_cap(cairo.LINE_CAP_ROUND)
         ctx.stroke()
 
-    for node in softbody.nodes:
+    for node in nodes:
         ctx.arc(node.position.x, node.position.y, 0.03, 0, tau)
         ctx.set_source_rgb(1, 1, 1)
         ctx.fill_preserve()
@@ -49,4 +51,4 @@ for i in range(1000):
 
     surface.write_to_png(f"output/{i:06d}.png")
 
-ffmpeg.input("output/%06d.png", pattern_type="sequence", framerate=60).output("output.mp4").run()
\ No newline at end of file
+ffmpeg.input("output/%06d.png", pattern_type="sequence", framerate=60).output("output.mp4").run()

commit b78f2928d8021dcdaab4b6f7ae35ad1d3586483c
Author: Daxonus <elias@dobrin.net>
Date:   Sat Apr 16 15:42:25 2022 -0700

    better structure :-)

diff --git a/structures.py b/structures.py
index c7e1d2a..d0d37c4 100644
--- a/structures.py
+++ b/structures.py
@@ -1,19 +1,33 @@
 from __future__ import annotations
-from math import cos, sin, tau, sqrt
+from math import sqrt, cos, sin, atan2, tau
 from random import random
-from softbodies import Node, Link, Point
+from typing import NewType
+from softbodies import Node, Link
+from points import Point
 
-softbody = tuple[list[Node], list[Link]]
+Softbody = tuple[list[Node], list[Link]]
 
 
-def tower(position: Point, size: tuple[float, float], grid: tuple[int, int], mass: float, stiffness: float, dampening: float) -> softbody:
+def structure(softbody: Softbody, position: Point, scale: float, rotation: float) -> Softbody:
+    nodes, links = softbody
+    for node in nodes:
+        node_angle = atan2(node.position.y, node.position.x)
+        node_radius = node.position.dist(Point(0, 0))
+        node.position.x = node_radius * cos(node_angle + rotation)
+        node.position.y = node_radius * sin(node_angle + rotation)
+        node.position *= scale
+        node.position += position
+    return nodes, links
+
+
+def tower(position: Point, size: tuple[float, float], grid: tuple[int, int], mass: float, stiffness: float, dampening: float) -> Softbody:
     nodes_mesh = []
     for x in range(grid[0] + 1):
         nodes_mesh.append([])
         for y in range(grid[1] + 1):
             node_mass = mass / ((grid[0] + 1) * (grid[1] + 1))
-            node_position = Point(position.x + size[0] * (x / grid[0] - 0.5),
-                                  position.y + size[1] * (y / grid[1] - 0.5))
+            node_position = Point(size[0] * (x / grid[0] - 0.5),
+                                  size[1] * (y / grid[1] - 0.5))
             nodes_mesh[x].append(Node(node_mass, node_position))
     links = []
     for x in range(grid[0]):
@@ -29,16 +43,16 @@ def tower(position: Point, size: tuple[float, float], grid: tuple[int, int], mas
         for y in range(grid[1]):
             links.append(Link((nodes_mesh[x + 1][y], nodes_mesh[x][y + 1]), stiffness, dampening))
     nodes = [node for buffer in nodes_mesh for node in buffer]
-    return nodes, links
+    return structure((nodes, links), position, 1, 0)
 
 
-def pyramid(position: Point, size: tuple[float, float], grid: int, mass: float, stiffness: float, dampening: float) -> softbody:
+def pyramid(position: Point, size: tuple[float, float], grid: int, mass: float, stiffness: float, dampening: float) -> Softbody:
     nodes_mesh = []
     for y in range(grid + 1):
         nodes_mesh.append([])
         for x in range(grid + 1 - y):
             node_mass = mass / ((grid + 1) * (grid + 2) / 2)
-            node_position = Point(position.x - size[0] / 2 + x, position.y - size[1] / 2 + y)
+            node_position = Point(-size[0] / 2 + x, -size[1] / 2 + y)
             nodes_mesh[y].append(Node(node_mass, node_position))
     links = []
     for y in range(grid + 1):
@@ -51,10 +65,10 @@ def pyramid(position: Point, size: tuple[float, float], grid: int, mass: float,
         for x in range(grid - y):
             links.append(Link((nodes_mesh[y][x + 1], nodes_mesh[y + 1][x]), stiffness, dampening))
     nodes = [node for buffer in nodes_mesh for node in buffer]
-    return nodes, links
+    return structure((nodes, links), position, rotation=0, scale=1)
 
 
-def blob(position: Point, size: float) -> softbody:
+def blob(position: Point, size: float) -> Softbody:
     nodes = []
     for n in range(30):
         radius = (size / 2) * sqrt(random())
@@ -68,4 +82,4 @@ def blob(position: Point, size: float) -> softbody:
 
             if Point.dist(node_1.position, node_2.position) <= size / 3:
                 links.append(Link(nodes=(node_1, node_2), stiffness=200, dampening=0))
-    return nodes, links
+    return structure((nodes, links), position, rotation=0, scale=1)

commit de14c9c76c2ab0a61ca360e71efeffb67ffdb3ec
Author: Daxonus <elias@dobrin.net>
Date:   Sat Apr 16 15:10:15 2022 -0700

    fixed structure of classes and removed unnecessary OOP

diff --git a/softbodies.py b/softbodies.py
index 4750385..a51d6e1 100644
--- a/softbodies.py
+++ b/softbodies.py
@@ -2,33 +2,6 @@ from __future__ import annotations
 from points import Point
 
 
-class Softbody:
-    """A spring-network type softbody consisting of nodes (point masses) and links (Hookean springs)."""
-    nodes: list[Node]
-    links: list[Link]
-
-    def __init__(self, nodes: list[Node], links: list[Link]) -> None:
-        self.nodes = nodes
-        self.links = links
-
-    def get_total_mass(self) -> float:
-        total_mass = 0
-        for node in self.nodes:
-            total_mass += node.mass
-        return total_mass
-
-    def get_center_mass(self) -> Point:
-        center_mass = Point(0, 0)
-        for node in self.nodes:
-            center_mass += node.mass * node.position
-        return center_mass
-
-    def iterate(self, time) -> None:
-        """Integrate the position and velocity of each node with Euler's method."""
-        for node in self.nodes:
-            node.iterate(time)
-
-
 class Node:
     """A point mass particle that implements Euler integration."""
     mass: float
diff --git a/structures.py b/structures.py
index 8066bec..c7e1d2a 100644
--- a/structures.py
+++ b/structures.py
@@ -1,83 +1,71 @@
 from __future__ import annotations
 from math import cos, sin, tau, sqrt
 from random import random
-from softbodies import Softbody, Node, Link, Point
-
-
-class Structure(Softbody):
-    def __init__(self, nodes: list[Node], links: list[Link]) -> None:
-        super().__init__(nodes, links)
-
-
-
-
-class Tower(Structure):
-    def __init__(self, position: Point, size: tuple[float, float], grid: tuple[int, int], mass: float, stiffness: float,
-                 dampening: float) -> None:
-        nodes = []
-        for x in range(grid[0] + 1):
-            nodes.append([])
-            for y in range(grid[1] + 1):
-                nodes[x].append(Node(mass=mass / ((grid[0] + 1) * (grid[1] + 1)),
-                                     position=Point(position.x + size[0] * (x / grid[0] - 0.5),
-                                                    position.y + size[1] * (y / grid[1] - 0.5))))
-        links = []
-        for x in range(grid[0]):
-            for y in range(grid[1] + 1):
-                links.append(Link(nodes=(nodes[x][y], nodes[x + 1][y]), stiffness=stiffness, dampening=dampening))
-        for x in range(grid[0] + 1):
-            for y in range(grid[1]):
-                links.append(Link(nodes=(nodes[x][y], nodes[x][y + 1]), stiffness=stiffness, dampening=dampening))
-        for x in range(grid[0]):
-            for y in range(grid[1]):
-                links.append(Link(nodes=(nodes[x][y], nodes[x + 1][y + 1]), stiffness=stiffness, dampening=dampening))
-        for x in range(grid[0]):
-            for y in range(grid[1]):
-                links.append(Link(nodes=(nodes[x + 1][y], nodes[x][y + 1]), stiffness=stiffness, dampening=dampening))
-        super().__init__(nodes=[node for buffer in nodes for node in buffer], links=links)
-
-
-class Pyramid(Structure):
-    def __init__(self, position: Point, size: tuple[float, float], grid: int, mass: float, stiffness: float,
-                 dampening: float) -> None:
-        nodes = []
-        for y in range(grid + 1):
-            nodes.append([])
-            for x in range(grid + 1 - y):
-                nodes[y].append(Node(mass=mass / ((grid + 1) * (grid + 2) / 2),
-                                     position=Point(position.x - size[0] / 2 + x,
-                                                    position.y - size[1] / 2 + y)))
-
-        links = []
-        for y in range(grid + 1):
-            for x in range(grid - y):
-                links.append(Link(nodes=(nodes[y][x], nodes[y][x + 1]), stiffness=stiffness, dampening=dampening))
-
-        for y in range(grid):
-            for x in range(grid - y):
-                links.append(Link(nodes=(nodes[y][x], nodes[y + 1][x]), stiffness=stiffness, dampening=dampening))
-
-        for y in range(grid):
-            for x in range(grid - y):
-                links.append(Link(nodes=(nodes[y][x + 1], nodes[y + 1][x]), stiffness=stiffness, dampening=dampening))
-
-        super().__init__(nodes=[node for buffer in nodes for node in buffer], links=links)
-
-
-class Blob(Structure):
-    def __init__(self, position: Point, size: float) -> None:
-        nodes = []
-        for n in range(30):
-            radius = (size / 2) * sqrt(random())
-            angle = tau * random()
-            nodes.append(Node(mass=1, position=Point(position.x + radius * cos(angle), position.y + radius * sin(angle))))
-        links = []
-        for n1 in range(30):
-            for n2 in range(n1 + 1, 30):
-                node_1 = nodes[n1]
-                node_2 = nodes[n2]
-
-                if Point.dist(node_1.position, node_2.position) <= size / 3:
-                    links.append(Link(nodes=(node_1, node_2), stiffness=200, dampening=0))
-
-        super().__init__(nodes=nodes, links=links)
\ No newline at end of file
+from softbodies import Node, Link, Point
+
+softbody = tuple[list[Node], list[Link]]
+
+
+def tower(position: Point, size: tuple[float, float], grid: tuple[int, int], mass: float, stiffness: float, dampening: float) -> softbody:
+    nodes_mesh = []
+    for x in range(grid[0] + 1):
+        nodes_mesh.append([])
+        for y in range(grid[1] + 1):
+            node_mass = mass / ((grid[0] + 1) * (grid[1] + 1))
+            node_position = Point(position.x + size[0] * (x / grid[0] - 0.5),
+                                  position.y + size[1] * (y / grid[1] - 0.5))
+            nodes_mesh[x].append(Node(node_mass, node_position))
+    links = []
+    for x in range(grid[0]):
+        for y in range(grid[1] + 1):
+            links.append(Link((nodes_mesh[x][y], nodes_mesh[x + 1][y]), stiffness, dampening))
+    for x in range(grid[0] + 1):
+        for y in range(grid[1]):
+            links.append(Link((nodes_mesh[x][y], nodes_mesh[x][y + 1]), stiffness, dampening))
+    for x in range(grid[0]):
+        for y in range(grid[1]):
+            links.append(Link((nodes_mesh[x][y], nodes_mesh[x + 1][y + 1]), stiffness, dampening))
+    for x in range(grid[0]):
+        for y in range(grid[1]):
+            links.append(Link((nodes_mesh[x + 1][y], nodes_mesh[x][y + 1]), stiffness, dampening))
+    nodes = [node for buffer in nodes_mesh for node in buffer]
+    return nodes, links
+
+
+def pyramid(position: Point, size: tuple[float, float], grid: int, mass: float, stiffness: float, dampening: float) -> softbody:
+    nodes_mesh = []
+    for y in range(grid + 1):
+        nodes_mesh.append([])
+        for x in range(grid + 1 - y):
+            node_mass = mass / ((grid + 1) * (grid + 2) / 2)
+            node_position = Point(position.x - size[0] / 2 + x, position.y - size[1] / 2 + y)
+            nodes_mesh[y].append(Node(node_mass, node_position))
+    links = []
+    for y in range(grid + 1):
+        for x in range(grid - y):
+            links.append(Link((nodes_mesh[y][x], nodes_mesh[y][x + 1]), stiffness, dampening))
+    for y in range(grid):
+        for x in range(grid - y):
+            links.append(Link((nodes_mesh[y][x], nodes_mesh[y + 1][x]), stiffness, dampening))
+    for y in range(grid):
+        for x in range(grid - y):
+            links.append(Link((nodes_mesh[y][x + 1], nodes_mesh[y + 1][x]), stiffness, dampening))
+    nodes = [node for buffer in nodes_mesh for node in buffer]
+    return nodes, links
+
+
+def blob(position: Point, size: float) -> softbody:
+    nodes = []
+    for n in range(30):
+        radius = (size / 2) * sqrt(random())
+        angle = tau * random()
+        nodes.append(Node(mass=1, position=Point(position.x + radius * cos(angle), position.y + radius * sin(angle))))
+    links = []
+    for n1 in range(30):
+        for n2 in range(n1 + 1, 30):
+            node_1 = nodes[n1]
+            node_2 = nodes[n2]
+
+            if Point.dist(node_1.position, node_2.position) <= size / 3:
+                links.append(Link(nodes=(node_1, node_2), stiffness=200, dampening=0))
+    return nodes, links

commit 2ea1754480ae1ba02a64a857437ad47d4a5a0f0b
Author: Daxonus <elias@dobrin.net>
Date:   Sat Apr 16 13:25:18 2022 -0700

    image snapshots and ffmpeg images to video working

diff --git a/render.py b/render.py
index ec5bdbb..899792c 100644
--- a/render.py
+++ b/render.py
@@ -1,28 +1,28 @@
-from os import mkdir
 from math import tau
 from scipy.constants import g
 import cairo
+import ffmpeg
 from structures import Tower
 from points import Point
 
-softbody = Tower(position=Point(0, 0), size=(1, 1), grid=(2, 2), mass=1, stiffness=1, dampening=0)
+softbody = Tower(position=Point(0, 0), size=(1, 1), grid=(4, 4), mass=1, stiffness=100, dampening=0)
 
 camera_position = Point(0, 0)
 camera_zoom = 0.5
 
-mkdir("renders")
-for i in range(100):
+for i in range(1000):
     for node in softbody.nodes:
         node.force.set(Point(0, -node.mass * g))
     for link in softbody.links:
         link.nodes[0].force.add(link.get_force() * (link.nodes[0].position - link.nodes[1].position) / Point.dist(link.nodes[0].position, link.nodes[1].position))
         link.nodes[1].force.add(link.get_force() * (link.nodes[1].position - link.nodes[0].position) / Point.dist(link.nodes[0].position, link.nodes[1].position))
+    softbody.nodes[0].force.set(Point(0, 0))
     softbody.iterate(time=0.005)
 
-    surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 256, 256)
+    surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 1000, 1000)
     ctx = cairo.Context(surface)
 
-    ctx.scale(256, 256)
+    ctx.scale(1000, 1000)
     ctx.rectangle(0, 0, 1, 1)
     ctx.set_source_rgb(1, 0.94, 0.79)
     ctx.fill()
@@ -47,4 +47,6 @@ for i in range(100):
         ctx.set_line_width(0.02)
         ctx.stroke()
 
-    surface.write_to_png(f"renders/render_{i}.png")
\ No newline at end of file
+    surface.write_to_png(f"output/{i:06d}.png")
+
+ffmpeg.input("output/%06d.png", pattern_type="sequence", framerate=60).output("output.mp4").run()
\ No newline at end of file
diff --git a/requirements.txt b/requirements.txt
deleted file mode 100644
index e1593b0..0000000
--- a/requirements.txt
+++ /dev/null
@@ -1,7 +0,0 @@
-commonmark==0.9.1
-numpy==1.22.3
-pycairo==1.21.0
-pygame==2.1.2
-Pygments==2.11.2
-rich==12.2.0
-scipy==1.8.0
\ No newline at end of file
diff --git a/softbodies.py b/softbodies.py
index 6e32836..4750385 100644
--- a/softbodies.py
+++ b/softbodies.py
@@ -49,7 +49,7 @@ class Node:
 
 
 class Link:
-    """A massless Hookean spring that features a stiffness force and a spring force."""
+    """A massless Hookean spring that features a pair of spring stiffness and dampening forces."""
     nodes: tuple[Node, Node]
     resting_length: float
     stiffness: float

commit 33ea75333e6ffb07ac905dd925aa753df77520cb
Author: Daxonus <elias@dobrin.net>
Date:   Tue Apr 5 22:26:54 2022 -0700

    added requirements.txt

diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..eba74f4
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1 @@
+venv/
\ No newline at end of file
diff --git a/requirements.txt b/requirements.txt
new file mode 100644
index 0000000..e1593b0
--- /dev/null
+++ b/requirements.txt
@@ -0,0 +1,7 @@
+commonmark==0.9.1
+numpy==1.22.3
+pycairo==1.21.0
+pygame==2.1.2
+Pygments==2.11.2
+rich==12.2.0
+scipy==1.8.0
\ No newline at end of file

commit 47e5d34beb78efb16b5a69ac398cb82c27f3c9c6
Author: Daxonus <elias@dobrin.net>
Date:   Tue Apr 5 22:18:16 2022 -0700

    rendering?

diff --git a/__pycache__/softbodies.cpython-310.pyc b/__pycache__/softbodies.cpython-310.pyc
index 8b7d7df..1da69ff 100644
Binary files a/__pycache__/softbodies.cpython-310.pyc and b/__pycache__/softbodies.cpython-310.pyc differ
diff --git a/example.png b/example.png
deleted file mode 100644
index 94ffc0e..0000000
Binary files a/example.png and /dev/null differ
diff --git a/object_1.py b/object_1.py
deleted file mode 100644
index 2e4a20c..0000000
--- a/object_1.py
+++ /dev/null
@@ -1,4 +0,0 @@
-from __future__ import annotations
-from scipy.constants import g
-import pygame
-from points import Point
\ No newline at end of file
diff --git a/render.py b/render.py
index f330705..ec5bdbb 100644
--- a/render.py
+++ b/render.py
@@ -1,4 +1,6 @@
+from os import mkdir
 from math import tau
+from scipy.constants import g
 import cairo
 from structures import Tower
 from points import Point
@@ -8,32 +10,41 @@ softbody = Tower(position=Point(0, 0), size=(1, 1), grid=(2, 2), mass=1, stiffne
 camera_position = Point(0, 0)
 camera_zoom = 0.5
 
-surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 256, 256)
-ctx = cairo.Context(surface)
-
-ctx.scale(256, 256)
-ctx.rectangle(0, 0, 1, 1)
-ctx.set_source_rgb(1, 0.94, 0.79)
-ctx.fill()
-ctx.translate(0.5, 0.5)
-ctx.scale(1, -1)
-ctx.translate(-camera_position.x, -camera_position.y)
-ctx.scale(camera_zoom, camera_zoom)
-
-for link in softbody.links:
-    ctx.move_to(link.nodes[0].position.x, link.nodes[0].position.y)
-    ctx.line_to(link.nodes[1].position.x, link.nodes[1].position.y)
-    ctx.set_source_rgb(0, 0, 0)
-    ctx.set_line_width(0.03)
-    ctx.set_line_cap(cairo.LINE_CAP_ROUND)
-    ctx.stroke()
-
-for node in softbody.nodes:
-    ctx.arc(node.position.x, node.position.y, 0.03, 0, tau)
-    ctx.set_source_rgb(1, 1, 1)
-    ctx.fill_preserve()
-    ctx.set_source_rgb(0, 0, 0)
-    ctx.set_line_width(0.02)
-    ctx.stroke()
-
-surface.write_to_png("example.png")
\ No newline at end of file
+mkdir("renders")
+for i in range(100):
+    for node in softbody.nodes:
+        node.force.set(Point(0, -node.mass * g))
+    for link in softbody.links:
+        link.nodes[0].force.add(link.get_force() * (link.nodes[0].position - link.nodes[1].position) / Point.dist(link.nodes[0].position, link.nodes[1].position))
+        link.nodes[1].force.add(link.get_force() * (link.nodes[1].position - link.nodes[0].position) / Point.dist(link.nodes[0].position, link.nodes[1].position))
+    softbody.iterate(time=0.005)
+
+    surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 256, 256)
+    ctx = cairo.Context(surface)
+
+    ctx.scale(256, 256)
+    ctx.rectangle(0, 0, 1, 1)
+    ctx.set_source_rgb(1, 0.94, 0.79)
+    ctx.fill()
+    ctx.translate(0.5, 0.5)
+    ctx.scale(1, -1)
+    ctx.translate(-camera_position.x, -camera_position.y)
+    ctx.scale(camera_zoom, camera_zoom)
+
+    for link in softbody.links:
+        ctx.move_to(link.nodes[0].position.x, link.nodes[0].position.y)
+        ctx.line_to(link.nodes[1].position.x, link.nodes[1].position.y)
+        ctx.set_source_rgb(0, 0, 0)
+        ctx.set_line_width(0.03)
+        ctx.set_line_cap(cairo.LINE_CAP_ROUND)
+        ctx.stroke()
+
+    for node in softbody.nodes:
+        ctx.arc(node.position.x, node.position.y, 0.03, 0, tau)
+        ctx.set_source_rgb(1, 1, 1)
+        ctx.fill_preserve()
+        ctx.set_source_rgb(0, 0, 0)
+        ctx.set_line_width(0.02)
+        ctx.stroke()
+
+    surface.write_to_png(f"renders/render_{i}.png")
\ No newline at end of file
diff --git a/softbodies.py b/softbodies.py
index fbaf9cb..6e32836 100644
--- a/softbodies.py
+++ b/softbodies.py
@@ -91,7 +91,3 @@ class Link:
     def iterate(self, time: float) -> None:
         self.nodes[0].iterate(time)
         self.nodes[1].iterate(time)
-
-
-link = Link(nodes=(Node(mass=1, position=Point(0, 0)), Node(mass=1, position=Point(5, 0))), stiffness=1, dampening=0, resting_length=0.5)
-print(link.get_stiffness_force())
\ No newline at end of file

commit 39f8b15beedbc55dc09737b6492b01c37fa5c8f4
Author: Daxonus <elias@dobrin.net>
Date:   Tue Apr 5 19:03:23 2022 -0700

    render code

diff --git a/__pycache__/points.cpython-310.pyc b/__pycache__/points.cpython-310.pyc
index 4969507..ac11a62 100644
Binary files a/__pycache__/points.cpython-310.pyc and b/__pycache__/points.cpython-310.pyc differ
diff --git a/__pycache__/softbodies.cpython-310.pyc b/__pycache__/softbodies.cpython-310.pyc
new file mode 100644
index 0000000..8b7d7df
Binary files /dev/null and b/__pycache__/softbodies.cpython-310.pyc differ
diff --git a/__pycache__/structures.cpython-310.pyc b/__pycache__/structures.cpython-310.pyc
new file mode 100644
index 0000000..040032b
Binary files /dev/null and b/__pycache__/structures.cpython-310.pyc differ
diff --git a/__pycache__/test.cpython-310.pyc b/__pycache__/test.cpython-310.pyc
new file mode 100644
index 0000000..7e91431
Binary files /dev/null and b/__pycache__/test.cpython-310.pyc differ
diff --git a/example.png b/example.png
new file mode 100644
index 0000000..94ffc0e
Binary files /dev/null and b/example.png differ
diff --git a/render.py b/render.py
new file mode 100644
index 0000000..f330705
--- /dev/null
+++ b/render.py
@@ -0,0 +1,39 @@
+from math import tau
+import cairo
+from structures import Tower
+from points import Point
+
+softbody = Tower(position=Point(0, 0), size=(1, 1), grid=(2, 2), mass=1, stiffness=1, dampening=0)
+
+camera_position = Point(0, 0)
+camera_zoom = 0.5
+
+surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 256, 256)
+ctx = cairo.Context(surface)
+
+ctx.scale(256, 256)
+ctx.rectangle(0, 0, 1, 1)
+ctx.set_source_rgb(1, 0.94, 0.79)
+ctx.fill()
+ctx.translate(0.5, 0.5)
+ctx.scale(1, -1)
+ctx.translate(-camera_position.x, -camera_position.y)
+ctx.scale(camera_zoom, camera_zoom)
+
+for link in softbody.links:
+    ctx.move_to(link.nodes[0].position.x, link.nodes[0].position.y)
+    ctx.line_to(link.nodes[1].position.x, link.nodes[1].position.y)
+    ctx.set_source_rgb(0, 0, 0)
+    ctx.set_line_width(0.03)
+    ctx.set_line_cap(cairo.LINE_CAP_ROUND)
+    ctx.stroke()
+
+for node in softbody.nodes:
+    ctx.arc(node.position.x, node.position.y, 0.03, 0, tau)
+    ctx.set_source_rgb(1, 1, 1)
+    ctx.fill_preserve()
+    ctx.set_source_rgb(0, 0, 0)
+    ctx.set_line_width(0.02)
+    ctx.stroke()
+
+surface.write_to_png("example.png")
\ No newline at end of file
diff --git a/test.py b/test.py
index 7271fa5..dfc9144 100644
--- a/test.py
+++ b/test.py
@@ -15,10 +15,10 @@ links = [Link(nodes=(nodes[0], nodes[1]), stiffness=100, dampening=1),
          Link(nodes=(nodes[0], nodes[2]), stiffness=100, dampening=1, resting_length=2),
          Link(nodes=(nodes[1], nodes[3]), stiffness=100, dampening=1, resting_length=2)]
 #softbody = Softbody(nodes=nodes, links=links)
-softbody = Tower(position=Point(0, 0), size=(3, 7), grid=(3, 7), mass=100, stiffness=2000, dampening=0.1)
+softbody = Tower(position=Point(0, 0), size=(1, 7), grid=(1, 7), mass=100, stiffness=5000, dampening=10)
 #softbody = Pyramid(position=Point(0, 0), size=(2, 2), grid=3, mass=1, stiffness=100, dampening=0)
 #softbody = Blob(position=Point(0, 0), size=2)
-camera_position = Point(0, 0)
+camera_position = Point(0, -2)
 camera_zoom = 0.1
 
 
@@ -51,9 +51,6 @@ while running:
                 force * (link.nodes[1].position - link.nodes[0].position) / Point.dist(link.nodes[0].position,
                                                                                        link.nodes[1].position))
         softbody.nodes[0].force.set(Point(0, 0))
-        softbody.nodes[8].force.set(Point(0, 0))
-        softbody.nodes[16].force.set(Point(0, 0))
-        softbody.nodes[24].force.add(Point(softbody.nodes[24].mass * g * 2, softbody.nodes[24].mass * g * 5))
         softbody.iterate(time=0.005)
 
     screen.fill((0, 0, 0))

commit f3bb7acfd773a455502566f198961eb2be795acb
Author: Daxonus <elias@dobrin.net>
Date:   Sat Apr 2 14:16:34 2022 -0700

    structure code nicer, softbody library code nicer as well

diff --git a/softbodies.py b/softbodies.py
index 6ccbc92..fbaf9cb 100644
--- a/softbodies.py
+++ b/softbodies.py
@@ -23,15 +23,10 @@ class Softbody:
             center_mass += node.mass * node.position
         return center_mass
 
-    def apply_link_forces(self) -> None:
-        """Apply the force of each link on each of the corresponding nodes."""
-        for link in self.links:
-            link.apply_force()
-
-    def iterate(self, delta_time) -> None:
+    def iterate(self, time) -> None:
         """Integrate the position and velocity of each node with Euler's method."""
         for node in self.nodes:
-            node.iterate(delta_time)
+            node.iterate(time)
 
 
 class Node:
@@ -47,15 +42,10 @@ class Node:
         self.velocity = Point(0, 0)
         self.force = Point(0, 0)
 
-    def apply_force(self, force: Point) -> None:
-        """Add a singular force to the node."""
-        self.force += force
-
-    def iterate(self, delta_time: float) -> None:
+    def iterate(self, time: float) -> None:
         """Integrate the position and velocity with Euler's method."""
-        self.velocity += (self.force / self.mass) * delta_time
-        self.position += self.velocity * delta_time
-        self.force.set(Point(0, 0))
+        self.velocity += (self.force / self.mass) * time
+        self.position += self.velocity * time
 
 
 class Link:
@@ -98,8 +88,10 @@ class Link:
         """Get the spring force expansion/contraction (positive/negative)."""
         return self.get_stiffness_force() + self.get_dampening_force()
 
-    def apply_force(self) -> None:
-        """Apply the pair of opposite facing spring forces on the pair of nodes."""
-        self.nodes[0].apply_force(self.get_force() * ((self.nodes[0].position - self.nodes[1].position) / self.get_length()))
-        self.nodes[1].apply_force(self.get_force() * ((self.nodes[1].position - self.nodes[0].position) / self.get_length()))
+    def iterate(self, time: float) -> None:
+        self.nodes[0].iterate(time)
+        self.nodes[1].iterate(time)
+
 
+link = Link(nodes=(Node(mass=1, position=Point(0, 0)), Node(mass=1, position=Point(5, 0))), stiffness=1, dampening=0, resting_length=0.5)
+print(link.get_stiffness_force())
\ No newline at end of file
diff --git a/structures.py b/structures.py
index 827dad5..8066bec 100644
--- a/structures.py
+++ b/structures.py
@@ -4,7 +4,14 @@ from random import random
 from softbodies import Softbody, Node, Link, Point
 
 
-class Tower(Softbody):
+class Structure(Softbody):
+    def __init__(self, nodes: list[Node], links: list[Link]) -> None:
+        super().__init__(nodes, links)
+
+
+
+
+class Tower(Structure):
     def __init__(self, position: Point, size: tuple[float, float], grid: tuple[int, int], mass: float, stiffness: float,
                  dampening: float) -> None:
         nodes = []
@@ -30,7 +37,7 @@ class Tower(Softbody):
         super().__init__(nodes=[node for buffer in nodes for node in buffer], links=links)
 
 
-class Pyramid(Softbody):
+class Pyramid(Structure):
     def __init__(self, position: Point, size: tuple[float, float], grid: int, mass: float, stiffness: float,
                  dampening: float) -> None:
         nodes = []
@@ -57,7 +64,7 @@ class Pyramid(Softbody):
         super().__init__(nodes=[node for buffer in nodes for node in buffer], links=links)
 
 
-class Blob(Softbody):
+class Blob(Structure):
     def __init__(self, position: Point, size: float) -> None:
         nodes = []
         for n in range(30):
diff --git a/test.py b/test.py
index 3835319..7271fa5 100644
--- a/test.py
+++ b/test.py
@@ -15,11 +15,11 @@ links = [Link(nodes=(nodes[0], nodes[1]), stiffness=100, dampening=1),
          Link(nodes=(nodes[0], nodes[2]), stiffness=100, dampening=1, resting_length=2),
          Link(nodes=(nodes[1], nodes[3]), stiffness=100, dampening=1, resting_length=2)]
 #softbody = Softbody(nodes=nodes, links=links)
-#softbody = Tower(position=Point(0, 0), size=(4, 4), grid=(7, 7), mass=1, stiffness=50, dampening=0)
+softbody = Tower(position=Point(0, 0), size=(3, 7), grid=(3, 7), mass=100, stiffness=2000, dampening=0.1)
 #softbody = Pyramid(position=Point(0, 0), size=(2, 2), grid=3, mass=1, stiffness=100, dampening=0)
-softbody = Blob(position=Point(0, 0), size=2)
+#softbody = Blob(position=Point(0, 0), size=2)
 camera_position = Point(0, 0)
-camera_zoom = 0.2
+camera_zoom = 0.1
 
 
 def transformed(position: Point) -> tuple[float, float]:
@@ -39,16 +39,22 @@ while running:
         if event.type == pygame.QUIT:
             running = False
 
-    for node in softbody.nodes:
-        node.apply_force(force=Point(0, -node.mass * g))
-    softbody.apply_link_forces()
-
-    for n, node in enumerate(softbody.nodes):
-        if n == 0:
-            node.force.set(Point(0, 0))
-            continue
-        node.iterate(delta_time=0.01)
-
+    for n in range(5):
+        for node in softbody.nodes:
+            node.force.set(Point(0, -node.mass * g))
+        for link in softbody.links:
+            force = link.get_force()
+            link.nodes[0].force.add(
+                force * (link.nodes[0].position - link.nodes[1].position) / Point.dist(link.nodes[0].position,
+                                                                                       link.nodes[1].position))
+            link.nodes[1].force.add(
+                force * (link.nodes[1].position - link.nodes[0].position) / Point.dist(link.nodes[0].position,
+                                                                                       link.nodes[1].position))
+        softbody.nodes[0].force.set(Point(0, 0))
+        softbody.nodes[8].force.set(Point(0, 0))
+        softbody.nodes[16].force.set(Point(0, 0))
+        softbody.nodes[24].force.add(Point(softbody.nodes[24].mass * g * 2, softbody.nodes[24].mass * g * 5))
+        softbody.iterate(time=0.005)
 
     screen.fill((0, 0, 0))
 

commit b11321ae05d1595e3f5f33d7a72c358b2ce9688b
Author: Daxonus <elias@dobrin.net>
Date:   Sat Apr 2 08:44:47 2022 -0700

    crappy blob

diff --git a/structures.py b/structures.py
index bf01c5c..827dad5 100644
--- a/structures.py
+++ b/structures.py
@@ -1,5 +1,6 @@
 from __future__ import annotations
-import numpy as np
+from math import cos, sin, tau, sqrt
+from random import random
 from softbodies import Softbody, Node, Link, Point
 
 
@@ -54,3 +55,22 @@ class Pyramid(Softbody):
                 links.append(Link(nodes=(nodes[y][x + 1], nodes[y + 1][x]), stiffness=stiffness, dampening=dampening))
 
         super().__init__(nodes=[node for buffer in nodes for node in buffer], links=links)
+
+
+class Blob(Softbody):
+    def __init__(self, position: Point, size: float) -> None:
+        nodes = []
+        for n in range(30):
+            radius = (size / 2) * sqrt(random())
+            angle = tau * random()
+            nodes.append(Node(mass=1, position=Point(position.x + radius * cos(angle), position.y + radius * sin(angle))))
+        links = []
+        for n1 in range(30):
+            for n2 in range(n1 + 1, 30):
+                node_1 = nodes[n1]
+                node_2 = nodes[n2]
+
+                if Point.dist(node_1.position, node_2.position) <= size / 3:
+                    links.append(Link(nodes=(node_1, node_2), stiffness=200, dampening=0))
+
+        super().__init__(nodes=nodes, links=links)
\ No newline at end of file
diff --git a/test.py b/test.py
index 5e50f1f..3835319 100644
--- a/test.py
+++ b/test.py
@@ -2,7 +2,7 @@ from time import sleep
 from scipy.constants import g
 import pygame
 from softbodies import Softbody, Node, Link, Point
-from structures import Tower, Pyramid
+from structures import Tower, Pyramid, Blob
 
 nodes = [Node(mass=1, position=Point(1, 1)),
          Node(mass=1, position=Point(1, -1)),
@@ -16,8 +16,8 @@ links = [Link(nodes=(nodes[0], nodes[1]), stiffness=100, dampening=1),
          Link(nodes=(nodes[1], nodes[3]), stiffness=100, dampening=1, resting_length=2)]
 #softbody = Softbody(nodes=nodes, links=links)
 #softbody = Tower(position=Point(0, 0), size=(4, 4), grid=(7, 7), mass=1, stiffness=50, dampening=0)
-softbody = Pyramid(position=Point(0, 0), size=(2, 2), grid=7, mass=1, stiffness=1000, dampening=0)
-print(len(softbody.links))
+#softbody = Pyramid(position=Point(0, 0), size=(2, 2), grid=3, mass=1, stiffness=100, dampening=0)
+softbody = Blob(position=Point(0, 0), size=2)
 camera_position = Point(0, 0)
 camera_zoom = 0.2
 

commit b4d4d62f3171976aeeaa039de0cb638ae4e38813
Author: Daxonus <elias@dobrin.net>
Date:   Fri Apr 1 21:18:39 2022 -0700

    finished pyramid structure

diff --git a/structures.py b/structures.py
index 98e567b..bf01c5c 100644
--- a/structures.py
+++ b/structures.py
@@ -1,9 +1,11 @@
 from __future__ import annotations
+import numpy as np
 from softbodies import Softbody, Node, Link, Point
 
 
 class Tower(Softbody):
-    def __init__(self, position: Point, size: tuple[float, float], grid: tuple[int, int], mass: float, stiffness: float, dampening: float) -> None:
+    def __init__(self, position: Point, size: tuple[float, float], grid: tuple[int, int], mass: float, stiffness: float,
+                 dampening: float) -> None:
         nodes = []
         for x in range(grid[0] + 1):
             nodes.append([])
@@ -28,5 +30,27 @@ class Tower(Softbody):
 
 
 class Pyramid(Softbody):
-    def __init__(self, position: Point, size: tuple[float, float], grid: int, mass: float, stiffness: float, dampening: float) -> None:
-        nodes = []
\ No newline at end of file
+    def __init__(self, position: Point, size: tuple[float, float], grid: int, mass: float, stiffness: float,
+                 dampening: float) -> None:
+        nodes = []
+        for y in range(grid + 1):
+            nodes.append([])
+            for x in range(grid + 1 - y):
+                nodes[y].append(Node(mass=mass / ((grid + 1) * (grid + 2) / 2),
+                                     position=Point(position.x - size[0] / 2 + x,
+                                                    position.y - size[1] / 2 + y)))
+
+        links = []
+        for y in range(grid + 1):
+            for x in range(grid - y):
+                links.append(Link(nodes=(nodes[y][x], nodes[y][x + 1]), stiffness=stiffness, dampening=dampening))
+
+        for y in range(grid):
+            for x in range(grid - y):
+                links.append(Link(nodes=(nodes[y][x], nodes[y + 1][x]), stiffness=stiffness, dampening=dampening))
+
+        for y in range(grid):
+            for x in range(grid - y):
+                links.append(Link(nodes=(nodes[y][x + 1], nodes[y + 1][x]), stiffness=stiffness, dampening=dampening))
+
+        super().__init__(nodes=[node for buffer in nodes for node in buffer], links=links)
diff --git a/test.py b/test.py
index 23c9b06..5e50f1f 100644
--- a/test.py
+++ b/test.py
@@ -2,7 +2,7 @@ from time import sleep
 from scipy.constants import g
 import pygame
 from softbodies import Softbody, Node, Link, Point
-from structures import Tower
+from structures import Tower, Pyramid
 
 nodes = [Node(mass=1, position=Point(1, 1)),
          Node(mass=1, position=Point(1, -1)),
@@ -14,10 +14,10 @@ links = [Link(nodes=(nodes[0], nodes[1]), stiffness=100, dampening=1),
          Link(nodes=(nodes[3], nodes[0]), stiffness=100, dampening=1),
          Link(nodes=(nodes[0], nodes[2]), stiffness=100, dampening=1, resting_length=2),
          Link(nodes=(nodes[1], nodes[3]), stiffness=100, dampening=1, resting_length=2)]
-softbody = Softbody(nodes=nodes, links=links)
-softbody = Tower(position=Point(0, 0), size=(2, 2), grid=(2, 2), mass=1, stiffness=50, dampening=0)
-
-
+#softbody = Softbody(nodes=nodes, links=links)
+#softbody = Tower(position=Point(0, 0), size=(4, 4), grid=(7, 7), mass=1, stiffness=50, dampening=0)
+softbody = Pyramid(position=Point(0, 0), size=(2, 2), grid=7, mass=1, stiffness=1000, dampening=0)
+print(len(softbody.links))
 camera_position = Point(0, 0)
 camera_zoom = 0.2
 

commit d141066b5a451124748b5af00e531c54394573b3
Author: Daxonus <elias@dobrin.net>
Date:   Fri Apr 1 18:56:51 2022 -0700

    working on pyramid structure

diff --git a/structures.py b/structures.py
index 50916a4..98e567b 100644
--- a/structures.py
+++ b/structures.py
@@ -3,25 +3,30 @@ from softbodies import Softbody, Node, Link, Point
 
 
 class Tower(Softbody):
-    def __init__(self, mass: float, position: Point, size: tuple[float, float], grid: tuple[int, int]) -> None:
+    def __init__(self, position: Point, size: tuple[float, float], grid: tuple[int, int], mass: float, stiffness: float, dampening: float) -> None:
         nodes = []
         for x in range(grid[0] + 1):
             nodes.append([])
             for y in range(grid[1] + 1):
                 nodes[x].append(Node(mass=mass / ((grid[0] + 1) * (grid[1] + 1)),
-                                     position=Point(position.x + size[0] * (x / grid[0]),
-                                                    position.y + size[1] * (y / grid[1]))))
+                                     position=Point(position.x + size[0] * (x / grid[0] - 0.5),
+                                                    position.y + size[1] * (y / grid[1] - 0.5))))
         links = []
         for x in range(grid[0]):
             for y in range(grid[1] + 1):
-                links.append(Link(nodes=(nodes[x][y], nodes[x + 1][y]), stiffness=5000, dampening=0))
+                links.append(Link(nodes=(nodes[x][y], nodes[x + 1][y]), stiffness=stiffness, dampening=dampening))
         for x in range(grid[0] + 1):
             for y in range(grid[1]):
-                links.append(Link(nodes=(nodes[x][y], nodes[x][y + 1]), stiffness=5000, dampening=0))
+                links.append(Link(nodes=(nodes[x][y], nodes[x][y + 1]), stiffness=stiffness, dampening=dampening))
         for x in range(grid[0]):
             for y in range(grid[1]):
-                links.append(Link(nodes=(nodes[x][y], nodes[x + 1][y + 1]), stiffness=5000, dampening=0))
+                links.append(Link(nodes=(nodes[x][y], nodes[x + 1][y + 1]), stiffness=stiffness, dampening=dampening))
         for x in range(grid[0]):
             for y in range(grid[1]):
-                links.append(Link(nodes=(nodes[x + 1][y], nodes[x][y + 1]), stiffness=5000, dampening=0))
-        super().__init__(nodes=[node for buffer in nodes for node in buffer], links=links)
\ No newline at end of file
+                links.append(Link(nodes=(nodes[x + 1][y], nodes[x][y + 1]), stiffness=stiffness, dampening=dampening))
+        super().__init__(nodes=[node for buffer in nodes for node in buffer], links=links)
+
+
+class Pyramid(Softbody):
+    def __init__(self, position: Point, size: tuple[float, float], grid: int, mass: float, stiffness: float, dampening: float) -> None:
+        nodes = []
\ No newline at end of file
diff --git a/test.py b/test.py
index 5b9dde3..23c9b06 100644
--- a/test.py
+++ b/test.py
@@ -15,7 +15,7 @@ links = [Link(nodes=(nodes[0], nodes[1]), stiffness=100, dampening=1),
          Link(nodes=(nodes[0], nodes[2]), stiffness=100, dampening=1, resting_length=2),
          Link(nodes=(nodes[1], nodes[3]), stiffness=100, dampening=1, resting_length=2)]
 softbody = Softbody(nodes=nodes, links=links)
-softbody = Tower(mass=100, position=Point(0, 0), size=(2, 2), grid=(2, 2))
+softbody = Tower(position=Point(0, 0), size=(2, 2), grid=(2, 2), mass=1, stiffness=50, dampening=0)
 
 
 camera_position = Point(0, 0)
@@ -50,7 +50,7 @@ while running:
         node.iterate(delta_time=0.01)
 
 
-    screen.fill((255, 255, 255))
+    screen.fill((0, 0, 0))
 
     for link in softbody.links:
         pygame.draw.line(screen, color=(0, 0, 255), start_pos=transformed(link.nodes[0].position), end_pos=transformed(link.nodes[1].position), width=3)
@@ -59,4 +59,4 @@ while running:
         pygame.draw.circle(screen, color=(255, 0, 0), center=transformed(node.position), radius=3)
 
     pygame.display.flip()
-    sleep(1 / 60)
\ No newline at end of file
+    sleep(1 / 30)
\ No newline at end of file

commit 926e9616138f54de7a9b5befcbe238892cc06189
Author: Daxonus <elias@dobrin.net>
Date:   Fri Apr 1 18:30:56 2022 -0700

    tower mesh structure working

diff --git a/softbodies.py b/softbodies.py
index 8714456..6ccbc92 100644
--- a/softbodies.py
+++ b/softbodies.py
@@ -23,10 +23,6 @@ class Softbody:
             center_mass += node.mass * node.position
         return center_mass
 
-    def apply_force(self, force: Point) -> None:
-        for node in self.nodes:
-            node.apply_force(force)
-
     def apply_link_forces(self) -> None:
         """Apply the force of each link on each of the corresponding nodes."""
         for link in self.links:
diff --git a/structures.py b/structures.py
index 051ae69..50916a4 100644
--- a/structures.py
+++ b/structures.py
@@ -1,40 +1,27 @@
-from itertools import combinations
-from math import cos, sin, tau
+from __future__ import annotations
 from softbodies import Softbody, Node, Link, Point
 
 
-class HollowPolygon(Softbody):
-    def __init__(self, center: Point, major_radius: float, total_mass: float, number_sides: int, stiffness: float, dampening: float) -> None:
+class Tower(Softbody):
+    def __init__(self, mass: float, position: Point, size: tuple[float, float], grid: tuple[int, int]) -> None:
         nodes = []
-        for n in range(number_sides):
-            angle = tau * (n / number_sides)
-            offset = Point(major_radius * cos(angle), major_radius * sin(angle))
-            nodes.append(Node(mass=total_mass / number_sides,
-                              position=center + offset))
-
-        links = []
-        for n in range(number_sides):
-            links.append(Link(nodes=(nodes[n], nodes[(n + 1) % number_sides]),
-                              stiffness=stiffness,
-                              dampening=dampening))
-        super().__init__(nodes, links)
-
-
-class CrazyPolygon(Softbody):
-    def __init__(self, center: Point, major_radius: float, total_mass: float, number_sides: int, stiffness: float, dampening: float):
-        nodes = []
-        for n in range(number_sides):
-            angle = tau * (n / number_sides)
-            offset = Point(major_radius * cos(angle), major_radius * sin(angle))
-            nodes.append(Node(mass=total_mass / number_sides,
-                              position=center + offset))
-
+        for x in range(grid[0] + 1):
+            nodes.append([])
+            for y in range(grid[1] + 1):
+                nodes[x].append(Node(mass=mass / ((grid[0] + 1) * (grid[1] + 1)),
+                                     position=Point(position.x + size[0] * (x / grid[0]),
+                                                    position.y + size[1] * (y / grid[1]))))
         links = []
-        for pair_nodes in combinations(nodes, 2):
-            links.append(Link(nodes=pair_nodes,
-                              stiffness=stiffness,
-                              dampening=dampening))
-        super().__init__(nodes, links)
-
-
-a = CrazyPolygon(center=Point(0, 0), major_radius=1, total_mass=100, number_sides=10, stiffness=25, dampening=1)
\ No newline at end of file
+        for x in range(grid[0]):
+            for y in range(grid[1] + 1):
+                links.append(Link(nodes=(nodes[x][y], nodes[x + 1][y]), stiffness=5000, dampening=0))
+        for x in range(grid[0] + 1):
+            for y in range(grid[1]):
+                links.append(Link(nodes=(nodes[x][y], nodes[x][y + 1]), stiffness=5000, dampening=0))
+        for x in range(grid[0]):
+            for y in range(grid[1]):
+                links.append(Link(nodes=(nodes[x][y], nodes[x + 1][y + 1]), stiffness=5000, dampening=0))
+        for x in range(grid[0]):
+            for y in range(grid[1]):
+                links.append(Link(nodes=(nodes[x + 1][y], nodes[x][y + 1]), stiffness=5000, dampening=0))
+        super().__init__(nodes=[node for buffer in nodes for node in buffer], links=links)
\ No newline at end of file
diff --git a/test.py b/test.py
index 66e06e2..5b9dde3 100644
--- a/test.py
+++ b/test.py
@@ -1,6 +1,8 @@
+from time import sleep
 from scipy.constants import g
 import pygame
 from softbodies import Softbody, Node, Link, Point
+from structures import Tower
 
 nodes = [Node(mass=1, position=Point(1, 1)),
          Node(mass=1, position=Point(1, -1)),
@@ -13,9 +15,8 @@ links = [Link(nodes=(nodes[0], nodes[1]), stiffness=100, dampening=1),
          Link(nodes=(nodes[0], nodes[2]), stiffness=100, dampening=1, resting_length=2),
          Link(nodes=(nodes[1], nodes[3]), stiffness=100, dampening=1, resting_length=2)]
 softbody = Softbody(nodes=nodes, links=links)
+softbody = Tower(mass=100, position=Point(0, 0), size=(2, 2), grid=(2, 2))
 
-from structures import a
-softbody = a
 
 camera_position = Point(0, 0)
 camera_zoom = 0.2
@@ -38,22 +39,24 @@ while running:
         if event.type == pygame.QUIT:
             running = False
 
-    softbody.apply_force(Point(0, -1 * g))
+    for node in softbody.nodes:
+        node.apply_force(force=Point(0, -node.mass * g))
     softbody.apply_link_forces()
 
     for n, node in enumerate(softbody.nodes):
-        if n == 3:
+        if n == 0:
             node.force.set(Point(0, 0))
             continue
-        node.iterate(delta_time=0.001)
+        node.iterate(delta_time=0.01)
 
 
     screen.fill((255, 255, 255))
 
     for link in softbody.links:
-        pygame.draw.line(screen, color=(0, 0, 255), start_pos=transformed(link.nodes[0].position), end_pos=transformed(link.nodes[1].position), width=5)
+        pygame.draw.line(screen, color=(0, 0, 255), start_pos=transformed(link.nodes[0].position), end_pos=transformed(link.nodes[1].position), width=3)
 
     for node in softbody.nodes:
         pygame.draw.circle(screen, color=(255, 0, 0), center=transformed(node.position), radius=3)
 
-    pygame.display.flip()
\ No newline at end of file
+    pygame.display.flip()
+    sleep(1 / 60)
\ No newline at end of file

commit 05e20333571b0fad39c5c4879801fd58e69f74bf
Author: Daxonus <elias@dobrin.net>
Date:   Fri Apr 1 09:21:28 2022 -0700

    made 2 structures circle and circle with lots of supports

diff --git a/dump.py b/dump.py
new file mode 100644
index 0000000..a38bc8d
--- /dev/null
+++ b/dump.py
@@ -0,0 +1,28 @@
+from test import softbody
+from rich.console import Console
+from rich.table import Table
+
+console = Console()
+
+table = Table(show_header=True, header_style="bold magenta")
+table.add_column("Date", style="dim", width=12)
+table.add_column("Title")
+table.add_column("Production Budget", justify="right")
+table.add_column("Box Office", justify="right")
+table.add_row(
+    "Dec 20, 2019", "Star Wars: The Rise of Skywalker", "$275,000,000", "$375,126,118"
+)
+table.add_row(
+    "May 25, 2018",
+    "[red]Solo[/red]: A Star Wars Story",
+    "$275,000,000",
+    "$393,151,347",
+)
+table.add_row(
+    "Dec 15, 2017",
+    "Star Wars Ep. VIII: The Last Jedi",
+    "$262,000,000",
+    "[bold]$1,332,539,889[/bold]",
+)
+
+console.print(table)
\ No newline at end of file
diff --git a/softbodies.py b/softbodies.py
index 53b9c4e..8714456 100644
--- a/softbodies.py
+++ b/softbodies.py
@@ -11,6 +11,18 @@ class Softbody:
         self.nodes = nodes
         self.links = links
 
+    def get_total_mass(self) -> float:
+        total_mass = 0
+        for node in self.nodes:
+            total_mass += node.mass
+        return total_mass
+
+    def get_center_mass(self) -> Point:
+        center_mass = Point(0, 0)
+        for node in self.nodes:
+            center_mass += node.mass * node.position
+        return center_mass
+
     def apply_force(self, force: Point) -> None:
         for node in self.nodes:
             node.apply_force(force)
diff --git a/structures.py b/structures.py
index db9e3b4..051ae69 100644
--- a/structures.py
+++ b/structures.py
@@ -1,2 +1,40 @@
+from itertools import combinations
+from math import cos, sin, tau
 from softbodies import Softbody, Node, Link, Point
 
+
+class HollowPolygon(Softbody):
+    def __init__(self, center: Point, major_radius: float, total_mass: float, number_sides: int, stiffness: float, dampening: float) -> None:
+        nodes = []
+        for n in range(number_sides):
+            angle = tau * (n / number_sides)
+            offset = Point(major_radius * cos(angle), major_radius * sin(angle))
+            nodes.append(Node(mass=total_mass / number_sides,
+                              position=center + offset))
+
+        links = []
+        for n in range(number_sides):
+            links.append(Link(nodes=(nodes[n], nodes[(n + 1) % number_sides]),
+                              stiffness=stiffness,
+                              dampening=dampening))
+        super().__init__(nodes, links)
+
+
+class CrazyPolygon(Softbody):
+    def __init__(self, center: Point, major_radius: float, total_mass: float, number_sides: int, stiffness: float, dampening: float):
+        nodes = []
+        for n in range(number_sides):
+            angle = tau * (n / number_sides)
+            offset = Point(major_radius * cos(angle), major_radius * sin(angle))
+            nodes.append(Node(mass=total_mass / number_sides,
+                              position=center + offset))
+
+        links = []
+        for pair_nodes in combinations(nodes, 2):
+            links.append(Link(nodes=pair_nodes,
+                              stiffness=stiffness,
+                              dampening=dampening))
+        super().__init__(nodes, links)
+
+
+a = CrazyPolygon(center=Point(0, 0), major_radius=1, total_mass=100, number_sides=10, stiffness=25, dampening=1)
\ No newline at end of file
diff --git a/test.py b/test.py
index 332f776..66e06e2 100644
--- a/test.py
+++ b/test.py
@@ -14,6 +14,9 @@ links = [Link(nodes=(nodes[0], nodes[1]), stiffness=100, dampening=1),
          Link(nodes=(nodes[1], nodes[3]), stiffness=100, dampening=1, resting_length=2)]
 softbody = Softbody(nodes=nodes, links=links)
 
+from structures import a
+softbody = a
+
 camera_position = Point(0, 0)
 camera_zoom = 0.2
 
@@ -51,6 +54,6 @@ while running:
         pygame.draw.line(screen, color=(0, 0, 255), start_pos=transformed(link.nodes[0].position), end_pos=transformed(link.nodes[1].position), width=5)
 
     for node in softbody.nodes:
-        pygame.draw.circle(screen, color=(255, 0, 0), center=transformed(node.position), radius=10)
+        pygame.draw.circle(screen, color=(255, 0, 0), center=transformed(node.position), radius=3)
 
     pygame.display.flip()
\ No newline at end of file

commit e0f0a6648c6d3bd28e36a586ce57deb45a01d58e
Author: Daxonus <elias@dobrin.net>
Date:   Thu Mar 31 21:07:40 2022 -0700

    changed some softbody methods, added test rendering, added empty structures file

diff --git a/animat_1.py b/animat_1.py
deleted file mode 100644
index e69de29..0000000
diff --git a/softbodies.py b/softbodies.py
index fd290a2..53b9c4e 100644
--- a/softbodies.py
+++ b/softbodies.py
@@ -11,6 +11,10 @@ class Softbody:
         self.nodes = nodes
         self.links = links
 
+    def apply_force(self, force: Point) -> None:
+        for node in self.nodes:
+            node.apply_force(force)
+
     def apply_link_forces(self) -> None:
         """Apply the force of each link on each of the corresponding nodes."""
         for link in self.links:
@@ -32,19 +36,18 @@ class Node:
     def __init__(self, mass: float, position: Point) -> None:
         self.mass = mass
         self.position = position
+        self.velocity = Point(0, 0)
+        self.force = Point(0, 0)
 
     def apply_force(self, force: Point) -> None:
         """Add a singular force to the node."""
         self.force += force
 
-    def reset_force(self) -> None:
-        """Reset the force applied on the node."""
-        self.force = Point(0, 0)
-
     def iterate(self, delta_time: float) -> None:
         """Integrate the position and velocity with Euler's method."""
         self.velocity += (self.force / self.mass) * delta_time
         self.position += self.velocity * delta_time
+        self.force.set(Point(0, 0))
 
 
 class Link:
@@ -54,9 +57,12 @@ class Link:
     stiffness: float
     dampening: float
 
-    def __init__(self, nodes: tuple[Node, Node], resting_length: float, stiffness: float, dampening: float) -> None:
+    def __init__(self, nodes: tuple[Node, Node], stiffness: float, dampening: float, resting_length: float = None) -> None:
         self.nodes = nodes
-        self.resting_length = resting_length
+        if resting_length is None:
+            self.resting_length = Point.dist(nodes[0].position, nodes[1].position)
+        else:
+            self.resting_length = resting_length
         self.stiffness = stiffness
         self.dampening = dampening
 
diff --git a/structures.py b/structures.py
new file mode 100644
index 0000000..db9e3b4
--- /dev/null
+++ b/structures.py
@@ -0,0 +1,2 @@
+from softbodies import Softbody, Node, Link, Point
+
diff --git a/test.py b/test.py
new file mode 100644
index 0000000..332f776
--- /dev/null
+++ b/test.py
@@ -0,0 +1,56 @@
+from scipy.constants import g
+import pygame
+from softbodies import Softbody, Node, Link, Point
+
+nodes = [Node(mass=1, position=Point(1, 1)),
+         Node(mass=1, position=Point(1, -1)),
+         Node(mass=1, position=Point(-1, -1)),
+         Node(mass=1, position=Point(-1, 1))]
+links = [Link(nodes=(nodes[0], nodes[1]), stiffness=100, dampening=1),
+         Link(nodes=(nodes[1], nodes[2]), stiffness=100, dampening=1),
+         Link(nodes=(nodes[2], nodes[3]), stiffness=100, dampening=1),
+         Link(nodes=(nodes[3], nodes[0]), stiffness=100, dampening=1),
+         Link(nodes=(nodes[0], nodes[2]), stiffness=100, dampening=1, resting_length=2),
+         Link(nodes=(nodes[1], nodes[3]), stiffness=100, dampening=1, resting_length=2)]
+softbody = Softbody(nodes=nodes, links=links)
+
+camera_position = Point(0, 0)
+camera_zoom = 0.2
+
+
+def transformed(position: Point) -> tuple[float, float]:
+    return (500 * (camera_zoom * (position.x - camera_position.x) + 0.5),
+            500 - (500 * (camera_zoom * (position.y - camera_position.y) + 0.5)))
+
+
+pygame.init()
+screen = pygame.display.set_mode((500, 500))
+
+clock = pygame.time.Clock()
+
+running = True
+
+while running:
+    for event in pygame.event.get():
+        if event.type == pygame.QUIT:
+            running = False
+
+    softbody.apply_force(Point(0, -1 * g))
+    softbody.apply_link_forces()
+
+    for n, node in enumerate(softbody.nodes):
+        if n == 3:
+            node.force.set(Point(0, 0))
+            continue
+        node.iterate(delta_time=0.001)
+
+
+    screen.fill((255, 255, 255))
+
+    for link in softbody.links:
+        pygame.draw.line(screen, color=(0, 0, 255), start_pos=transformed(link.nodes[0].position), end_pos=transformed(link.nodes[1].position), width=5)
+
+    for node in softbody.nodes:
+        pygame.draw.circle(screen, color=(255, 0, 0), center=transformed(node.position), radius=10)
+
+    pygame.display.flip()
\ No newline at end of file

commit 406ad8840a3022ca9981c8f792c66881e6048fc0
Author: Daxonus <elias@dobrin.net>
Date:   Thu Mar 31 12:04:31 2022 -0700

    lots of docs

diff --git a/softbodies.py b/softbodies.py
index 36c8465..fd290a2 100644
--- a/softbodies.py
+++ b/softbodies.py
@@ -3,6 +3,7 @@ from points import Point
 
 
 class Softbody:
+    """A spring-network type softbody consisting of nodes (point masses) and links (Hookean springs)."""
     nodes: list[Node]
     links: list[Link]
 
@@ -10,12 +11,22 @@ class Softbody:
         self.nodes = nodes
         self.links = links
 
+    def apply_link_forces(self) -> None:
+        """Apply the force of each link on each of the corresponding nodes."""
+        for link in self.links:
+            link.apply_force()
+
+    def iterate(self, delta_time) -> None:
+        """Integrate the position and velocity of each node with Euler's method."""
+        for node in self.nodes:
+            node.iterate(delta_time)
+
 
 class Node:
+    """A point mass particle that implements Euler integration."""
     mass: float
     position: Point
     velocity: Point
-    acceleration: Point
     force: Point
 
     def __init__(self, mass: float, position: Point) -> None:
@@ -23,10 +34,21 @@ class Node:
         self.position = position
 
     def apply_force(self, force: Point) -> None:
+        """Add a singular force to the node."""
         self.force += force
 
+    def reset_force(self) -> None:
+        """Reset the force applied on the node."""
+        self.force = Point(0, 0)
+
+    def iterate(self, delta_time: float) -> None:
+        """Integrate the position and velocity with Euler's method."""
+        self.velocity += (self.force / self.mass) * delta_time
+        self.position += self.velocity * delta_time
+
 
 class Link:
+    """A massless Hookean spring that features a stiffness force and a spring force."""
     nodes: tuple[Node, Node]
     resting_length: float
     stiffness: float
@@ -39,24 +61,31 @@ class Link:
         self.dampening = dampening
 
     def get_length(self) -> float:
+        """Get the momentary length of the link."""
         return Point.dist(self.nodes[0].position, self.nodes[1].position)
 
     def get_speed(self) -> float:
+        """Get the speed of the expansion/contraction of the link (positive/negative)."""
         return Point.dot(self.nodes[0].position - self.nodes[1].position, self.nodes[0].velocity - self.nodes[1].velocity) / self.get_length()
 
     def get_displacement(self) -> float:
+        """Get the expansion/contraction of the link from its resting configuration (positive/negative)."""
         return self.get_length() - self.resting_length
 
     def get_stiffness_force(self) -> float:
+        """Get the spring stiffness force expansion/contraction (positive/negative)."""
         return -self.stiffness * self.get_displacement()
 
     def get_dampening_force(self) -> float:
+        """Get the spring dampening force expansion/contraction (positive/negative)."""
         return -self.dampening * self.get_speed()
 
     def get_force(self) -> float:
+        """Get the spring force expansion/contraction (positive/negative)."""
         return self.get_stiffness_force() + self.get_dampening_force()
 
     def apply_force(self) -> None:
-        self.nodes[0].apply_force(self.get_spring_force() * ((self.nodes[0].position - self.nodes[1].position) / self.get_length()))
-        self.nodes[1].apply_force(self.get_spring_force() * ((self.nodes[1].position - self.nodes[0].position) / self.get_length()))
+        """Apply the pair of opposite facing spring forces on the pair of nodes."""
+        self.nodes[0].apply_force(self.get_force() * ((self.nodes[0].position - self.nodes[1].position) / self.get_length()))
+        self.nodes[1].apply_force(self.get_force() * ((self.nodes[1].position - self.nodes[0].position) / self.get_length()))
 

commit 1b3373d8f2d1dbe17eae673062874e0842b2fb59
Author: Daxonus <elias@dobrin.net>
Date:   Thu Mar 31 11:32:25 2022 -0700

    again

diff --git a/softbodies.py b/softbodies.py
index e5b38b0..36c8465 100644
--- a/softbodies.py
+++ b/softbodies.py
@@ -6,6 +6,11 @@ class Softbody:
     nodes: list[Node]
     links: list[Link]
 
+    def __init__(self, nodes: list[Node], links: list[Link]) -> None:
+        self.nodes = nodes
+        self.links = links
+
+
 class Node:
     mass: float
     position: Point

commit 8324b7300586ba16c992dcf3f3c76c6fcbb8c8f8
Author: Daxonus <elias@dobrin.net>
Date:   Thu Mar 31 11:31:13 2022 -0700

    clean basic softbody data structure

diff --git a/softbodies.py b/softbodies.py
new file mode 100644
index 0000000..e5b38b0
--- /dev/null
+++ b/softbodies.py
@@ -0,0 +1,57 @@
+from __future__ import annotations
+from points import Point
+
+
+class Softbody:
+    nodes: list[Node]
+    links: list[Link]
+
+class Node:
+    mass: float
+    position: Point
+    velocity: Point
+    acceleration: Point
+    force: Point
+
+    def __init__(self, mass: float, position: Point) -> None:
+        self.mass = mass
+        self.position = position
+
+    def apply_force(self, force: Point) -> None:
+        self.force += force
+
+
+class Link:
+    nodes: tuple[Node, Node]
+    resting_length: float
+    stiffness: float
+    dampening: float
+
+    def __init__(self, nodes: tuple[Node, Node], resting_length: float, stiffness: float, dampening: float) -> None:
+        self.nodes = nodes
+        self.resting_length = resting_length
+        self.stiffness = stiffness
+        self.dampening = dampening
+
+    def get_length(self) -> float:
+        return Point.dist(self.nodes[0].position, self.nodes[1].position)
+
+    def get_speed(self) -> float:
+        return Point.dot(self.nodes[0].position - self.nodes[1].position, self.nodes[0].velocity - self.nodes[1].velocity) / self.get_length()
+
+    def get_displacement(self) -> float:
+        return self.get_length() - self.resting_length
+
+    def get_stiffness_force(self) -> float:
+        return -self.stiffness * self.get_displacement()
+
+    def get_dampening_force(self) -> float:
+        return -self.dampening * self.get_speed()
+
+    def get_force(self) -> float:
+        return self.get_stiffness_force() + self.get_dampening_force()
+
+    def apply_force(self) -> None:
+        self.nodes[0].apply_force(self.get_spring_force() * ((self.nodes[0].position - self.nodes[1].position) / self.get_length()))
+        self.nodes[1].apply_force(self.get_spring_force() * ((self.nodes[1].position - self.nodes[0].position) / self.get_length()))
+

commit 4b393a8db4d110ac32767e7eb43b3aa337734bf9
Author: Daxonus <elias@dobrin.net>
Date:   Wed Mar 30 20:29:29 2022 -0700

    changed points library from 3d to 2d

diff --git a/circle.py b/circle.py
deleted file mode 100644
index 8798d01..0000000
--- a/circle.py
+++ /dev/null
@@ -1,159 +0,0 @@
-from __future__ import annotations
-from math import tau, cos, sin
-import numpy as np
-from scipy.constants import g
-import pygame
-from points import Point
-
-
-class System:
-    nodes: list[Node]
-    links: list[Link]
-
-    def __init__(self, nodes: list[Node], links: list[Link]) -> None:
-        self.nodes = nodes
-        self.links = links
-
-    def __str__(self) -> str:
-        return f"Nodes {self.nodes}\nLinks {self.links}"
-
-    def iterate(self, delta_time: float) -> None:
-        for node in self.nodes:
-            node.iterate(delta_time)
-
-
-class Node:
-    mass: float
-    position: Point
-    velocity: Point
-    acceleration: Point
-    force: Point
-
-    def __init__(self, mass: float, position: Point, velocity: Point, acceleration: Point, force: Point) -> None:
-        self.mass = mass
-        self.position = position
-        self.velocity = velocity
-        self.acceleration = acceleration
-        self.force = force
-
-    def __repr__(self) -> str:
-        return f"Node{self.position}"
-
-    def update_acceleration(self) -> None:
-        self.acceleration = self.force / self.mass
-
-    def iterate(self, delta_time) -> None:
-        self.update_acceleration()
-        self.velocity += self.acceleration * delta_time
-        self.position += self.velocity * delta_time
-
-
-class Link:
-    nodes: tuple[Node, Node]
-    resting_distance: float
-    actual_distance: float
-    stiffness: float
-    dampening: float
-    actual_speed: float
-
-    def __init__(self, nodes: tuple[Node, Node], resting_distance: float, actual_distance: float, stiffness: float, dampening: float, actual_speed: float) -> None:
-        self.nodes = nodes
-        self.resting_distance = resting_distance
-        self.actual_distance = actual_distance
-        self.stiffness = stiffness
-        self.dampening = dampening
-        self.actual_speed = actual_speed
-
-    def __repr__(self) -> str:
-        return f"{self.nodes[0].position} <- Link -> {self.nodes[1].position}"
-
-    def get_unit_vector(self) -> Point:
-        return (self.nodes[0].position - self.nodes[1].position) / self.resting_distance
-
-    def get_displacement(self) -> float:
-        return self.actual_distance - self.resting_distance
-
-    def get_stiffness_force(self) -> float:
-        return -self.stiffness * self.get_displacement()
-
-    def get_dampening_force(self) -> float:
-        return -self.dampening * self.actual_speed
-
-    def get_spring_force(self) -> float:
-        return self.get_stiffness_force() + self.get_dampening_force()
-
-    def update_actual_distance(self) -> float:
-        previous_distance = self.actual_distance
-        self.actual_distance = Point.dist(self.nodes[0].position, self.nodes[1].position)
-        return previous_distance
-
-    def update_actual_speed(self, delta_time: float) -> None:
-        previous_distance = self.update_actual_distance()
-        self.actual_speed = (self.actual_distance - previous_distance) / delta_time
-
-    def apply_forces(self) -> None:
-        self.nodes[0].force += self.get_spring_force() * self.get_unit_vector()
-        self.nodes[1].force -= self.get_spring_force() * self.get_unit_vector()
-
-
-nodes = [Node(mass=1, position=Point(cos(tau * n / 10), sin(tau * n / 10)), velocity=Point(0, 0), acceleration=Point(0, 0), force=Point(0, 0)) for n in range(10)]
-
-links = [Link(nodes=(nodes[n], nodes[(n + 1) % 10]), resting_distance=tau / 10, actual_distance=tau / 10, stiffness=1, dampening=1, actual_speed=0) for n in range(10)]
-
-system = System(nodes=nodes, links=links)
-
-
-iteration = 1
-iterations = 30000
-delta_time = 0.001
-
-
-
-view_minimum = Point(-2, -6)
-view_maximum = Point(12, 8)
-
-pygame.init()
-screen = pygame.display.set_mode([500, 500])
-
-def transformed(point: Point) -> Point:
-    return Point(500 * (point.x - view_minimum.x) / (view_maximum.x - view_minimum.x),
-                 500 * (1 - (point.y - view_minimum.y) / (view_maximum.y - view_minimum.y)))
-
-running = True
-
-for i in range(iterations):
-    for node in system.nodes:
-        node.force.set(Point(0, 0, 0))
-
-    for node in system.nodes:
-        node.force.y -= node.mass * g
-
-    for link in system.links:
-        link.update_actual_speed(delta_time)
-        link.apply_forces()
-
-    for node in system.nodes:
-        node.iterate(delta_time)
-
-    for event in pygame.event.get():
-        if event.type == pygame.QUIT:
-            running = False
-
-    if not running:
-        break
-
-    screen.fill((255, 255, 255))
-
-    for link in system.links:
-        t1 = transformed(link.nodes[0].position)
-        t2 = transformed(link.nodes[1].position)
-        pygame.draw.line(screen, (255, 0, 0), (t1.x, t1.y), (t2.x, t2.y), 3)
-
-    for node in system.nodes:
-        t1 = transformed(node.position)
-        pygame.draw.circle(screen, (0, 0, 255), (t1.x, t1.y), 3)
-
-    pygame.display.flip()
-    iteration += 1
-
-pygame.quit()
\ No newline at end of file
diff --git a/object_1.py b/object_1.py
new file mode 100644
index 0000000..2e4a20c
--- /dev/null
+++ b/object_1.py
@@ -0,0 +1,4 @@
+from __future__ import annotations
+from scipy.constants import g
+import pygame
+from points import Point
\ No newline at end of file
diff --git a/points.py b/points.py
index 4027971..79c917c 100644
--- a/points.py
+++ b/points.py
@@ -1,4 +1,4 @@
-"""Python module for dealing with three-dimensional cartesian coordinates and vector operations."""
+"""Python module for dealing with two-dimensional cartesian coordinates and vector operations."""
 
 from __future__ import annotations
 from math import hypot
@@ -6,25 +6,22 @@ from collections.abc import Iterator
 
 
 class Point:
-    """Three-dimensional point represented in cartesian coordinates."""
+    """Two-dimensional point represented in cartesian coordinates."""
     x: float
     y: float
-    z: float
 
-    def __init__(self, x: float, y: float, z: float = 0) -> None:
+    def __init__(self, x: float, y: float) -> None:
         """Instantiate a point from cartesian coordinates."""
         self.x = x
         self.y = y
-        self.z = z
 
     def __iter__(self) -> Iterator[float]:
         """Iterate through the pair of coordinates."""
         yield self.x
         yield self.y
-        yield self.z
 
     def __str__(self) -> str:
-        return f"({self.x}, {self.y}, {self.z})"
+        return f"({self.x}, {self.y})"
 
     def __add__(self, point: Point, /) -> Point:
         """(+) Add caller point with parameter point, without modification to point."""
@@ -74,7 +71,7 @@ class Point:
         """(@) Find the dot product of two points as vectors."""
         return self.dot(point)
 
-    def __mod__(self, point: Point, /) -> Point:
+    def __mod__(self, point: Point, /) -> float:
         """(%) Find the cross product of two points as vectors."""
         return self.cross(point)
 
@@ -82,55 +79,48 @@ class Point:
         """Set coordinates of caller point to match parameter point."""
         self.x = point.x
         self.y = point.y
-        self.z = point.z
         return self
 
     def add(self, point: Point, /) -> Point:
         """Add caller point with parameter point, with modification to caller point."""
         self.x += point.x
         self.y += point.y
-        self.z += point.z
         return self
 
     def sub(self, point: Point, /) -> Point:
         """Subtract parameter point from caller point, with modification to caller point."""
         self.x -= point.x
         self.y -= point.y
-        self.z -= point.z
         return self
 
     def mul(self, multiplier: float, /) -> Point:
         """Multiply point coordinates by a number, with modification to point."""
         self.x *= multiplier
         self.y *= multiplier
-        self.z *= multiplier
         return self
 
     def div(self, divisor: float, /) -> Point:
         """Divide point coordinates by a number, with modification to point."""
         self.x /= divisor
         self.y /= divisor
-        self.z /= divisor
         return self
 
     def len(self) -> float:
         """Find the distance to the origin."""
-        return hypot(self.x, self.y, self.z)
+        return hypot(self.x, self.y)
 
     def dist(self, point: Point, /) -> float:
         """Find the distance between two points."""
-        return hypot(self.x - point.x, self.y - point.y, self.z - point.z)
+        return hypot(self.x - point.x, self.y - point.y)
 
     def dot(self, point: Point, /) -> float:
         """Find the dot product of two points."""
-        return self.x * point.x + self.y * point.y + self.z * point.z
+        return self.x * point.x + self.y * point.y
 
-    def cross(self, point: Point, /) -> Point:
+    def cross(self, point: Point, /) -> float:
         """Find the cross product of two points."""
-        return Point(self.y * point.z - self.z * point.y,
-                     self.z * point.x - self.x * point.z,
-                     self.x * point.y - self.y * point.x)
+        return self.x * point.y - self.y * point.x
 
     def copy(self) -> Point:
         """Copy the point instance."""
-        return Point(self.x, self.y, self.z)
+        return Point(self.x, self.y)

commit a6aec5fefead6edee4a7770557f38c1755eb3094
Author: Daxonus <elias@dobrin.net>
Date:   Wed Mar 30 12:31:30 2022 -0700

    made a circle whooo

diff --git a/animat_1.py b/animat_1.py
new file mode 100644
index 0000000..e69de29
diff --git a/circle.py b/circle.py
new file mode 100644
index 0000000..8798d01
--- /dev/null
+++ b/circle.py
@@ -0,0 +1,159 @@
+from __future__ import annotations
+from math import tau, cos, sin
+import numpy as np
+from scipy.constants import g
+import pygame
+from points import Point
+
+
+class System:
+    nodes: list[Node]
+    links: list[Link]
+
+    def __init__(self, nodes: list[Node], links: list[Link]) -> None:
+        self.nodes = nodes
+        self.links = links
+
+    def __str__(self) -> str:
+        return f"Nodes {self.nodes}\nLinks {self.links}"
+
+    def iterate(self, delta_time: float) -> None:
+        for node in self.nodes:
+            node.iterate(delta_time)
+
+
+class Node:
+    mass: float
+    position: Point
+    velocity: Point
+    acceleration: Point
+    force: Point
+
+    def __init__(self, mass: float, position: Point, velocity: Point, acceleration: Point, force: Point) -> None:
+        self.mass = mass
+        self.position = position
+        self.velocity = velocity
+        self.acceleration = acceleration
+        self.force = force
+
+    def __repr__(self) -> str:
+        return f"Node{self.position}"
+
+    def update_acceleration(self) -> None:
+        self.acceleration = self.force / self.mass
+
+    def iterate(self, delta_time) -> None:
+        self.update_acceleration()
+        self.velocity += self.acceleration * delta_time
+        self.position += self.velocity * delta_time
+
+
+class Link:
+    nodes: tuple[Node, Node]
+    resting_distance: float
+    actual_distance: float
+    stiffness: float
+    dampening: float
+    actual_speed: float
+
+    def __init__(self, nodes: tuple[Node, Node], resting_distance: float, actual_distance: float, stiffness: float, dampening: float, actual_speed: float) -> None:
+        self.nodes = nodes
+        self.resting_distance = resting_distance
+        self.actual_distance = actual_distance
+        self.stiffness = stiffness
+        self.dampening = dampening
+        self.actual_speed = actual_speed
+
+    def __repr__(self) -> str:
+        return f"{self.nodes[0].position} <- Link -> {self.nodes[1].position}"
+
+    def get_unit_vector(self) -> Point:
+        return (self.nodes[0].position - self.nodes[1].position) / self.resting_distance
+
+    def get_displacement(self) -> float:
+        return self.actual_distance - self.resting_distance
+
+    def get_stiffness_force(self) -> float:
+        return -self.stiffness * self.get_displacement()
+
+    def get_dampening_force(self) -> float:
+        return -self.dampening * self.actual_speed
+
+    def get_spring_force(self) -> float:
+        return self.get_stiffness_force() + self.get_dampening_force()
+
+    def update_actual_distance(self) -> float:
+        previous_distance = self.actual_distance
+        self.actual_distance = Point.dist(self.nodes[0].position, self.nodes[1].position)
+        return previous_distance
+
+    def update_actual_speed(self, delta_time: float) -> None:
+        previous_distance = self.update_actual_distance()
+        self.actual_speed = (self.actual_distance - previous_distance) / delta_time
+
+    def apply_forces(self) -> None:
+        self.nodes[0].force += self.get_spring_force() * self.get_unit_vector()
+        self.nodes[1].force -= self.get_spring_force() * self.get_unit_vector()
+
+
+nodes = [Node(mass=1, position=Point(cos(tau * n / 10), sin(tau * n / 10)), velocity=Point(0, 0), acceleration=Point(0, 0), force=Point(0, 0)) for n in range(10)]
+
+links = [Link(nodes=(nodes[n], nodes[(n + 1) % 10]), resting_distance=tau / 10, actual_distance=tau / 10, stiffness=1, dampening=1, actual_speed=0) for n in range(10)]
+
+system = System(nodes=nodes, links=links)
+
+
+iteration = 1
+iterations = 30000
+delta_time = 0.001
+
+
+
+view_minimum = Point(-2, -6)
+view_maximum = Point(12, 8)
+
+pygame.init()
+screen = pygame.display.set_mode([500, 500])
+
+def transformed(point: Point) -> Point:
+    return Point(500 * (point.x - view_minimum.x) / (view_maximum.x - view_minimum.x),
+                 500 * (1 - (point.y - view_minimum.y) / (view_maximum.y - view_minimum.y)))
+
+running = True
+
+for i in range(iterations):
+    for node in system.nodes:
+        node.force.set(Point(0, 0, 0))
+
+    for node in system.nodes:
+        node.force.y -= node.mass * g
+
+    for link in system.links:
+        link.update_actual_speed(delta_time)
+        link.apply_forces()
+
+    for node in system.nodes:
+        node.iterate(delta_time)
+
+    for event in pygame.event.get():
+        if event.type == pygame.QUIT:
+            running = False
+
+    if not running:
+        break
+
+    screen.fill((255, 255, 255))
+
+    for link in system.links:
+        t1 = transformed(link.nodes[0].position)
+        t2 = transformed(link.nodes[1].position)
+        pygame.draw.line(screen, (255, 0, 0), (t1.x, t1.y), (t2.x, t2.y), 3)
+
+    for node in system.nodes:
+        t1 = transformed(node.position)
+        pygame.draw.circle(screen, (0, 0, 255), (t1.x, t1.y), 3)
+
+    pygame.display.flip()
+    iteration += 1
+
+pygame.quit()
\ No newline at end of file

commit 52254b50077efbc2a9bd2001eef531708c6176ef
Author: Daxonus <elias@dobrin.net>
Date:   Thu Mar 24 19:30:43 2022 -0700

    changed 3d building to 2d bridge

diff --git a/building.py b/bridge.py
similarity index 51%
rename from building.py
rename to bridge.py
index da63b0e..76682d6 100644
--- a/building.py
+++ b/bridge.py
@@ -1,5 +1,6 @@
 from __future__ import annotations
 from math import sqrt
+import numpy as np
 from scipy.constants import g
 import pygame
 from points import Point
@@ -67,7 +68,7 @@ class Link:
         return f"{self.nodes[0].position} <- Link -> {self.nodes[1].position}"
 
     def get_unit_vector(self) -> Point:
-        return (self.nodes[1].position - self.nodes[0].position) / self.resting_distance
+        return (self.nodes[0].position - self.nodes[1].position) / self.resting_distance
 
     def get_displacement(self) -> float:
         return self.actual_distance - self.resting_distance
@@ -95,53 +96,63 @@ class Link:
         self.nodes[1].force -= self.get_spring_force() * self.get_unit_vector()
 
 
-length = 10
-width = 5
-height = 20
+nodes = [Node(mass=10, position=Point(0, 0), velocity=Point(0, 0), acceleration=Point(0, 0), force=Point(0, 0)),
+         Node(mass=10, position=Point(1, 0), velocity=Point(0, 0), acceleration=Point(0, 0), force=Point(0, 0)),
+         Node(mass=10, position=Point(2, 0), velocity=Point(0, 0), acceleration=Point(0, 0), force=Point(0, 0)),
+         Node(mass=10, position=Point(3, 0), velocity=Point(0, 0), acceleration=Point(0, 0), force=Point(0, 0)),
+         Node(mass=10, position=Point(4, 0), velocity=Point(0, 0), acceleration=Point(0, 0), force=Point(0, 0)),
+         Node(mass=10, position=Point(5, 0), velocity=Point(0, 0), acceleration=Point(0, 0), force=Point(0, 0)),
+         Node(mass=10, position=Point(6, 0), velocity=Point(0, 0), acceleration=Point(0, 0), force=Point(0, 0)),
+         Node(mass=10, position=Point(7, 0), velocity=Point(0, 0), acceleration=Point(0, 0), force=Point(0, 0)),
+         Node(mass=10, position=Point(8, 0), velocity=Point(0, 0), acceleration=Point(0, 0), force=Point(0, 0)),
+         Node(mass=10, position=Point(9, 0), velocity=Point(0, 0), acceleration=Point(0, 0), force=Point(0, 0)),
+         Node(mass=10, position=Point(10, 0), velocity=Point(0, 0), acceleration=Point(0, 0), force=Point(0, 0)),
 
-nodes = [[[Node(mass=1, position=Point(x, y, z), velocity=Point(0, 0, 0), acceleration=Point(0, 0, 0), force=Point(0, 0, 0))
-         for z in range(height + 1)] for y in range(width + 1)] for x in range(length + 1)]
-links = []
+         Node(mass=10, position=Point(0, -2), velocity=Point(0, 0), acceleration=Point(0, 0), force=Point(0, 0)),
+         Node(mass=10, position=Point(10, -2), velocity=Point(0, 0), acceleration=Point(0, 0), force=Point(0, 0))]
 
-for x in range(1, length - 1):
-    for y in range(1, width):
-        for z in range(1, height):
-            links.append(Link(nodes=(nodes[x][y][z], nodes[x + 1][y][z]),
-                              resting_distance=0.9,
-                              actual_distance=1,
-                              stiffness=1,
-                              dampening=1,
-                              actual_speed=0))
+links = [Link(nodes=(nodes[0], nodes[1]), resting_distance=1, actual_distance=1, stiffness=2000, dampening=100, actual_speed=1),
+         Link(nodes=(nodes[1], nodes[2]), resting_distance=1, actual_distance=1, stiffness=2000, dampening=100, actual_speed=1),
+         Link(nodes=(nodes[2], nodes[3]), resting_distance=1, actual_distance=1, stiffness=2000, dampening=100, actual_speed=1),
+         Link(nodes=(nodes[3], nodes[4]), resting_distance=1, actual_distance=1, stiffness=2000, dampening=100, actual_speed=1),
+         Link(nodes=(nodes[4], nodes[5]), resting_distance=1, actual_distance=1, stiffness=2000, dampening=100, actual_speed=1),
+         Link(nodes=(nodes[5], nodes[6]), resting_distance=1, actual_distance=1, stiffness=2000, dampening=100, actual_speed=1),
+         Link(nodes=(nodes[6], nodes[7]), resting_distance=1, actual_distance=1, stiffness=2000, dampening=100, actual_speed=1),
+         Link(nodes=(nodes[7], nodes[8]), resting_distance=1, actual_distance=1, stiffness=2000, dampening=100, actual_speed=1),
+         Link(nodes=(nodes[8], nodes[9]), resting_distance=1, actual_distance=1, stiffness=2000, dampening=100, actual_speed=1),
+         Link(nodes=(nodes[9], nodes[10]), resting_distance=1, actual_distance=1, stiffness=2000, dampening=100, actual_speed=1),
 
-system = System(nodes=[nodes[x][y][z] for x in range(length + 1) for y in range(width + 1) for z in range(height + 1)], links=links)
+         Link(nodes=(nodes[11], nodes[3]), resting_distance=4, actual_distance=1, stiffness=2000, dampening=100, actual_speed=1),
+         Link(nodes=(nodes[12], nodes[7]), resting_distance=4, actual_distance=1, stiffness=2000, dampening=100, actual_speed=1)]
 
+system = System(nodes=nodes, links=links)
 
-iteration = 1
-iterations = 1000
-delta_time = 0.01
 
-camera_position = Point(0, 0, 0)
-camera_focal_distance = 1
+iteration = 1
+iterations = 30000
+delta_time = 0.001
 
 
-def transformed(position: Point) -> Point:
-    try:
-        return Point(500 * ((position.x - camera_position.x) * camera_focal_distance / ((position.z - camera_position.z) + 20) + 0.5), 500 * ((position.y - camera_position.y) * camera_focal_distance / ((position.z - camera_position.z) + 20) + 0.5))
-    except ZeroDivisionError:
-        return Point(0, 0)
 
+view_minimum = Point(-2, -6)
+view_maximum = Point(12, 8)
 
 pygame.init()
 screen = pygame.display.set_mode([500, 500])
 
+def transformed(point: Point) -> Point:
+    return Point(500 * (point.x - view_minimum.x) / (view_maximum.x - view_minimum.x),
+                 500 * (1 - (point.y - view_minimum.y) / (view_maximum.y - view_minimum.y)))
+
 running = True
 
 for i in range(iterations):
-    camera_position.x += 0.1
-
     for node in system.nodes:
         node.force.set(Point(0, 0, 0))
 
+    for node in system.nodes:
+        node.force.y -= node.mass * g
+
     for link in system.links:
         link.update_actual_speed(delta_time)
         link.apply_forces()
@@ -149,6 +160,11 @@ for i in range(iterations):
     for node in system.nodes:
         node.iterate(delta_time)
 
+    system.nodes[0].position.set(Point(0, 0))
+    system.nodes[10].position.set(Point(10, 0))
+    system.nodes[11].position.set(Point(0, -2))
+    system.nodes[12].position.set(Point(10, -2))
+
     for event in pygame.event.get():
         if event.type == pygame.QUIT:
             running = False
@@ -168,4 +184,6 @@ for i in range(iterations):
         pygame.draw.circle(screen, (0, 0, 255), (t1.x, t1.y), 3)
 
     pygame.display.flip()
-    iteration += 1
\ No newline at end of file
+    iteration += 1
+
+pygame.quit()
\ No newline at end of file

commit e57eecf6ffdc3b8a150358c701751650a0890026
Author: Daxonus <elias@dobrin.net>
Date:   Thu Mar 24 13:44:34 2022 -0700

    made 3 render code, added update loop and pygame integration

diff --git a/building.py b/building.py
index 459068a..da63b0e 100644
--- a/building.py
+++ b/building.py
@@ -35,8 +35,8 @@ class Node:
         self.acceleration = acceleration
         self.force = force
 
-    def __str__(self) -> str:
-        return "Node"
+    def __repr__(self) -> str:
+        return f"Node{self.position}"
 
     def update_acceleration(self) -> None:
         self.acceleration = self.force / self.mass
@@ -63,8 +63,8 @@ class Link:
         self.dampening = dampening
         self.actual_speed = actual_speed
 
-    def __str__(self) -> str:
-        return f"{self.nodes[0].position} <-> {self.nodes[1].position}"
+    def __repr__(self) -> str:
+        return f"{self.nodes[0].position} <- Link -> {self.nodes[1].position}"
 
     def get_unit_vector(self) -> Point:
         return (self.nodes[1].position - self.nodes[0].position) / self.resting_distance
@@ -95,23 +95,77 @@ class Link:
         self.nodes[1].force -= self.get_spring_force() * self.get_unit_vector()
 
 
-length: int = 10
-width: int = 5
-height: int = 20
+length = 10
+width = 5
+height = 20
 
-nodes = [[[Node(mass=1, position=Point(0, 0, 0), velocity=Point(0, 0, 0), acceleration=Point(0, 0, 0), force=Point(0, 0, 0))
-         for z in range(height)] for y in range(width)] for x in range(length)]
+nodes = [[[Node(mass=1, position=Point(x, y, z), velocity=Point(0, 0, 0), acceleration=Point(0, 0, 0), force=Point(0, 0, 0))
+         for z in range(height + 1)] for y in range(width + 1)] for x in range(length + 1)]
 links = []
 
-for x in range(1, length - 2):
-    for y in range(1, width - 1):
-        for z in range(1, height - 1):
+for x in range(1, length - 1):
+    for y in range(1, width):
+        for z in range(1, height):
             links.append(Link(nodes=(nodes[x][y][z], nodes[x + 1][y][z]),
-                              resting_distance=1,
+                              resting_distance=0.9,
                               actual_distance=1,
                               stiffness=1,
                               dampening=1,
                               actual_speed=0))
 
-system = System(nodes=[nodes[x][y][z] for x in range(length) for y in range(width) for z in range(height)], links=links)
-print(system.links[0])
\ No newline at end of file
+system = System(nodes=[nodes[x][y][z] for x in range(length + 1) for y in range(width + 1) for z in range(height + 1)], links=links)
+
+
+iteration = 1
+iterations = 1000
+delta_time = 0.01
+
+camera_position = Point(0, 0, 0)
+camera_focal_distance = 1
+
+
+def transformed(position: Point) -> Point:
+    try:
+        return Point(500 * ((position.x - camera_position.x) * camera_focal_distance / ((position.z - camera_position.z) + 20) + 0.5), 500 * ((position.y - camera_position.y) * camera_focal_distance / ((position.z - camera_position.z) + 20) + 0.5))
+    except ZeroDivisionError:
+        return Point(0, 0)
+
+
+pygame.init()
+screen = pygame.display.set_mode([500, 500])
+
+running = True
+
+for i in range(iterations):
+    camera_position.x += 0.1
+
+    for node in system.nodes:
+        node.force.set(Point(0, 0, 0))
+
+    for link in system.links:
+        link.update_actual_speed(delta_time)
+        link.apply_forces()
+
+    for node in system.nodes:
+        node.iterate(delta_time)
+
+    for event in pygame.event.get():
+        if event.type == pygame.QUIT:
+            running = False
+
+    if not running:
+        break
+
+    screen.fill((255, 255, 255))
+
+    for link in system.links:
+        t1 = transformed(link.nodes[0].position)
+        t2 = transformed(link.nodes[1].position)
+        pygame.draw.line(screen, (255, 0, 0), (t1.x, t1.y), (t2.x, t2.y), 3)
+
+    for node in system.nodes:
+        t1 = transformed(node.position)
+        pygame.draw.circle(screen, (0, 0, 255), (t1.x, t1.y), 3)
+
+    pygame.display.flip()
+    iteration += 1
\ No newline at end of file

commit 122726854d2c3673e597756e3fc95c48fedf4da4
Author: Daxonus <elias@dobrin.net>
Date:   Thu Mar 24 11:34:23 2022 -0700

    added some building code

diff --git a/__pycache__/points.cpython-310.pyc b/__pycache__/points.cpython-310.pyc
index bd7a493..4969507 100644
Binary files a/__pycache__/points.cpython-310.pyc and b/__pycache__/points.cpython-310.pyc differ
diff --git a/building.py b/building.py
index 30436f7..459068a 100644
--- a/building.py
+++ b/building.py
@@ -13,6 +13,13 @@ class System:
         self.nodes = nodes
         self.links = links
 
+    def __str__(self) -> str:
+        return f"Nodes {self.nodes}\nLinks {self.links}"
+
+    def iterate(self, delta_time: float) -> None:
+        for node in self.nodes:
+            node.iterate(delta_time)
+
 
 class Node:
     mass: float
@@ -28,6 +35,17 @@ class Node:
         self.acceleration = acceleration
         self.force = force
 
+    def __str__(self) -> str:
+        return "Node"
+
+    def update_acceleration(self) -> None:
+        self.acceleration = self.force / self.mass
+
+    def iterate(self, delta_time) -> None:
+        self.update_acceleration()
+        self.velocity += self.acceleration * delta_time
+        self.position += self.velocity * delta_time
+
 
 class Link:
     nodes: tuple[Node, Node]
@@ -45,6 +63,12 @@ class Link:
         self.dampening = dampening
         self.actual_speed = actual_speed
 
+    def __str__(self) -> str:
+        return f"{self.nodes[0].position} <-> {self.nodes[1].position}"
+
+    def get_unit_vector(self) -> Point:
+        return (self.nodes[1].position - self.nodes[0].position) / self.resting_distance
+
     def get_displacement(self) -> float:
         return self.actual_distance - self.resting_distance
 
@@ -57,8 +81,37 @@ class Link:
     def get_spring_force(self) -> float:
         return self.get_stiffness_force() + self.get_dampening_force()
 
-    def update_actual_distance(self) -> None:
+    def update_actual_distance(self) -> float:
+        previous_distance = self.actual_distance
         self.actual_distance = Point.dist(self.nodes[0].position, self.nodes[1].position)
+        return previous_distance
+
+    def update_actual_speed(self, delta_time: float) -> None:
+        previous_distance = self.update_actual_distance()
+        self.actual_speed = (self.actual_distance - previous_distance) / delta_time
+
+    def apply_forces(self) -> None:
+        self.nodes[0].force += self.get_spring_force() * self.get_unit_vector()
+        self.nodes[1].force -= self.get_spring_force() * self.get_unit_vector()
+
+
+length: int = 10
+width: int = 5
+height: int = 20
+
+nodes = [[[Node(mass=1, position=Point(0, 0, 0), velocity=Point(0, 0, 0), acceleration=Point(0, 0, 0), force=Point(0, 0, 0))
+         for z in range(height)] for y in range(width)] for x in range(length)]
+links = []
+
+for x in range(1, length - 2):
+    for y in range(1, width - 1):
+        for z in range(1, height - 1):
+            links.append(Link(nodes=(nodes[x][y][z], nodes[x + 1][y][z]),
+                              resting_distance=1,
+                              actual_distance=1,
+                              stiffness=1,
+                              dampening=1,
+                              actual_speed=0))
 
-    def update_actual_speed(self, previous_distance: float, delta_time: float) -> None:
-        self.actual_speed = (self.actual_distance - previous_distance) / delta_time
\ No newline at end of file
+system = System(nodes=[nodes[x][y][z] for x in range(length) for y in range(width) for z in range(height)], links=links)
+print(system.links[0])
\ No newline at end of file

commit d7f41329089aedd028628667730c36b5ac68c9e0
Author: Daxonus <elias@dobrin.net>
Date:   Wed Mar 23 18:52:14 2022 -0700

    made object oriented code for nodes and spring links

diff --git a/building.py b/building.py
new file mode 100644
index 0000000..30436f7
--- /dev/null
+++ b/building.py
@@ -0,0 +1,64 @@
+from __future__ import annotations
+from math import sqrt
+from scipy.constants import g
+import pygame
+from points import Point
+
+
+class System:
+    nodes: list[Node]
+    links: list[Link]
+
+    def __init__(self, nodes: list[Node], links: list[Link]) -> None:
+        self.nodes = nodes
+        self.links = links
+
+
+class Node:
+    mass: float
+    position: Point
+    velocity: Point
+    acceleration: Point
+    force: Point
+
+    def __init__(self, mass: float, position: Point, velocity: Point, acceleration: Point, force: Point) -> None:
+        self.mass = mass
+        self.position = position
+        self.velocity = velocity
+        self.acceleration = acceleration
+        self.force = force
+
+
+class Link:
+    nodes: tuple[Node, Node]
+    resting_distance: float
+    actual_distance: float
+    stiffness: float
+    dampening: float
+    actual_speed: float
+
+    def __init__(self, nodes: tuple[Node, Node], resting_distance: float, actual_distance: float, stiffness: float, dampening: float, actual_speed: float) -> None:
+        self.nodes = nodes
+        self.resting_distance = resting_distance
+        self.actual_distance = actual_distance
+        self.stiffness = stiffness
+        self.dampening = dampening
+        self.actual_speed = actual_speed
+
+    def get_displacement(self) -> float:
+        return self.actual_distance - self.resting_distance
+
+    def get_stiffness_force(self) -> float:
+        return -self.stiffness * self.get_displacement()
+
+    def get_dampening_force(self) -> float:
+        return -self.dampening * self.actual_speed
+
+    def get_spring_force(self) -> float:
+        return self.get_stiffness_force() + self.get_dampening_force()
+
+    def update_actual_distance(self) -> None:
+        self.actual_distance = Point.dist(self.nodes[0].position, self.nodes[1].position)
+
+    def update_actual_speed(self, previous_distance: float, delta_time: float) -> None:
+        self.actual_speed = (self.actual_distance - previous_distance) / delta_time
\ No newline at end of file
diff --git a/main.py b/main.py
deleted file mode 100644
index 607fb28..0000000
--- a/main.py
+++ /dev/null
@@ -1,44 +0,0 @@
-import pygame
-from softbodies import Softbody, Node, Link, Point
-
-nodes = [[Node(mass=1, position=Point(x / 4, y / 4), velocity=Point(0, 0)) for y in range(5)] for x in range(5)]
-softbody = Softbody(nodes=[node for node_buffer in nodes for node in node_buffer],
-                    links=[])
-
-for x in range(len(nodes)):
-    for y in range(len(nodes[0]) - 1):
-        softbody.links.append(Link(nodes[x][y], nodes[x][y + 1]))
-
-for y in range(len(nodes[0])):
-    for x in range(len(nodes) - 1):
-        softbody.links.append(Link(nodes[x][y], nodes[x + 1][y]))
-
-minimum = Point(-5, -5)
-maximum = Point(5, 5)
-
-
-def transform(point: Point) -> Point:
-    return Point(500 * (point.x - minimum.x) / (maximum.x - minimum.x), 500 * (point.y - minimum.y) / (maximum.y - minimum.y))
-
-
-pygame.init()
-screen = pygame.display.set_mode([500, 500])
-
-running = True
-while running:
-    for event in pygame.event.get():
-        if event.type == pygame.QUIT:
-            running = False
-
-    screen.fill((255, 255, 255))
-
-    for node in softbody.nodes:
-        transformed = transform(node.position)
-        pygame.draw.circle(screen, (0, 0, 255), (transformed.x, transformed.y), 3)
-
-    softbody.iterate(0.001)
-    softbody.nodes[0].position = Point(-1, -1)
-
-    pygame.display.flip()
-
-pygame.quit()
\ No newline at end of file
diff --git a/softbodies.py b/softbodies.py
deleted file mode 100644
index 8f256a1..0000000
--- a/softbodies.py
+++ /dev/null
@@ -1,56 +0,0 @@
-from __future__ import annotations
-from points import Point
-
-
-class Softbody:
-    nodes: list[Node]
-    links: list[Link]
-
-    def __init__(self, nodes: list[Node], links: list[Link]) -> None:
-        self.nodes = nodes
-        self.links = links
-
-    def iterate(self, time: float) -> None:
-        for node in self.nodes:
-            node.force = Point(0, -9.88 * node.mass)
-
-        for link in self.links:
-            node_1 = link.node_1
-            node_2 = link.node_2
-            force = Point.polar(10 * (node_1.position.dist(node_2.position) - link.distance), node_1.position.angle(node_2.position))
-            node_1.force -= force
-            node_2.force += force
-
-        for node in self.nodes:
-            node.iterate(time)
-
-
-class Node:
-    mass: float
-    position: Point
-    velocity: Point
-    force: Point
-
-    def __init__(self, mass: float, position: Point, velocity: Point) -> None:
-        self.mass = mass
-        self.position = position
-        self.velocity = velocity
-        self.force = Point(0, 0)
-
-    def iterate(self, time: float) -> None:
-        self.velocity += self.force * (time / self.mass)
-        self.position += self.velocity * time
-
-
-class Link:
-    node_1: Node
-    node_2: Node
-    distance: float
-
-    def __init__(self, node_1: Node, node_2: Node, distance: float = None) -> None:
-        self.node_1 = node_1
-        self.node_2 = node_2
-        if distance is not None:
-            self.distance = distance
-        else:
-            self.distance = node_1.position.dist(node_2.position)
\ No newline at end of file

commit 2447da4a9b7e996c5eae4665b596413e8d2e8d1d
Author: Daxonus <elias@dobrin.net>
Date:   Wed Mar 23 14:56:12 2022 -0700

    4 cloth simulations

diff --git a/cloth.py b/cloth_1.py
similarity index 82%
rename from cloth.py
rename to cloth_1.py
index d8bea70..ae82891 100644
--- a/cloth.py
+++ b/cloth_1.py
@@ -27,7 +27,7 @@ for y in range(isqrt(cloth_nodes)):
     for x in range(isqrt(cloth_nodes) - 1):
         links_nodes.append((nodes_references[y][x], nodes_references[y][x + 1]))
         links_resting.append(0.9)
-        links_distance.append(nan)
+        links_distance.append(1)
         links_stiffness.append(200)
         links_dampening.append(5)
         links_speed.append(0)
@@ -37,7 +37,7 @@ for x in range(isqrt(cloth_nodes)):
     for y in range(isqrt(cloth_nodes) - 1):
         links_nodes.append((nodes_references[y][x], nodes_references[y + 1][x]))
         links_resting.append(0.9)
-        links_distance.append(nan)
+        links_distance.append(1)
         links_stiffness.append(200)
         links_dampening.append(5)
         links_speed.append(0)
@@ -47,7 +47,7 @@ for x in range(isqrt(cloth_nodes) - 1):
     for y in range(isqrt(cloth_nodes) - 1):
         links_nodes.append((nodes_references[x][y], nodes_references[x + 1][y + 1]))
         links_resting.append(1.3)
-        links_distance.append(nan)
+        links_distance.append(1)
         links_stiffness.append(200)
         links_dampening.append(5)
         links_speed.append(0)
@@ -55,24 +55,27 @@ for x in range(isqrt(cloth_nodes) - 1):
     for y in range(isqrt(cloth_nodes) - 1):
         links_nodes.append((nodes_references[x][y + 1], nodes_references[x + 1][y]))
         links_resting.append(1.3)
-        links_distance.append(nan)
+        links_distance.append(1)
         links_stiffness.append(200)
         links_dampening.append(5)
         links_speed.append(0)
 
 iterations: int = 10000
 time_step: float = 0.001
-view_minimum = Point(-1, -1)
-view_maximum = Point(6, 6)
+view_minimum = Point(-1, -2)
+view_maximum = Point(6, 5)
+
+
 
 pygame.init()
-screen = pygame.display.set_mode([1000, 1000])
+screen = pygame.display.set_mode([500, 500])
 
 
 def transform(point: Point) -> Point:
-    return Point(1000 * (point.x - view_minimum.x) / (view_maximum.x - view_minimum.x),
-                 1000 * (1 - (point.y - view_minimum.y) / (view_maximum.y - view_minimum.y)))
+    return Point(500 * (point.x - view_minimum.x) / (view_maximum.x - view_minimum.x),
+                 500 * (1 - (point.y - view_minimum.y) / (view_maximum.y - view_minimum.y)))
 
+running = True
 
 for i in range(iterations):
     # Clearing forces
@@ -88,34 +91,34 @@ for i in range(iterations):
         link_distance = Point.dist(nodes_position[link_nodes[0]], nodes_position[link_nodes[1]])
 
         # Finding speed of expansion/contraction before distance set
-        if not isnan(links_distance[l]):
-            links_speed[l] = (link_distance - links_distance[l]) / time_step
-        else:
-            links_speed[l] = 0
-
+        links_speed[l] = (link_distance - links_distance[l]) / time_step
         links_distance[l] = link_distance
-
         force_stiffness = -links_stiffness[l] * (link_distance - links_resting[l])
-        force_dampening = -links_dampening[l] * links_speed[l]
+        force_dampening = links_dampening[l] * links_speed[l]
         # Force of spring (one-sided)
-        force_spring = (force_stiffness + force_dampening) * (nodes_position[link_nodes[0]] - nodes_position[link_nodes[1]]) / link_distance
+        force_spring = (force_stiffness - force_dampening) * (nodes_position[link_nodes[0]] - nodes_position[link_nodes[1]]) / link_distance
         nodes_force[link_nodes[0]].add(force_spring)
         nodes_force[link_nodes[1]].sub(force_spring)
 
     # Integration
     for n in range(nodes):
-        nodes_acceleration[n] = nodes_force[n] / nodes_mass[n]
-        nodes_velocity[n] += nodes_acceleration[n] * time_step
-
         if n == 24:
-            pass
-            continue
+            nodes_force[n].set(Point(0, 0))
+
 
+        nodes_acceleration[n] = nodes_force[n] / nodes_mass[n]
+        nodes_velocity[n] += nodes_acceleration[n] * time_step
         nodes_position[n] += nodes_velocity[n] * time_step
 
     # Conditions
     # enter here
 
+    for event in pygame.event.get():
+        if event.type == pygame.QUIT:
+            running = False
+
+    if not running:
+        break
 
     screen.fill((255, 255, 255))
 
@@ -127,8 +130,8 @@ for i in range(iterations):
 
     for n in range(nodes):
         transformed = transform(nodes_position[n])
-        pygame.draw.circle(screen, (0, 0, 255), (transformed.x, transformed.y), 10)
+        pygame.draw.circle(screen, (0, 0, 255), (transformed.x, transformed.y), 5)
 
     pygame.display.flip()
 
-pygame.quit()
\ No newline at end of file
+pygame.quit()
diff --git a/cloth_2.py b/cloth_2.py
new file mode 100644
index 0000000..858bb5d
--- /dev/null
+++ b/cloth_2.py
@@ -0,0 +1,140 @@
+from math import nan, isnan, isqrt, sin
+from time import sleep
+from scipy.constants import g
+import pygame
+from points import Point
+
+cloth_nodes: int = 25
+nodes_references: list[list[int]] = [[y * isqrt(cloth_nodes) + x for x in range(isqrt(cloth_nodes))] for y in range(isqrt(cloth_nodes))]
+
+nodes: int = cloth_nodes
+nodes_mass: list[float] = [1 for n in range(cloth_nodes)]
+nodes_position: list[Point] = [Point(x, y) for y in range(isqrt(cloth_nodes)) for x in range(isqrt(cloth_nodes))]
+nodes_velocity: list[Point] = [Point(0, 0) for n in range(cloth_nodes)]
+nodes_acceleration: list[Point] = [Point(0, 0) for n in range(cloth_nodes)]
+nodes_force: list[Point] = [Point(0, 0) for n in range(cloth_nodes)]
+
+links: int = 2 * (isqrt(cloth_nodes) * (isqrt(cloth_nodes) - 1) + (isqrt(cloth_nodes) - 1) ** 2)
+links_nodes: list[tuple[int, int]] = []
+links_resting: list[float] = []
+links_distance: list[float] = []
+links_stiffness: list[float] = []
+links_dampening: list[float] = []
+links_speed: list[float] = []
+
+# Adding horizontal springs
+for y in range(isqrt(cloth_nodes)):
+    for x in range(isqrt(cloth_nodes) - 1):
+        links_nodes.append((nodes_references[y][x], nodes_references[y][x + 1]))
+        links_resting.append(0.9)
+        links_distance.append(1)
+        links_stiffness.append(200)
+        links_dampening.append(30)
+        links_speed.append(0)
+
+# Adding vertical springs
+for x in range(isqrt(cloth_nodes)):
+    for y in range(isqrt(cloth_nodes) - 1):
+        links_nodes.append((nodes_references[y][x], nodes_references[y + 1][x]))
+        links_resting.append(0.9)
+        links_distance.append(1)
+        links_stiffness.append(200)
+        links_dampening.append(30)
+        links_speed.append(0)
+
+# Adding diagonal springs
+for x in range(isqrt(cloth_nodes) - 1):
+    for y in range(isqrt(cloth_nodes) - 1):
+        links_nodes.append((nodes_references[x][y], nodes_references[x + 1][y + 1]))
+        links_resting.append(1.3)
+        links_distance.append(1)
+        links_stiffness.append(200)
+        links_dampening.append(30)
+        links_speed.append(0)
+for x in range(isqrt(cloth_nodes) - 1):
+    for y in range(isqrt(cloth_nodes) - 1):
+        links_nodes.append((nodes_references[x][y + 1], nodes_references[x + 1][y]))
+        links_resting.append(1.3)
+        links_distance.append(1)
+        links_stiffness.append(200)
+        links_dampening.append(30)
+        links_speed.append(0)
+
+iteration: int = 1
+iterations: int = 10000
+time_step: float = 0.001
+view_minimum = Point(-1, -2)
+view_maximum = Point(6, 5)
+
+
+
+pygame.init()
+screen = pygame.display.set_mode([500, 500])
+
+
+def transform(point: Point) -> Point:
+    return Point(500 * (point.x - view_minimum.x) / (view_maximum.x - view_minimum.x),
+                 500 * (1 - (point.y - view_minimum.y) / (view_maximum.y - view_minimum.y)))
+
+running = True
+
+for i in range(iterations):
+    # Clearing forces
+    for n in range(nodes):
+        nodes_force[n].set(Point(0, 0))
+
+    # Force of gravity
+    for n in range(nodes):
+        nodes_force[n].y -= nodes_mass[n] * g
+
+    for l in range(links):
+        link_nodes = links_nodes[l]
+        link_distance = Point.dist(nodes_position[link_nodes[0]], nodes_position[link_nodes[1]])
+
+        # Finding speed of expansion/contraction before distance set
+        links_speed[l] = (link_distance - links_distance[l]) / time_step
+        links_distance[l] = link_distance
+        force_stiffness = -links_stiffness[l] * (link_distance - links_resting[l])
+        force_dampening = links_dampening[l] * links_speed[l]
+        # Force of spring (one-sided)
+        force_spring = (force_stiffness - force_dampening) * (nodes_position[link_nodes[0]] - nodes_position[link_nodes[1]]) / link_distance
+        nodes_force[link_nodes[0]].add(force_spring)
+        nodes_force[link_nodes[1]].sub(force_spring)
+
+    # Integration
+    for n in range(nodes):
+        if n == 24:
+            nodes_position[n].set(Point(4 + 2 * sin(0.002 * iteration), 4))
+            continue
+
+        nodes_acceleration[n] = nodes_force[n] / nodes_mass[n]
+        nodes_velocity[n] += nodes_acceleration[n] * time_step
+        nodes_position[n] += nodes_velocity[n] * time_step
+
+    # Conditions
+    # enter here
+
+
+    for event in pygame.event.get():
+        if event.type == pygame.QUIT:
+            running = False
+
+    if not running:
+        break
+
+    screen.fill((255, 255, 255))
+
+    for l in range(links):
+        link_nodes = links_nodes[l]
+        transformed_1 = transform(nodes_position[link_nodes[0]])
+        transformed_2 = transform(nodes_position[link_nodes[1]])
+        pygame.draw.line(screen, (255, 0, 0), (transformed_1.x, transformed_1.y), (transformed_2.x, transformed_2.y), 3)
+
+    for n in range(nodes):
+        transformed = transform(nodes_position[n])
+        pygame.draw.circle(screen, (0, 0, 255), (transformed.x, transformed.y), 5)
+
+    pygame.display.flip()
+    iteration += 1
+
+pygame.quit()
diff --git a/cloth_3.py b/cloth_3.py
new file mode 100644
index 0000000..73a08e2
--- /dev/null
+++ b/cloth_3.py
@@ -0,0 +1,140 @@
+from math import nan, isnan, isqrt, sin, cos
+from time import sleep
+from scipy.constants import g
+import pygame
+from points import Point
+
+cloth_nodes: int = 25
+nodes_references: list[list[int]] = [[y * isqrt(cloth_nodes) + x for x in range(isqrt(cloth_nodes))] for y in range(isqrt(cloth_nodes))]
+
+nodes: int = cloth_nodes
+nodes_mass: list[float] = [1 for n in range(cloth_nodes)]
+nodes_position: list[Point] = [Point(x, y) for y in range(isqrt(cloth_nodes)) for x in range(isqrt(cloth_nodes))]
+nodes_velocity: list[Point] = [Point(0, 0) for n in range(cloth_nodes)]
+nodes_acceleration: list[Point] = [Point(0, 0) for n in range(cloth_nodes)]
+nodes_force: list[Point] = [Point(0, 0) for n in range(cloth_nodes)]
+
+links: int = 2 * (isqrt(cloth_nodes) * (isqrt(cloth_nodes) - 1) + (isqrt(cloth_nodes) - 1) ** 2)
+links_nodes: list[tuple[int, int]] = []
+links_resting: list[float] = []
+links_distance: list[float] = []
+links_stiffness: list[float] = []
+links_dampening: list[float] = []
+links_speed: list[float] = []
+
+# Adding horizontal springs
+for y in range(isqrt(cloth_nodes)):
+    for x in range(isqrt(cloth_nodes) - 1):
+        links_nodes.append((nodes_references[y][x], nodes_references[y][x + 1]))
+        links_resting.append(0.9)
+        links_distance.append(1)
+        links_stiffness.append(200)
+        links_dampening.append(50)
+        links_speed.append(0)
+
+# Adding vertical springs
+for x in range(isqrt(cloth_nodes)):
+    for y in range(isqrt(cloth_nodes) - 1):
+        links_nodes.append((nodes_references[y][x], nodes_references[y + 1][x]))
+        links_resting.append(0.9)
+        links_distance.append(1)
+        links_stiffness.append(200)
+        links_dampening.append(50)
+        links_speed.append(0)
+
+# Adding diagonal springs
+for x in range(isqrt(cloth_nodes) - 1):
+    for y in range(isqrt(cloth_nodes) - 1):
+        links_nodes.append((nodes_references[x][y], nodes_references[x + 1][y + 1]))
+        links_resting.append(1.3)
+        links_distance.append(1)
+        links_stiffness.append(200)
+        links_dampening.append(50)
+        links_speed.append(0)
+for x in range(isqrt(cloth_nodes) - 1):
+    for y in range(isqrt(cloth_nodes) - 1):
+        links_nodes.append((nodes_references[x][y + 1], nodes_references[x + 1][y]))
+        links_resting.append(1.3)
+        links_distance.append(1)
+        links_stiffness.append(200)
+        links_dampening.append(50)
+        links_speed.append(0)
+
+iteration: int = 1
+iterations: int = 10000
+time_step: float = 0.001
+view_minimum = Point(-1, -2)
+view_maximum = Point(6, 5)
+
+
+
+pygame.init()
+screen = pygame.display.set_mode([500, 500])
+
+
+def transform(point: Point) -> Point:
+    return Point(500 * (point.x - view_minimum.x) / (view_maximum.x - view_minimum.x),
+                 500 * (1 - (point.y - view_minimum.y) / (view_maximum.y - view_minimum.y)))
+
+running = True
+
+for i in range(iterations):
+    # Clearing forces
+    for n in range(nodes):
+        nodes_force[n].set(Point(0, 0))
+
+    # Force of gravity
+    for n in range(nodes):
+        nodes_force[n].y -= nodes_mass[n] * g
+
+    for l in range(links):
+        link_nodes = links_nodes[l]
+        link_distance = Point.dist(nodes_position[link_nodes[0]], nodes_position[link_nodes[1]])
+
+        # Finding speed of expansion/contraction before distance set
+        links_speed[l] = (link_distance - links_distance[l]) / time_step
+        links_distance[l] = link_distance
+        force_stiffness = -links_stiffness[l] * (link_distance - links_resting[l])
+        force_dampening = links_dampening[l] * links_speed[l]
+        # Force of spring (one-sided)
+        force_spring = (force_stiffness - force_dampening) * (nodes_position[link_nodes[0]] - nodes_position[link_nodes[1]]) / link_distance
+        nodes_force[link_nodes[0]].add(force_spring)
+        nodes_force[link_nodes[1]].sub(force_spring)
+
+    # Integration
+    for n in range(nodes):
+        if n == 24:
+            nodes_position[n].set(Point(3 + 1 * cos(0.004 * iteration), 4 + 1 * sin(0.004 * iteration)))
+            continue
+
+        nodes_acceleration[n] = nodes_force[n] / nodes_mass[n]
+        nodes_velocity[n] += nodes_acceleration[n] * time_step
+        nodes_position[n] += nodes_velocity[n] * time_step
+
+    # Conditions
+    # enter here
+
+
+    for event in pygame.event.get():
+        if event.type == pygame.QUIT:
+            running = False
+
+    if not running:
+        break
+
+    screen.fill((255, 255, 255))
+
+    for l in range(links):
+        link_nodes = links_nodes[l]
+        transformed_1 = transform(nodes_position[link_nodes[0]])
+        transformed_2 = transform(nodes_position[link_nodes[1]])
+        pygame.draw.line(screen, (255, 0, 0), (transformed_1.x, transformed_1.y), (transformed_2.x, transformed_2.y), 3)
+
+    for n in range(nodes):
+        transformed = transform(nodes_position[n])
+        pygame.draw.circle(screen, (0, 0, 255), (transformed.x, transformed.y), 5)
+
+    pygame.display.flip()
+    iteration += 1
+
+pygame.quit()
diff --git a/cloth_4.py b/cloth_4.py
new file mode 100644
index 0000000..d4943ad
--- /dev/null
+++ b/cloth_4.py
@@ -0,0 +1,140 @@
+from math import isqrt
+from time import sleep
+from scipy.constants import g
+import pygame
+from points import Point
+
+cloth_nodes: int = 25
+nodes_references: list[list[int]] = [[y * isqrt(cloth_nodes) + x for x in range(isqrt(cloth_nodes))] for y in range(isqrt(cloth_nodes))]
+
+nodes: int = cloth_nodes
+nodes_mass: list[float] = [1 for n in range(cloth_nodes)]
+nodes_position: list[Point] = [Point(x, y) for y in range(isqrt(cloth_nodes)) for x in range(isqrt(cloth_nodes))]
+nodes_velocity: list[Point] = [Point(0, 0) for n in range(cloth_nodes)]
+nodes_acceleration: list[Point] = [Point(0, 0) for n in range(cloth_nodes)]
+nodes_force: list[Point] = [Point(0, 0) for n in range(cloth_nodes)]
+
+links: int = 2 * (isqrt(cloth_nodes) * (isqrt(cloth_nodes) - 1) + (isqrt(cloth_nodes) - 1) ** 2)
+links_nodes: list[tuple[int, int]] = []
+links_resting: list[float] = []
+links_distance: list[float] = []
+links_stiffness: list[float] = []
+links_dampening: list[float] = []
+links_speed: list[float] = []
+
+# Adding horizontal springs
+for y in range(isqrt(cloth_nodes)):
+    for x in range(isqrt(cloth_nodes) - 1):
+        links_nodes.append((nodes_references[y][x], nodes_references[y][x + 1]))
+        links_resting.append(0.9)
+        links_distance.append(1)
+        links_stiffness.append(200)
+        links_dampening.append(0)
+        links_speed.append(0)
+
+# Adding vertical springs
+for x in range(isqrt(cloth_nodes)):
+    for y in range(isqrt(cloth_nodes) - 1):
+        links_nodes.append((nodes_references[y][x], nodes_references[y + 1][x]))
+        links_resting.append(0.9)
+        links_distance.append(1)
+        links_stiffness.append(200)
+        links_dampening.append(0)
+        links_speed.append(0)
+
+# Adding diagonal springs
+for x in range(isqrt(cloth_nodes) - 1):
+    for y in range(isqrt(cloth_nodes) - 1):
+        links_nodes.append((nodes_references[x][y], nodes_references[x + 1][y + 1]))
+        links_resting.append(1.3)
+        links_distance.append(1)
+        links_stiffness.append(200)
+        links_dampening.append(0)
+        links_speed.append(0)
+for x in range(isqrt(cloth_nodes) - 1):
+    for y in range(isqrt(cloth_nodes) - 1):
+        links_nodes.append((nodes_references[x][y + 1], nodes_references[x + 1][y]))
+        links_resting.append(1.3)
+        links_distance.append(1)
+        links_stiffness.append(200)
+        links_dampening.append(0)
+        links_speed.append(0)
+
+iteration: int = 1
+iterations: int = 10000
+time_step: float = 0.001
+view_minimum = Point(-1, -2)
+view_maximum = Point(6, 5)
+
+
+
+pygame.init()
+screen = pygame.display.set_mode([500, 500])
+
+
+def transform(point: Point) -> Point:
+    return Point(500 * (point.x - view_minimum.x) / (view_maximum.x - view_minimum.x),
+                 500 * (1 - (point.y - view_minimum.y) / (view_maximum.y - view_minimum.y)))
+
+running = True
+
+for i in range(iterations):
+    # Clearing forces
+    for n in range(nodes):
+        nodes_force[n].set(Point(0, 0))
+
+    # Force of gravity
+    for n in range(nodes):
+        nodes_force[n].y -= nodes_mass[n] * g
+
+    for l in range(links):
+        link_nodes = links_nodes[l]
+        link_distance = Point.dist(nodes_position[link_nodes[0]], nodes_position[link_nodes[1]])
+
+        # Finding speed of expansion/contraction before distance set
+        links_speed[l] = (link_distance - links_distance[l]) / time_step
+        links_distance[l] = link_distance
+        force_stiffness = -links_stiffness[l] * (link_distance - links_resting[l])
+        force_dampening = links_dampening[l] * links_speed[l]
+        # Force of spring (one-sided)
+        force_spring = (force_stiffness - force_dampening) * (nodes_position[link_nodes[0]] - nodes_position[link_nodes[1]]) / link_distance
+        nodes_force[link_nodes[0]].add(force_spring)
+        nodes_force[link_nodes[1]].sub(force_spring)
+
+    # Integration
+    for n in range(nodes):
+        if n == 24:
+            nodes_position[n].set(Point(4, 4))
+            continue
+
+        nodes_acceleration[n] = nodes_force[n] / nodes_mass[n]
+        nodes_velocity[n] += nodes_acceleration[n] * time_step
+        nodes_position[n] += nodes_velocity[n] * time_step
+
+    # Conditions
+    # enter here
+
+
+    for event in pygame.event.get():
+        if event.type == pygame.QUIT:
+            running = False
+
+    if not running:
+        break
+
+    screen.fill((255, 255, 255))
+
+    for l in range(links):
+        link_nodes = links_nodes[l]
+        transformed_1 = transform(nodes_position[link_nodes[0]])
+        transformed_2 = transform(nodes_position[link_nodes[1]])
+        pygame.draw.line(screen, (255, 0, 0), (transformed_1.x, transformed_1.y), (transformed_2.x, transformed_2.y), 3)
+
+    for n in range(nodes):
+        transformed = transform(nodes_position[n])
+        pygame.draw.circle(screen, (0, 0, 255), (transformed.x, transformed.y), 5)
+
+    pygame.display.flip()
+    iteration += 1
+
+pygame.quit()
diff --git a/points.py b/points.py
index 08c2310..4027971 100644
--- a/points.py
+++ b/points.py
@@ -23,6 +23,9 @@ class Point:
         yield self.y
         yield self.z
 
+    def __str__(self) -> str:
+        return f"({self.x}, {self.y}, {self.z})"
+
     def __add__(self, point: Point, /) -> Point:
         """(+) Add caller point with parameter point, without modification to point."""
         return self.copy().add(point)

commit ea6bf21f57d9355d4d7674ead5b2018a5307a8ce
Author: Elias <elias@dobrin.net>
Date:   Tue Mar 22 19:06:18 2022 -0700

    made actual cloth

diff --git a/__pycache__/points.cpython-310.pyc b/__pycache__/points.cpython-310.pyc
new file mode 100644
index 0000000..bd7a493
Binary files /dev/null and b/__pycache__/points.cpython-310.pyc differ
diff --git a/cloth.py b/cloth.py
index 9e0c270..d8bea70 100644
--- a/cloth.py
+++ b/cloth.py
@@ -1,29 +1,69 @@
-from math import nan, isnan
+from math import nan, isnan, isqrt
 from time import sleep
 from scipy.constants import g
 import pygame
 from points import Point
 
-
-nodes: int = 4
-nodes_mass: list[float] = [1, 1, 1, 1]
-nodes_position: list[Point] = [Point(0, 0), Point(1, 0), Point(1, 1), Point(0, 1)]
-nodes_velocity: list[Point] = [Point(0, 0), Point(0, 0), Point(0, 0), Point(0, 0)]
-nodes_acceleration: list[Point] = [Point(0, 0), Point(0, 0), Point(0, 0), Point(0, 0)]
-nodes_force: list[Point] = [Point(0, 0), Point(0, 0), Point(0, 0), Point(0, 0)]
-
-links: int = 6
-links_nodes: list[tuple[int, int]] = [(0, 1), (1, 2), (2, 3), (3, 0), (0, 2), (1, 3)]
-links_resting: list[float] = [0.9, 0.9, 0.9, 0.9, 1.3, 1.3]
-links_distance: list[float] = [nan, nan, nan, nan, nan, nan]
-links_stiffness: list[float] = [100, 100, 100, 100, 100, 100]
-links_dampening: list[float] = [10, 10, 10, 10, 10, 10]
-links_speed: list[float] = [0, 0, 0, 0, 0, 0]
+cloth_nodes: int = 25
+nodes_references: list[list[int]] = [[y * isqrt(cloth_nodes) + x for x in range(isqrt(cloth_nodes))] for y in range(isqrt(cloth_nodes))]
+
+nodes: int = cloth_nodes
+nodes_mass: list[float] = [1 for n in range(cloth_nodes)]
+nodes_position: list[Point] = [Point(x, y) for y in range(isqrt(cloth_nodes)) for x in range(isqrt(cloth_nodes))]
+nodes_velocity: list[Point] = [Point(0, 0) for n in range(cloth_nodes)]
+nodes_acceleration: list[Point] = [Point(0, 0) for n in range(cloth_nodes)]
+nodes_force: list[Point] = [Point(0, 0) for n in range(cloth_nodes)]
+
+links: int = 2 * (isqrt(cloth_nodes) * (isqrt(cloth_nodes) - 1) + (isqrt(cloth_nodes) - 1) ** 2)
+links_nodes: list[tuple[int, int]] = []
+links_resting: list[float] = []
+links_distance: list[float] = []
+links_stiffness: list[float] = []
+links_dampening: list[float] = []
+links_speed: list[float] = []
+
+# Adding horizontal springs
+for y in range(isqrt(cloth_nodes)):
+    for x in range(isqrt(cloth_nodes) - 1):
+        links_nodes.append((nodes_references[y][x], nodes_references[y][x + 1]))
+        links_resting.append(0.9)
+        links_distance.append(nan)
+        links_stiffness.append(200)
+        links_dampening.append(5)
+        links_speed.append(0)
+
+# Adding vertical springs
+for x in range(isqrt(cloth_nodes)):
+    for y in range(isqrt(cloth_nodes) - 1):
+        links_nodes.append((nodes_references[y][x], nodes_references[y + 1][x]))
+        links_resting.append(0.9)
+        links_distance.append(nan)
+        links_stiffness.append(200)
+        links_dampening.append(5)
+        links_speed.append(0)
+
+# Adding diagonal springs
+for x in range(isqrt(cloth_nodes) - 1):
+    for y in range(isqrt(cloth_nodes) - 1):
+        links_nodes.append((nodes_references[x][y], nodes_references[x + 1][y + 1]))
+        links_resting.append(1.3)
+        links_distance.append(nan)
+        links_stiffness.append(200)
+        links_dampening.append(5)
+        links_speed.append(0)
+for x in range(isqrt(cloth_nodes) - 1):
+    for y in range(isqrt(cloth_nodes) - 1):
+        links_nodes.append((nodes_references[x][y + 1], nodes_references[x + 1][y]))
+        links_resting.append(1.3)
+        links_distance.append(nan)
+        links_stiffness.append(200)
+        links_dampening.append(5)
+        links_speed.append(0)
 
 iterations: int = 10000
-time_step: float = 0.0001
+time_step: float = 0.001
 view_minimum = Point(-1, -1)
-view_maximum = Point(2, 2)
+view_maximum = Point(6, 6)
 
 pygame.init()
 screen = pygame.display.set_mode([1000, 1000])
@@ -31,7 +71,7 @@ screen = pygame.display.set_mode([1000, 1000])
 
 def transform(point: Point) -> Point:
     return Point(1000 * (point.x - view_minimum.x) / (view_maximum.x - view_minimum.x),
-                 1000 * (point.y - view_minimum.y) / (view_maximum.y - view_minimum.y))
+                 1000 * (1 - (point.y - view_minimum.y) / (view_maximum.y - view_minimum.y)))
 
 
 for i in range(iterations):
@@ -64,14 +104,18 @@ for i in range(iterations):
 
     # Integration
     for n in range(nodes):
-        print(*nodes_force[n])
         nodes_acceleration[n] = nodes_force[n] / nodes_mass[n]
         nodes_velocity[n] += nodes_acceleration[n] * time_step
+
+        if n == 24:
+            pass
+            continue
+
         nodes_position[n] += nodes_velocity[n] * time_step
 
     # Conditions
-    nodes_position[0].set(Point(0, 0))
-    nodes_position[1].set(Point(1, 0))
+    # enter here
+
 
     screen.fill((255, 255, 255))
 
@@ -79,11 +123,11 @@ for i in range(iterations):
         link_nodes = links_nodes[l]
         transformed_1 = transform(nodes_position[link_nodes[0]])
         transformed_2 = transform(nodes_position[link_nodes[1]])
-        pygame.draw.line(screen, (0, 0, 255), (transformed_1.x, transformed_1.y), (transformed_2.x, transformed_2.y), 3)
+        pygame.draw.line(screen, (255, 0, 0), (transformed_1.x, transformed_1.y), (transformed_2.x, transformed_2.y), 3)
 
     for n in range(nodes):
         transformed = transform(nodes_position[n])
-        pygame.draw.circle(screen, (255, 0, 0), (transformed.x, transformed.y), 10)
+        pygame.draw.circle(screen, (0, 0, 255), (transformed.x, transformed.y), 10)
 
     pygame.display.flip()
 

commit 2c78c1913db7bec56bf223340b7d2fd7e1b4e431
Author: Elias <elias@dobrin.net>
Date:   Tue Mar 22 16:48:44 2022 -0700

    basic rendering and physics engine implemented (MVP)

diff --git a/cloth.py b/cloth.py
new file mode 100644
index 0000000..9e0c270
--- /dev/null
+++ b/cloth.py
@@ -0,0 +1,90 @@
+from math import nan, isnan
+from time import sleep
+from scipy.constants import g
+import pygame
+from points import Point
+
+
+nodes: int = 4
+nodes_mass: list[float] = [1, 1, 1, 1]
+nodes_position: list[Point] = [Point(0, 0), Point(1, 0), Point(1, 1), Point(0, 1)]
+nodes_velocity: list[Point] = [Point(0, 0), Point(0, 0), Point(0, 0), Point(0, 0)]
+nodes_acceleration: list[Point] = [Point(0, 0), Point(0, 0), Point(0, 0), Point(0, 0)]
+nodes_force: list[Point] = [Point(0, 0), Point(0, 0), Point(0, 0), Point(0, 0)]
+
+links: int = 6
+links_nodes: list[tuple[int, int]] = [(0, 1), (1, 2), (2, 3), (3, 0), (0, 2), (1, 3)]
+links_resting: list[float] = [0.9, 0.9, 0.9, 0.9, 1.3, 1.3]
+links_distance: list[float] = [nan, nan, nan, nan, nan, nan]
+links_stiffness: list[float] = [100, 100, 100, 100, 100, 100]
+links_dampening: list[float] = [10, 10, 10, 10, 10, 10]
+links_speed: list[float] = [0, 0, 0, 0, 0, 0]
+
+iterations: int = 10000
+time_step: float = 0.0001
+view_minimum = Point(-1, -1)
+view_maximum = Point(2, 2)
+
+pygame.init()
+screen = pygame.display.set_mode([1000, 1000])
+
+
+def transform(point: Point) -> Point:
+    return Point(1000 * (point.x - view_minimum.x) / (view_maximum.x - view_minimum.x),
+                 1000 * (point.y - view_minimum.y) / (view_maximum.y - view_minimum.y))
+
+
+for i in range(iterations):
+    # Clearing forces
+    for n in range(nodes):
+        nodes_force[n].set(Point(0, 0))
+
+    # Force of gravity
+    for n in range(nodes):
+        nodes_force[n].y -= nodes_mass[n] * g
+
+    for l in range(links):
+        link_nodes = links_nodes[l]
+        link_distance = Point.dist(nodes_position[link_nodes[0]], nodes_position[link_nodes[1]])
+
+        # Finding speed of expansion/contraction before distance set
+        if not isnan(links_distance[l]):
+            links_speed[l] = (link_distance - links_distance[l]) / time_step
+        else:
+            links_speed[l] = 0
+
+        links_distance[l] = link_distance
+
+        force_stiffness = -links_stiffness[l] * (link_distance - links_resting[l])
+        force_dampening = -links_dampening[l] * links_speed[l]
+        # Force of spring (one-sided)
+        force_spring = (force_stiffness + force_dampening) * (nodes_position[link_nodes[0]] - nodes_position[link_nodes[1]]) / link_distance
+        nodes_force[link_nodes[0]].add(force_spring)
+        nodes_force[link_nodes[1]].sub(force_spring)
+
+    # Integration
+    for n in range(nodes):
+        print(*nodes_force[n])
+        nodes_acceleration[n] = nodes_force[n] / nodes_mass[n]
+        nodes_velocity[n] += nodes_acceleration[n] * time_step
+        nodes_position[n] += nodes_velocity[n] * time_step
+
+    # Conditions
+    nodes_position[0].set(Point(0, 0))
+    nodes_position[1].set(Point(1, 0))
+
+    screen.fill((255, 255, 255))
+
+    for l in range(links):
+        link_nodes = links_nodes[l]
+        transformed_1 = transform(nodes_position[link_nodes[0]])
+        transformed_2 = transform(nodes_position[link_nodes[1]])
+        pygame.draw.line(screen, (0, 0, 255), (transformed_1.x, transformed_1.y), (transformed_2.x, transformed_2.y), 3)
+
+    for n in range(nodes):
+        transformed = transform(nodes_position[n])
+        pygame.draw.circle(screen, (255, 0, 0), (transformed.x, transformed.y), 10)
+
+    pygame.display.flip()
+
+pygame.quit()
\ No newline at end of file
diff --git a/points.py b/points.py
index d159624..08c2310 100644
--- a/points.py
+++ b/points.py
@@ -11,7 +11,7 @@ class Point:
     y: float
     z: float
 
-    def __init__(self, x: float, y: float, z: float) -> None:
+    def __init__(self, x: float, y: float, z: float = 0) -> None:
         """Instantiate a point from cartesian coordinates."""
         self.x = x
         self.y = y

commit a5091d5144790d253d0ca1c9afb5c7f133c0423a
Author: Elias <elias@dobrin.net>
Date:   Tue Mar 22 15:18:20 2022 -0700

    fix

diff --git a/points.py b/points.py
index 5ed4058..d159624 100644
--- a/points.py
+++ b/points.py
@@ -9,6 +9,7 @@ class Point:
     """Three-dimensional point represented in cartesian coordinates."""
     x: float
     y: float
+    z: float
 
     def __init__(self, x: float, y: float, z: float) -> None:
         """Instantiate a point from cartesian coordinates."""

commit ea5a091822c49cd789385656ef620c35858af161
Author: Elias <elias@dobrin.net>
Date:   Tue Mar 22 15:18:05 2022 -0700

    converted to 3d points in points library

diff --git a/points.py b/points.py
index 5fe6c40..5ed4058 100644
--- a/points.py
+++ b/points.py
@@ -1,24 +1,26 @@
-"""Python module for dealing with two-dimensional cartesian coordinates and vector operations."""
+"""Python module for dealing with three-dimensional cartesian coordinates and vector operations."""
 
 from __future__ import annotations
-from math import cos, hypot, sin, atan2
+from math import hypot
 from collections.abc import Iterator
 
 
 class Point:
-    """Two-dimensional point represented in cartesian coordinates."""
+    """Three-dimensional point represented in cartesian coordinates."""
     x: float
     y: float
 
-    def __init__(self, x: float, y: float) -> None:
+    def __init__(self, x: float, y: float, z: float) -> None:
         """Instantiate a point from cartesian coordinates."""
         self.x = x
         self.y = y
+        self.z = z
 
     def __iter__(self) -> Iterator[float]:
         """Iterate through the pair of coordinates."""
         yield self.x
         yield self.y
+        yield self.z
 
     def __add__(self, point: Point, /) -> Point:
         """(+) Add caller point with parameter point, without modification to point."""
@@ -68,7 +70,7 @@ class Point:
         """(@) Find the dot product of two points as vectors."""
         return self.dot(point)
 
-    def __mod__(self, point: Point, /) -> float:
+    def __mod__(self, point: Point, /) -> Point:
         """(%) Find the cross product of two points as vectors."""
         return self.cross(point)
 
@@ -76,55 +78,55 @@ class Point:
         """Set coordinates of caller point to match parameter point."""
         self.x = point.x
         self.y = point.y
+        self.z = point.z
         return self
 
     def add(self, point: Point, /) -> Point:
         """Add caller point with parameter point, with modification to caller point."""
         self.x += point.x
         self.y += point.y
+        self.z += point.z
         return self
 
     def sub(self, point: Point, /) -> Point:
         """Subtract parameter point from caller point, with modification to caller point."""
         self.x -= point.x
         self.y -= point.y
+        self.z -= point.z
         return self
 
     def mul(self, multiplier: float, /) -> Point:
         """Multiply point coordinates by a number, with modification to point."""
         self.x *= multiplier
         self.y *= multiplier
+        self.z *= multiplier
         return self
 
     def div(self, divisor: float, /) -> Point:
         """Divide point coordinates by a number, with modification to point."""
         self.x /= divisor
         self.y /= divisor
+        self.z /= divisor
         return self
 
     def len(self) -> float:
         """Find the distance to the origin."""
-        return hypot(self.x, self.y)
+        return hypot(self.x, self.y, self.z)
 
     def dist(self, point: Point, /) -> float:
         """Find the distance between two points."""
-        return hypot(self.x - point.x, self.y - point.y)
-
-    def angle(self, point: Point, /) -> float:
-        return atan2(self.y - point.y, self.x - point.x)
+        return hypot(self.x - point.x, self.y - point.y, self.z - point.z)
 
     def dot(self, point: Point, /) -> float:
         """Find the dot product of two points."""
-        return self.x * point.x + self.y * point.y
+        return self.x * point.x + self.y * point.y + self.z * point.z
 
-    def cross(self, point: Point, /) -> float:
+    def cross(self, point: Point, /) -> Point:
         """Find the cross product of two points."""
-        return self.x * point.y - self.y * point.x
+        return Point(self.y * point.z - self.z * point.y,
+                     self.z * point.x - self.x * point.z,
+                     self.x * point.y - self.y * point.x)
 
     def copy(self) -> Point:
         """Copy the point instance."""
-        return Point(self.x, self.y)
-
-    @classmethod
-    def polar(cls, r: float, t: float) -> Point:
-        return cls(r * cos(t), r * sin(t))
+        return Point(self.x, self.y, self.z)

commit dbbdeed590e7afc559f194706796a7d3eccc6bc7
Author: Daxonus <elias@dobrin.net>
Date:   Sun Feb 20 21:29:23 2022 -0800

    buggy physics

diff --git a/main.py b/main.py
new file mode 100644
index 0000000..607fb28
--- /dev/null
+++ b/main.py
@@ -0,0 +1,44 @@
+import pygame
+from softbodies import Softbody, Node, Link, Point
+
+nodes = [[Node(mass=1, position=Point(x / 4, y / 4), velocity=Point(0, 0)) for y in range(5)] for x in range(5)]
+softbody = Softbody(nodes=[node for node_buffer in nodes for node in node_buffer],
+                    links=[])
+
+for x in range(len(nodes)):
+    for y in range(len(nodes[0]) - 1):
+        softbody.links.append(Link(nodes[x][y], nodes[x][y + 1]))
+
+for y in range(len(nodes[0])):
+    for x in range(len(nodes) - 1):
+        softbody.links.append(Link(nodes[x][y], nodes[x + 1][y]))
+
+minimum = Point(-5, -5)
+maximum = Point(5, 5)
+
+
+def transform(point: Point) -> Point:
+    return Point(500 * (point.x - minimum.x) / (maximum.x - minimum.x), 500 * (point.y - minimum.y) / (maximum.y - minimum.y))
+
+
+pygame.init()
+screen = pygame.display.set_mode([500, 500])
+
+running = True
+while running:
+    for event in pygame.event.get():
+        if event.type == pygame.QUIT:
+            running = False
+
+    screen.fill((255, 255, 255))
+
+    for node in softbody.nodes:
+        transformed = transform(node.position)
+        pygame.draw.circle(screen, (0, 0, 255), (transformed.x, transformed.y), 3)
+
+    softbody.iterate(0.001)
+    softbody.nodes[0].position = Point(-1, -1)
+
+    pygame.display.flip()
+
+pygame.quit()
\ No newline at end of file
diff --git a/points.py b/points.py
index dc0d4af..5fe6c40 100644
--- a/points.py
+++ b/points.py
@@ -1,7 +1,7 @@
 """Python module for dealing with two-dimensional cartesian coordinates and vector operations."""
 
 from __future__ import annotations
-from math import cos, hypot, sin
+from math import cos, hypot, sin, atan2
 from collections.abc import Iterator
 
 
@@ -110,6 +110,9 @@ class Point:
         """Find the distance between two points."""
         return hypot(self.x - point.x, self.y - point.y)
 
+    def angle(self, point: Point, /) -> float:
+        return atan2(self.y - point.y, self.x - point.x)
+
     def dot(self, point: Point, /) -> float:
         """Find the dot product of two points."""
         return self.x * point.x + self.y * point.y
diff --git a/softbodies.py b/softbodies.py
index 1190ea2..8f256a1 100644
--- a/softbodies.py
+++ b/softbodies.py
@@ -6,12 +6,9 @@ class Softbody:
     nodes: list[Node]
     links: list[Link]
 
-    def __init__(self, nodes: list[Node], links: list[Link] = None) -> None:
+    def __init__(self, nodes: list[Node], links: list[Link]) -> None:
         self.nodes = nodes
-        if links is not None:
-            self.links = links
-        else:
-            self.links = []
+        self.links = links
 
     def iterate(self, time: float) -> None:
         for node in self.nodes:
@@ -20,9 +17,9 @@ class Softbody:
         for link in self.links:
             node_1 = link.node_1
             node_2 = link.node_2
-            force = 1.0 * (node_1.position.dist(node_2.position) - link.distance) * (node_2.position - node_1.position) / node_1.position.dist(node_2.position)
-            node_1.force += force
-            node_2.force -= force
+            force = Point.polar(10 * (node_1.position.dist(node_2.position) - link.distance), node_1.position.angle(node_2.position))
+            node_1.force -= force
+            node_2.force += force
 
         for node in self.nodes:
             node.iterate(time)

commit 28fa798d64de9f273da590ba9b8843af0cc0912b
Author: Daxonus <elias@dobrin.net>
Date:   Sun Feb 20 18:53:18 2022 -0800

    added force calculation

diff --git a/points.py b/points.py
index 2e5dff2..dc0d4af 100644
--- a/points.py
+++ b/points.py
@@ -121,3 +121,7 @@ class Point:
     def copy(self) -> Point:
         """Copy the point instance."""
         return Point(self.x, self.y)
+
+    @classmethod
+    def polar(cls, r: float, t: float) -> Point:
+        return cls(r * cos(t), r * sin(t))
diff --git a/softbodies.py b/softbodies.py
index 4fb3512..1190ea2 100644
--- a/softbodies.py
+++ b/softbodies.py
@@ -6,6 +6,27 @@ class Softbody:
     nodes: list[Node]
     links: list[Link]
 
+    def __init__(self, nodes: list[Node], links: list[Link] = None) -> None:
+        self.nodes = nodes
+        if links is not None:
+            self.links = links
+        else:
+            self.links = []
+
+    def iterate(self, time: float) -> None:
+        for node in self.nodes:
+            node.force = Point(0, -9.88 * node.mass)
+
+        for link in self.links:
+            node_1 = link.node_1
+            node_2 = link.node_2
+            force = 1.0 * (node_1.position.dist(node_2.position) - link.distance) * (node_2.position - node_1.position) / node_1.position.dist(node_2.position)
+            node_1.force += force
+            node_2.force -= force
+
+        for node in self.nodes:
+            node.iterate(time)
+
 
 class Node:
     mass: float
@@ -13,13 +34,17 @@ class Node:
     velocity: Point
     force: Point
 
-    def __init__(self, mass: float) -> None:
+    def __init__(self, mass: float, position: Point, velocity: Point) -> None:
         self.mass = mass
+        self.position = position
+        self.velocity = velocity
+        self.force = Point(0, 0)
 
-    def iterate(self, time: float):
+    def iterate(self, time: float) -> None:
         self.velocity += self.force * (time / self.mass)
         self.position += self.velocity * time
 
+
 class Link:
     node_1: Node
     node_2: Node
@@ -28,7 +53,7 @@ class Link:
     def __init__(self, node_1: Node, node_2: Node, distance: float = None) -> None:
         self.node_1 = node_1
         self.node_2 = node_2
-        if distance is None:
-            self.distance = node_1.position.dist(node_2.position)
+        if distance is not None:
+            self.distance = distance
         else:
-            self.distance = distance
\ No newline at end of file
+            self.distance = node_1.position.dist(node_2.position)
\ No newline at end of file

commit 8a4558f6b663d7303031ea14fab29fb7ce0cbf0b
Author: Daxonus <elias@dobrin.net>
Date:   Sun Feb 20 18:21:06 2022 -0800

    initial structure

diff --git a/.idea/.gitignore b/.idea/.gitignore
new file mode 100644
index 0000000..13566b8
--- /dev/null
+++ b/.idea/.gitignore
@@ -0,0 +1,8 @@
+# Default ignored files
+/shelf/
+/workspace.xml
+# Editor-based HTTP Client requests
+/httpRequests/
+# Datasource local storage ignored files
+/dataSources/
+/dataSources.local.xml
diff --git a/.idea/inspectionProfiles/profiles_settings.xml b/.idea/inspectionProfiles/profiles_settings.xml
new file mode 100644
index 0000000..105ce2d
--- /dev/null
+++ b/.idea/inspectionProfiles/profiles_settings.xml
@@ -0,0 +1,6 @@
+<component name="InspectionProjectProfileManager">
+  <settings>
+    <option name="USE_PROJECT_PROFILE" value="false" />
+    <version value="1.0" />
+  </settings>
+</component>
\ No newline at end of file
diff --git a/.idea/misc.xml b/.idea/misc.xml
new file mode 100644
index 0000000..dc9ea49
--- /dev/null
+++ b/.idea/misc.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.10" project-jdk-type="Python SDK" />
+</project>
\ No newline at end of file
diff --git a/.idea/modules.xml b/.idea/modules.xml
new file mode 100644
index 0000000..e88184b
--- /dev/null
+++ b/.idea/modules.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectModuleManager">
+    <modules>
+      <module fileurl="file://$PROJECT_DIR$/.idea/softbodies.iml" filepath="$PROJECT_DIR$/.idea/softbodies.iml" />
+    </modules>
+  </component>
+</project>
\ No newline at end of file
diff --git a/.idea/softbodies.iml b/.idea/softbodies.iml
new file mode 100644
index 0000000..d0876a7
--- /dev/null
+++ b/.idea/softbodies.iml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="PYTHON_MODULE" version="4">
+  <component name="NewModuleRootManager">
+    <content url="file://$MODULE_DIR$" />
+    <orderEntry type="inheritedJdk" />
+    <orderEntry type="sourceFolder" forTests="false" />
+  </component>
+</module>
\ No newline at end of file
diff --git a/.idea/vcs.xml b/.idea/vcs.xml
new file mode 100644
index 0000000..94a25f7
--- /dev/null
+++ b/.idea/vcs.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="VcsDirectoryMappings">
+    <mapping directory="$PROJECT_DIR$" vcs="Git" />
+  </component>
+</project>
\ No newline at end of file
diff --git a/points.py b/points.py
new file mode 100644
index 0000000..2e5dff2
--- /dev/null
+++ b/points.py
@@ -0,0 +1,123 @@
+"""Python module for dealing with two-dimensional cartesian coordinates and vector operations."""
+
+from __future__ import annotations
+from math import cos, hypot, sin
+from collections.abc import Iterator
+
+
+class Point:
+    """Two-dimensional point represented in cartesian coordinates."""
+    x: float
+    y: float
+
+    def __init__(self, x: float, y: float) -> None:
+        """Instantiate a point from cartesian coordinates."""
+        self.x = x
+        self.y = y
+
+    def __iter__(self) -> Iterator[float]:
+        """Iterate through the pair of coordinates."""
+        yield self.x
+        yield self.y
+
+    def __add__(self, point: Point, /) -> Point:
+        """(+) Add caller point with parameter point, without modification to point."""
+        return self.copy().add(point)
+
+    def __iadd__(self, point: Point, /) -> Point:
+        """(+=) Add caller point with parameter point, with modification to caller point."""
+        return self.add(point)
+
+    def __sub__(self, point: Point, /) -> Point:
+        """(-) Subtract parameter point from caller point, without modification to point."""
+        return self.copy().sub(point)
+
+    def __isub__(self, point: Point, /) -> Point:
+        """(-=) Subtract parameter point from caller point, with modification to caller point."""
+        return self.sub(point)
+
+    def __mul__(self, multiplier: float, /) -> Point:
+        """(*) Multiply point coordinates by a number, without modification to point."""
+        return self.copy().mul(multiplier)
+
+    def __rmul__(self, multiplier: float, /) -> Point:
+        """(*) Multiply point coordinates by a number, without modification to point."""
+        return self.copy().mul(multiplier)
+
+    def __imul__(self, multiplier: float, /) -> Point:
+        """(*=) Multiply point coordinates by a number, with modification to point."""
+        return self.mul(multiplier)
+
+    def __truediv__(self, divisor: float, /) -> Point:
+        """(/) Divide point coordinates by a number, without modification to point."""
+        return self.copy().div(divisor)
+
+    def __itruediv__(self, divisor: float, /) -> Point:
+        """(/=) Divide point coordinates by a number, with modification to point."""
+        return self.div(divisor)
+
+    def __pos__(self) -> Point:
+        """(+) Return the same point instance."""
+        return self
+
+    def __neg__(self) -> Point:
+        """(-) Flip the sign of point coordinates, without modification to point."""
+        return self.copy().mul(-1)
+
+    def __matmul__(self, point: Point, /) -> float:
+        """(@) Find the dot product of two points as vectors."""
+        return self.dot(point)
+
+    def __mod__(self, point: Point, /) -> float:
+        """(%) Find the cross product of two points as vectors."""
+        return self.cross(point)
+
+    def set(self, point: Point, /) -> Point:
+        """Set coordinates of caller point to match parameter point."""
+        self.x = point.x
+        self.y = point.y
+        return self
+
+    def add(self, point: Point, /) -> Point:
+        """Add caller point with parameter point, with modification to caller point."""
+        self.x += point.x
+        self.y += point.y
+        return self
+
+    def sub(self, point: Point, /) -> Point:
+        """Subtract parameter point from caller point, with modification to caller point."""
+        self.x -= point.x
+        self.y -= point.y
+        return self
+
+    def mul(self, multiplier: float, /) -> Point:
+        """Multiply point coordinates by a number, with modification to point."""
+        self.x *= multiplier
+        self.y *= multiplier
+        return self
+
+    def div(self, divisor: float, /) -> Point:
+        """Divide point coordinates by a number, with modification to point."""
+        self.x /= divisor
+        self.y /= divisor
+        return self
+
+    def len(self) -> float:
+        """Find the distance to the origin."""
+        return hypot(self.x, self.y)
+
+    def dist(self, point: Point, /) -> float:
+        """Find the distance between two points."""
+        return hypot(self.x - point.x, self.y - point.y)
+
+    def dot(self, point: Point, /) -> float:
+        """Find the dot product of two points."""
+        return self.x * point.x + self.y * point.y
+
+    def cross(self, point: Point, /) -> float:
+        """Find the cross product of two points."""
+        return self.x * point.y - self.y * point.x
+
+    def copy(self) -> Point:
+        """Copy the point instance."""
+        return Point(self.x, self.y)
diff --git a/softbodies.py b/softbodies.py
new file mode 100644
index 0000000..4fb3512
--- /dev/null
+++ b/softbodies.py
@@ -0,0 +1,34 @@
+from __future__ import annotations
+from points import Point
+
+
+class Softbody:
+    nodes: list[Node]
+    links: list[Link]
+
+
+class Node:
+    mass: float
+    position: Point
+    velocity: Point
+    force: Point
+
+    def __init__(self, mass: float) -> None:
+        self.mass = mass
+
+    def iterate(self, time: float):
+        self.velocity += self.force * (time / self.mass)
+        self.position += self.velocity * time
+
+class Link:
+    node_1: Node
+    node_2: Node
+    distance: float
+
+    def __init__(self, node_1: Node, node_2: Node, distance: float = None) -> None:
+        self.node_1 = node_1
+        self.node_2 = node_2
+        if distance is None:
+            self.distance = node_1.position.dist(node_2.position)
+        else:
+            self.distance = distance
\ No newline at end of file

commit 461c0f079978ff124202b81e91edaf582bc177dd
Author: Daxonus <elias@dobrin.net>
Date:   Sun Feb 20 17:50:15 2022 -0800

    Initial commit

diff --git a/.gitattributes b/.gitattributes
new file mode 100644
index 0000000..dfe0770
--- /dev/null
+++ b/.gitattributes
@@ -0,0 +1,2 @@
+# Auto detect text files and perform LF normalization
+* text=auto
